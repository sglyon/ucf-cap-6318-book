{"version":"1","records":[{"hierarchy":{"lvl1":"Welcome"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Welcome"},"content":"Computational Analysis of Social Complexity\n\nFall 2025, Spencer Lyon\n\nWelcome to week 1!\n\nThis week we will get to know eachother and get on the same page with respect to what this class is all about.\n\nWe will also dive right in to the computational infrastructure we will need by installing the Julia programming langauge and learning a bit about how to use it.\n\nEach week lecture notes will be distributed as a collection of Jupyter notebooks. The notebooks will follow a strict naming convention, where each notebook has a name such as L@@.##_XXX.ipynb where @@ is a two digit lecture number and ## is a two digit file number and XXX is one or more words describing the content of the notebook. We will work through the notebooks in the order indicated by the ##. The XXX are to provide easier access when reviewing notes after class.\n\n","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Welcome","lvl2":"About Me"},"type":"lvl2","url":"/#about-me","position":2},{"hierarchy":{"lvl1":"Welcome","lvl2":"About Me"},"content":"Spencer Lyon (\n\nspencer​.lyon@ucf​.edu)\n\nEconomics PhD from NYU (2018)\n\nLove to teach: mostly economics, data science, AI/ML – all have\nprogramming/computational element\n\nMoved to Orlando in July 2018 with wife and 5 (yes!) kids\n\nRun consulting (training/projects) business:   Valorum Data\n\nWorking on a couple startups\n\n","type":"content","url":"/#about-me","position":3},{"hierarchy":{"lvl1":"Welcome","lvl2":"About you"},"type":"lvl2","url":"/#about-you","position":4},{"hierarchy":{"lvl1":"Welcome","lvl2":"About you"},"content":"Background?\n\nProgress in program?\n\nAreas of interest? (meaningful answers here! they matter…)\n\nRumors about the course?\n\n","type":"content","url":"/#about-you","position":5},{"hierarchy":{"lvl1":"Welcome","lvl2":"About the course"},"type":"lvl2","url":"/#about-the-course","position":6},{"hierarchy":{"lvl1":"Welcome","lvl2":"About the course"},"content":"Interdisciplinary by nature\n\n“Living course”: only been taught a handful of times, content is flexible\n\nMore ideas/topics than time!\n\nHas been altered fairly significantly over the past few years (but the heart/soul of the course remains the same)\n\nNo required topics or standard textbook, so we get to pick!\n\nTheoretical concepts\n\nGraphs: less detail than network science course, but more algorithms\n\nGame Theory: strategic interaction/competition\n\nAgent Based Models: simulation of rule based systems\n\nAuction theory: Game theory at scale in bidding markets\n\nBlockchain: cryptographically secure, public, distributed ledger\n\nSocial, information, financial networks\n\nApplications\n\nTwitter\n\nEconomic markets and trade\nnetwork\n\nMore...\n\n","type":"content","url":"/#about-the-course","position":7},{"hierarchy":{"lvl1":"Welcome","lvl2":"Expectations"},"type":"lvl2","url":"/#expectations","position":8},{"hierarchy":{"lvl1":"Welcome","lvl2":"Expectations"},"content":"Take the time in the first 2 weeks to learn Julia\n\nYou’ll be glad you did\n\nContent moves quick and you don’t want syntax/programming to distract you or hold you back\n\nStudy reading assignments before class\n\nComplete assignments on time -- no exceptions\n\nParticipate in in-class discussions\n\nSpend ~3-6 hours outside of class per week\n\nCommunication\n\nPost all content related questions to class discussion forum\n\nRespond to peers’ questions and engage in discussions\n\nPersonal questions should go directly to me via email\n\nI do not use email on Sunday. Other days I will respond within 48 hours.\n\nDeliverables\n\nHomework (~8 – 30%)\n\nExam (2 – 30%)\n\nProjects (2 – 30%)\n\nCitizenship (throughout - 10%)\n\nFirst best: attend class in person, actively participate\n\nAcceptable: attend virtually, but keep video on and be ready to speak up when called on\n\nUnacceptable: attend virtually, but keep video off and/or don’t participate in discussions\n\n","type":"content","url":"/#expectations","position":9},{"hierarchy":{"lvl1":"Welcome","lvl2":"Tools/Resources"},"type":"lvl2","url":"/#tools-resources","position":10},{"hierarchy":{"lvl1":"Welcome","lvl2":"Tools/Resources"},"content":"Core textbooks\n\nNetworks, Crowds, and Markets by David Easley and Jon Kleinberg\n\nEconomics Networks by John Stachurski and Thomas Sargent\n\nWill be supplemented by lecture notes for more computational content\n\nJulia Programming language\n\nLecture notes are accessible via the \n\ncourse website\n\nLecture notes AND assignments in Jupyter notebooks\n\nAll course administration will happen through webcourses (Canvas)\n\nAssignments me <-> you\n\nFeedback on assignments me -> you\n\nDiscussion me + you <-> me + you\n\nOfficial grades will be visible on canvas","type":"content","url":"/#tools-resources","position":11},{"hierarchy":{"lvl1":"Julia Setup"},"type":"lvl1","url":"/l01-02-setup","position":0},{"hierarchy":{"lvl1":"Julia Setup"},"content":"Computational Analysis of Social Complexity\n\nFall 2025, Spencer Lyon\n\nPrerequisites\n\nLaptop or personal computer with internet connection\n\nOutcomes\n\nInstall Julia and IJulia locally\n\nInstall VS Code\n\nOpen lecture notes locally\n\nReferences\n\nLecture notes\n\nQuantEcon lectures\n\nSetting up Julia\n\nGit, GitHub, Version Control\n\nJulia tools and editors\n\n","type":"content","url":"/l01-02-setup","position":1},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Step 1: Install Julia"},"type":"lvl2","url":"/l01-02-setup#step-1-install-julia","position":2},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Step 1: Install Julia"},"content":"The first step is to install Julia\n\n","type":"content","url":"/l01-02-setup#step-1-install-julia","position":3},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Install Julia","lvl2":"Step 1: Install Julia"},"type":"lvl3","url":"/l01-02-setup#task-install-julia","position":4},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Install Julia","lvl2":"Step 1: Install Julia"},"content":"Windows: windows users can install Julia from the microsoft store OR by running winget install --name Julia --id 9NJNWW8PVKMN -e -s msstore from powershell\n\nMac/Linux: Open terminal and run curl -fsSL https://install.julialang.org | sh (it is safe -- I promise ;))\n\n","type":"content","url":"/l01-02-setup#task-install-julia","position":5},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Launch Julia REPL","lvl2":"Step 1: Install Julia"},"type":"lvl3","url":"/l01-02-setup#task-launch-julia-repl","position":6},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Launch Julia REPL","lvl2":"Step 1: Install Julia"},"content":"Launch the Julia REPL (read-eval-print-loop) by clicking on the Julia icon or running julia from your shell (PowerShell or Terminal)\n\nYou will be greeted with a prompt that looks like this:   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.11.6 (2025-07-09)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> \n\nYou are now in what is called the Julia REPL (read-eval-print-loop). This is a place where you can type Julia commands and have them executed immediately.\n\nTest it out by typing rand(2, 2) and pressing enter\n\nYou should see something like this (note the numbers will be different for you):julia> rand(2, 2)\n2×2 Matrix{Float64}:\n 0.698944  0.676245\n 0.17375   0.448243\n\nCongratulations! You have successfully installed Julia and are ready to move on to the next step!\n\n","type":"content","url":"/l01-02-setup#task-launch-julia-repl","position":7},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Step 2: Install IJulia.jl"},"type":"lvl2","url":"/l01-02-setup#step-2-install-ijulia-jl","position":8},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Step 2: Install IJulia.jl"},"content":"With Julia installed we are now ready to install some Julia packages\n\nThe first package we’ll be using is called IJulia\n\nThis is a package integrates with Jupyter to allow us to run Julia code from notebooks\n\nSame Jupyter you may have used with Python\n\n","type":"content","url":"/l01-02-setup#step-2-install-ijulia-jl","position":9},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Install IJulia","lvl2":"Step 2: Install IJulia.jl"},"type":"lvl3","url":"/l01-02-setup#task-install-ijulia","position":10},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Install IJulia","lvl2":"Step 2: Install IJulia.jl"},"content":"Launch the Julia REPL (by typing julia from the Linux/OSX terminal prompt or using the start menu on Windows)\n\nAt the juila> prompt, type ]\n\nPrompt will switch to (@v1.11) pkg> \n\nOnce there type add IJulia and press enter\n\nIJulia.jl will be downloaded and installed on your machine\n\n","type":"content","url":"/l01-02-setup#task-install-ijulia","position":11},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Start IJulia","lvl2":"Step 2: Install IJulia.jl"},"type":"lvl3","url":"/l01-02-setup#task-start-ijulia","position":12},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Start IJulia","lvl2":"Step 2: Install IJulia.jl"},"content":"At the juila> prompt (press backspace to exit Pkg mode if needed), type using IJulia\n\nThen run the command: IJulia.notebook()\n\nA web browser should pop open with the IJulia.jl interface (should look similar to what I’m using)\n\n","type":"content","url":"/l01-02-setup#task-start-ijulia","position":13},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Step 3: Install Visual Studio Code"},"type":"lvl2","url":"/l01-02-setup#step-3-install-visual-studio-code","position":14},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Step 3: Install Visual Studio Code"},"content":"While we can and will use the native Julia REPL and first-party Jupyter software for our lecture notes, it is also helpful to have the ability to edit and run Julia code in a more full-featured editor\n\nFor this we will use Visual Studio Code (VSCode)\n\nVSCode is a free, open-source, cross-platform editor that has a large community of users and developers\n\nIt also has great support for Julia\n\nLearning how to use a general purpose text editor will help you in the long run\n\nYou can use it for Julia, Python, R, C, C++, etc.\n\nYou can use it for writing papers, taking notes, etc.\n\nNote on VS Code alternatives: There are several popular forks/alternatives to VS Code that provide enhanced features, particularly for AI-assisted coding:\n\nCursor: An AI-first code editor built on VS Code with enhanced AI capabilities\n\nWindsurf: Another AI-powered editor with advanced coding assistance features\n\nThese alternatives generally maintain compatibility with VS Code extensions (including the Julia extension), so you can use any of them for this course if you prefer. The instructions below will work for VS Code and most of its forks.\n\n","type":"content","url":"/l01-02-setup#step-3-install-visual-studio-code","position":15},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Download/Install VS Code","lvl2":"Step 3: Install Visual Studio Code"},"type":"lvl3","url":"/l01-02-setup#task-download-install-vs-code","position":16},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Download/Install VS Code","lvl2":"Step 3: Install Visual Studio Code"},"content":"Download and install VSCode from \n\nhere\n\nFollow all system prompts and accept default options\n\nOpen/launch VSCode\n\n","type":"content","url":"/l01-02-setup#task-download-install-vs-code","position":17},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Install Julia extension","lvl2":"Step 3: Install Visual Studio Code"},"type":"lvl3","url":"/l01-02-setup#task-install-julia-extension","position":18},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Install Julia extension","lvl2":"Step 3: Install Visual Studio Code"},"content":"VSCode has a large ecosystem of extensions that add functionality to the editor\n\nWe will install the Julia extension to add Julia support to VSCode\n\nIn VSCode, click on the “Extensions” icon in the left-hand toolbar (looks like a box with four squares in it)\n\nSearch for “Julia” and click the “Install” button on the “Julia” extension (subtitle is “Julia Language Support”)\n\n","type":"content","url":"/l01-02-setup#task-install-julia-extension","position":19},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: run Julia code in VSCode","lvl2":"Step 3: Install Visual Studio Code"},"type":"lvl3","url":"/l01-02-setup#task-run-julia-code-in-vscode","position":20},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: run Julia code in VSCode","lvl2":"Step 3: Install Visual Studio Code"},"content":"We can now run Julia code in VSCode\n\nOpen a new file in VSCode (File -> New File)\n\nType the following code into the file:println(\"Hello world!\")\n\nSave the file as hello.jl in a location you can find later\n\nPress Ctrl + Shift + P (or Cmd + Shift + P on Mac) to open the command palette\n\nType “Julia” and select “Julia: Run file in new process”\n\nYou should see the output of the code show up in a new terminal window within VS Code\n\n","type":"content","url":"/l01-02-setup#task-run-julia-code-in-vscode","position":21},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: run code with shift + Enter","lvl2":"Step 3: Install Visual Studio Code"},"type":"lvl3","url":"/l01-02-setup#task-run-code-with-shift-enter","position":22},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: run code with shift + Enter","lvl2":"Step 3: Install Visual Studio Code"},"content":"Go back to hello.jl and add the coden = 5\nP = rand(n, n)\n\nThen, put your cursor on the line that contains n = and press shift and enter at the same time\n\nThis will start a new Julia REPL within your VS Code session and execute the code for you\n\nIt will also move your cursor down to the P = line. Press shift + enter again to execute that line\n\n","type":"content","url":"/l01-02-setup#task-run-code-with-shift-enter","position":23},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Open Notebooks Locally"},"type":"lvl2","url":"/l01-02-setup#open-notebooks-locally","position":24},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Open Notebooks Locally"},"content":"You should view/follow along with lectures on the your computer\n\nBeing able to run code on your machine is critical for success in this course and will allow you to take skills with you after the course\n\n","type":"content","url":"/l01-02-setup#open-notebooks-locally","position":25},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Download notebooks","lvl2":"Open Notebooks Locally"},"type":"lvl3","url":"/l01-02-setup#task-download-notebooks","position":26},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Download notebooks","lvl2":"Open Notebooks Locally"},"content":"Go to the course website and download the notebooks for the first week\n\nMove the downloaded folder from your “Downloads” folder to wherever you’d like to store materials for the semester\n\nFollow the instructions above to start Julia, load IJulia, and open the Jupyter notebook with IJulia\n\nInside your local Jupyter notebook instance (in your web browser), navigate to where you copied the “Handouts” folder and open up this notebook\n\n","type":"content","url":"/l01-02-setup#task-download-notebooks","position":27},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Open notebook in vscode","lvl2":"Open Notebooks Locally"},"type":"lvl3","url":"/l01-02-setup#task-open-notebook-in-vscode","position":28},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Open notebook in vscode","lvl2":"Open Notebooks Locally"},"content":"You can also run Jupyter notebooks directly in VS Code\n\nOpen VS Code and click on the “File” menu and select “Open Folder”\n\nNavigate to where you copied the notebooks for the first week\n\nClick on the “L01.02_setup.ipynb” file in the left-hand toolbar\n\nYou should see the notebook open in VS Code\n\nYou can run cells by clicking the “Run Cell” button in the top right of each cell, or by pressing Shift + Enter while your cursor is in the cell\n\nA menu will appear, choose the option containing Julia Release\n\nTest this out below\n\n# some random Julia code\nprintln(\"That's all, folks!\")","type":"content","url":"/l01-02-setup#task-open-notebook-in-vscode","position":29},{"hierarchy":{"lvl1":"Julia Foundations"},"type":"lvl1","url":"/l01-03-julia-basics","position":0},{"hierarchy":{"lvl1":"Julia Foundations"},"content":"Computational Analysis of Social Complexity\n\nFall 2025, Spencer Lyon\n\nPrerequisites\n\nLaptop or personal computer with internet connection\n\nOutcomes\n\nUnderstand the main benefits and features of Julia\n\nSee how to define variables, functions, and types in Julia\n\nInstall commonly used packages for Graphs, DataFrames, Plotting and more\n\nReferences\n\nPackages and Software Engineering sections of QuantEcon julia lectures\n\nJulia \n\ndocumentation\n\nDocumentation for packages: \n\nGraphs, \n\nDataFrames, \n\nPlots\n\n","type":"content","url":"/l01-03-julia-basics","position":1},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"What is Julia?"},"type":"lvl2","url":"/l01-03-julia-basics#what-is-julia","position":2},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"What is Julia?"},"content":"Julia is a relatively new programming language (first public release in 2012, 1.0 release in 2018)\n\nGeneral purpose, but specializes in numerical computation\n\nLeverages advanced compiler technology to generate very efficient code\n\nIt can be as clear to read and write as Python, and as quick to evaluate as C!\n\n","type":"content","url":"/l01-03-julia-basics#what-is-julia","position":3},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Core Types"},"type":"lvl2","url":"/l01-03-julia-basics#core-types","position":4},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Core Types"},"content":"We’ll start by learning about the core datatypes built in to Julia\n\nAlong the way we’ll pick up some of the key syntax elements\n\nWe will move quickly, so some prior programming experience would be helpful\n\n","type":"content","url":"/l01-03-julia-basics#core-types","position":5},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Numbers","lvl2":"Core Types"},"type":"lvl3","url":"/l01-03-julia-basics#numbers","position":6},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Numbers","lvl2":"Core Types"},"content":"Let’s start with numbers\n\nTo work with a number, just type it!\n\n42\n\nWe can also do basic arithmetic in the way you would expect\n\n10 * 3\n\n1 + 2\n\nSo far we’ve worked with integers (whole numbers)\n\nJulia can also work with numbers containing a decimal\n\nIn Julia these are called floating point numbers\n\n1.234 ^ 2.2  # use `^` for exponentiation, not `**` like in python\n\n553.34 / 12.9\n\nWe can mix and match integers and floats\n\n25 / 2.5\n\n25 / 2  # dividing integers returns a float (notice the `.`)\n\nnotice we used # to define a comment\n\n","type":"content","url":"/l01-03-julia-basics#numbers","position":7},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Text Data"},"type":"lvl2","url":"/l01-03-julia-basics#text-data","position":8},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Text Data"},"content":"Not all data is numerical\n\nSome is textual\n\nTo represent text in Julia we use a String\n\nTo define a String we use quotation marks (\") as below\n\n\"My name is Spencer\"\n\n\"1\"  # an integer in a string\n\nYou cannot use single quotes for strings as in other languages (like Python or Javascript)\n\nGo ahead... try it by removing the # and excuting the cell below\n\n# 'hello'\n\n\"\"\"\nThis\n\nis\n\nalso\n\na\n\nstring\n\"\"\"\n\n","type":"content","url":"/l01-03-julia-basics#text-data","position":9},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Arrays"},"type":"lvl2","url":"/l01-03-julia-basics#arrays","position":10},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Arrays"},"content":"When doing numerical work, we often need to deal with multiple pieces of data at the same time\n\nIn Julia the default way of doing this is to use an array\n\nArrays are defined with [ and ] as below\n\n[1, 2, 3.14]  # a 3 element array\n\n[1 2 3]  # a 1x3 matrix\n\n[1 2; 3 4]  # a 2x2 matrix\n\n[1 2\n 3 4]  # another way to write a 2x2 matrix\n\n[1 \"hello\"; 2 \"world\"]  # a 2x2 matrix with int and string\n\n","type":"content","url":"/l01-03-julia-basics#arrays","position":11},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Accessing array items","lvl2":"Arrays"},"type":"lvl3","url":"/l01-03-julia-basics#accessing-array-items","position":12},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Accessing array items","lvl2":"Arrays"},"content":"We can use [N] to access the Nth element\n\nWe can also use [i:j] to access items i through j\n\nFinally we can use [[n1, n2]] to access the n1th and n2th elements\n\n[100, 101, 102, 103][2]\n\n[100, 101, 102, 103][2:4]\n\n[100, 101, 102, 103][[1, 3]]\n\nNote that unlike Python, Julia starts counting at 1\n\nAlso note that end can be used to refer to the last element, end-1 to second to last, and so on\n\n[1, 2, 3, 4][end]\n\n[1, 2, 3, 4][end-2]\n\n","type":"content","url":"/l01-03-julia-basics#accessing-array-items","position":13},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Tuples"},"type":"lvl2","url":"/l01-03-julia-basics#tuples","position":14},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Tuples"},"content":"There is another data type for holding “lists” of data called a tuple\n\nTuples are create using parenthesis instead of square brackets as follows\n\n(1, 2, 3, \"hello\")\n\n(\"hello\", 5)\n\n(\"hello\", 5)[2]\n\nThe main differences between tuples and arrays are\n\nTuples are meant to hold immutable or non-changing data\n\nTuples aren’t usually meant for computation or linear algebra\n\n","type":"content","url":"/l01-03-julia-basics#tuples","position":15},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Dictionary"},"type":"lvl2","url":"/l01-03-julia-basics#dictionary","position":16},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Dictionary"},"content":"Very often in programming we want to be able to associate a key or name to a specific value\n\nOne data type for doing that is a Dict\n\nDicts are created with the somewhat inconvenient syntax Dict(name => value, ...) where the ... means we can repeat the pattern multiple times\n\nThey keys and values can be of any type\n\nDict(\"x\" => 1, 2 => \"y\", [\"w\", \"z\"] => [1, 2, 3])\n\n# use `[name]` to access element with `name`\nDict(\"x\" => 1, 2 => \"y\", [\"w\", \"z\"] => [1, 2, 3])[2]\n\nDict(\"x\" => 1, \"y\" =>2)\n\nDictionaries are often used for passing around groups of parameters\n\nWe’ll see examples later on\n\n","type":"content","url":"/l01-03-julia-basics#dictionary","position":17},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Named Tuples"},"type":"lvl2","url":"/l01-03-julia-basics#named-tuples","position":18},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Named Tuples"},"content":"The final “collection” we’ll talk about is the named tuple\n\nIt is a hybrid between a tuple and a dictionary\n\nTo create them we use the synax (name = value, ...)\n\nThey names or keys need to be just names (not numbers or arrays). The values can be anything\n\n(x = 1, y = 2, z=\"hello\")\n\n(x = 1, y = 2, z=\"hello\").z # use `.name` to access item\n\nNamed tuples are a newer feature of Julia\n\nThey are often used for the same purpsoes as dictionaries because the syntax is much cleaner\n\n","type":"content","url":"/l01-03-julia-basics#named-tuples","position":19},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Variables"},"type":"lvl2","url":"/l01-03-julia-basics#variables","position":20},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Variables"},"content":"Often when programming, we need to refer to the same piece of data more than once\n\nTo do this we use a variable\n\nVariables are defined using an =, as in name = value\n\nx = 1\n\ny = 42\n\nx + y  # 'use' or 'refer to' x and y\n\nm1 = [1 0; 0 1]\n\nm2 = [1 2; 3 4]\n\nm1 * m2  # matrix multiplication\n\nm2 * m2  # again -- but with something besides identity matrix!\n\nd = Dict(\"X\" => 1, \"Y\" => 2)\n\nd[\"X\"]\n\n","type":"content","url":"/l01-03-julia-basics#variables","position":21},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Functions"},"type":"lvl2","url":"/l01-03-julia-basics#functions","position":22},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Functions"},"content":"Most Julia programs do more than basic arithmetic operations on data\n\nTo apply an operation to a piece of data, we call a function\n\nTo call a function we use the function_name(data1, data2)\n\nA very handy function is the typeof function\n\ntypeof(1)\n\ntypeof(2.0)\n\ntypeof([1,2,3])\n\ntypeof([1 2; 3 4.0])\n\nMany standard operations are built in to Julia as functions\n\nsum([1, 2, 3])  # compute sum of array of numbers\n\ninv([1 2; 3 4])  # matrix inverse\n\nsize([1 2; 3 4])  # number of (rows, columns)  in matrix\n\nlength([1, 2, 3])  # number of elements in array\n\nlength([1 2; 3 4])  # returns total number of elements in a Matrix\n\nrand(2, 2, 2)  # a 2x2x2 array of random numbers, sampled from uniform[0,1] dist\n\nJulia has 1000s of functions\n\nWe’ll learn more as we go along...\n\nJust watch for the pattern with parentisis: name(args)\n\n","type":"content","url":"/l01-03-julia-basics#functions","position":23},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Defining Functions","lvl2":"Functions"},"type":"lvl3","url":"/l01-03-julia-basics#defining-functions","position":24},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Defining Functions","lvl2":"Functions"},"content":"Functions are used to execute a predefined set of operations\n\nDefining our own funcitons allows us to break programs into small, easily written an understood components\n\nWe define functions using the syntaxfunction name(arg1, arg2)\n    # steps\nend\n\nfunction mean(x)\n    total = sum(x)\n    N = length(x)\n    total / N\nend\n\nmean([1, 2, 3])\n\n# mean of 1000 random samples from U[0,1] -- should be ~ 0.5\nmean(rand(1000))\n\nIf a function only contains one line of code, you can also use a shorthand notation:function_name(arg1, arg2) = # step\n\nadd_two(x) = x + 2\n\nadd_two(40)\n\n","type":"content","url":"/l01-03-julia-basics#defining-functions","position":25},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Getting help for functions"},"type":"lvl2","url":"/l01-03-julia-basics#getting-help-for-functions","position":26},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Getting help for functions"},"content":"Given that there are so many functions, sometimes it is hard to remember exactly what a function does\n\nThankfully we can get help from Julia\n\nIf we type ?function_name, Julia will present us with documentation about the function\n\n?map\n\n?extrema\n\n","type":"content","url":"/l01-03-julia-basics#getting-help-for-functions","position":27},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Control Flow"},"type":"lvl2","url":"/l01-03-julia-basics#control-flow","position":28},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Control Flow"},"content":"Julia has the basic elements of control flow:\n\nif-else statements\n\nfor loops\n\nif 1 > 2 # no parenthesis needed\n    println(\"what???\")\nelse     # else is optional\n    return mean([1, 2, 3])\n    print(\"phew\")\nend      # all \"blocks\" terminate with word `end`\n\nfor i in 1:5 # range of numbers 1 to 5\n    println(i, \" \", i^2)\nend\n\nWe will see many more examples as we go forward\n\n","type":"content","url":"/l01-03-julia-basics#control-flow","position":29},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Packages"},"type":"lvl2","url":"/l01-03-julia-basics#packages","position":30},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Packages"},"content":"Julia comes ready to go with many powerful functions and data types\n\nHowever, there is a very active community of Julia programmers who are experts in different subfields of science and engineering\n\nThis has led to the development of vibrant and exciting ecosystem of packages or toolboxes for performing specific tasks\n\nWe can access these routines by using Julia packages\n\n","type":"content","url":"/l01-03-julia-basics#packages","position":31},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Loading packages","lvl2":"Packages"},"type":"lvl3","url":"/l01-03-julia-basics#loading-packages","position":32},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Loading packages","lvl2":"Packages"},"content":"By default Julia ships with a “standard library”\n\nThese are packages that come bundled with Julia itself and are pre-installed\n\nTo load a package and all of its types/functions use the using keyword\n\nFor example, we can load the Dates package and start using it\n\nusing Dates\n\nt1 = Dates.now()\n\nDates.format(t1, \"yyyy-mm-dd\")\n\nt2 = Dates.now()\n\nt2 > t1\n\nt3 = DateTime(1776, 7, 4)\n\n\"America is $(t1 - t3) ($(floor(t1 - t3, Dates.Day))) old\"\n\n","type":"content","url":"/l01-03-julia-basics#loading-packages","position":33},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Installing Packages","lvl2":"Packages"},"type":"lvl3","url":"/l01-03-julia-basics#installing-packages","position":34},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Installing Packages","lvl2":"Packages"},"content":"In addition to the standard library, we can also use packages created by other Julia users\n\nTo use a 3rd party package, we first need to install it\n\nThere are two ways to do this\n\n1]add PackageName\n\n2using Pkg  # a standard library package\nPkg.add(\"PackageName\")\n\nLet’s try them both\n\n]add Plots\n\nusing Pkg\nPkg.add(\"DataFrames\")\n\nAfter installing packages, we can load and use them just as we did the standard library packages\n\nusing Plots  # Python: from Plots import *\n\nplot([sin, cos], -2pi, 2pi)\n\nusing DataFrames\ndf = DataFrame(c1=1:10, c2=(1:10).^2)\n\n","type":"content","url":"/l01-03-julia-basics#installing-packages","position":35},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Package Composability","lvl2":"Packages"},"type":"lvl3","url":"/l01-03-julia-basics#package-composability","position":36},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Package Composability","lvl2":"Packages"},"content":"One unique feature sof Julia is that most of the language itself, in addition to packages, are written in Julia\n\nFor other languages like Python or R the “built in” part of the language is often written in another language like C\n\nThis difference has a large impact for Julia users\n\nBuilt in code and user code (including packages) are given the same “treatment”\n\nAnything the language creators can do, so can you\n\nA practical implication of this is that packages can operate on built in types (like we saw in our examples above) as well as types from other packages\n\nLet’s see what this looks like by plotting a DataFrame\n\n# install \"StatsPlots\", which links Plots and DataFrames\nPkg.add(\"StatsPlots\")\n\nusing StatsPlots\n\n@df df scatter(:c1, :c2)\n\nPkg.add(\"RDatasets\") # common datasets from R programming language\nusing RDatasets\nschool = RDatasets.dataset(\"mlmRev\",\"Hsb82\")\n@df school density(:MAch, group = :Sx)\n\n@df school density(:MAch, group = (:Sx, :Sector))","type":"content","url":"/l01-03-julia-basics#package-composability","position":37},{"hierarchy":{"lvl1":"Julia Types and Methods"},"type":"lvl1","url":"/l02-01-julia-types-methods","position":0},{"hierarchy":{"lvl1":"Julia Types and Methods"},"content":"Computational Analysis of Social Complexity\n\nFall 2025, Spencer Lyon\n\nPrerequisites\n\nLaptop or personal computer with internet connection\n\nJulia intro lecture\n\nOutcomes\n\nUnderstand key components of Julia’s type system: abstract types, primitive types, composite types, and parametric types\n\nBe able to define our own custom types to hold data\n\nUnderstand the concept of multiple dispatch\n\nBe able to leverage the mulitple dispatch system to define custom behavior for built-in and custom types\n\nReferences\n\nLecture notes\n\nJulia documentation on \n\ntypes and \n\nmethods (these are technical, but comprehensive and well-written)\n\nQuantEcon lectures on \n\ntypes and generic programming\n\n","type":"content","url":"/l02-01-julia-types-methods","position":1},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl2":"Types in Julia"},"type":"lvl2","url":"/l02-01-julia-types-methods#types-in-julia","position":2},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl2":"Types in Julia"},"content":"Julia is both very expressive and runtime efficient\n\nThis is made possible because of the underlying compiler technology\n\nThe main strategy for user interaction with the compiler is by defining custom types and methods that operate on those types\n\nTypes and multiple dispatch go hand in hand and are key to effective Julia\n\n","type":"content","url":"/l02-01-julia-types-methods#types-in-julia","position":3},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"What is a type?","lvl2":"Types in Julia"},"type":"lvl3","url":"/l02-01-julia-types-methods#what-is-a-type","position":4},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"What is a type?","lvl2":"Types in Julia"},"content":"Each piece of data in a program resides in memory (RAM) on the host computer\n\nWe often assign names to data, which we call variables (in x = \"hello\", x is a variable)\n\nAt its most basic level, a variable is composed of\n\nAn arrangment of 0’s and 1’s called bits\n\nAn address to where in memory the data is recorded\n\nA Symbol representing the name we gave the data\n\nA type in Julia represents what kind of object is represented at a certain memory address\n\nJulia uses this type information to enable syntax (e.g. the $ in a string to interpolate or the . access for an objects fields) and ultimiately decide what behaviors are defined to operate on the data\n\n","type":"content","url":"/l02-01-julia-types-methods#what-is-a-type","position":5},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Organizing types","lvl2":"Types in Julia"},"type":"lvl3","url":"/l02-01-julia-types-methods#organizing-types","position":6},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Organizing types","lvl2":"Types in Julia"},"content":"In Julia types are organized into a hierarchy\n\nAt the top of the hierarcy is Any -- all objects are instances of Any\n\nAt the bottom of the hierarchy is Union{} -- no objects are instances of Union{}\n\nIn between these endpoints we have a rich family of types\n\nEach type can have at most one parent type (if not specified, default parent is Any)\n\nTypes can actually come in a few different flavors...\n\n","type":"content","url":"/l02-01-julia-types-methods#organizing-types","position":7},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Types of Types","lvl2":"Types in Julia"},"type":"lvl3","url":"/l02-01-julia-types-methods#types-of-types","position":8},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Types of Types","lvl2":"Types in Julia"},"content":"Abstract Types: cannot be created directly, but serve as nodes in a type hierarchy. Help us organize types into families and provide shared behavior for all members of the family\n\nPrimitive types: provided to us by Julia and represent a collection of bits (e.g. Float64, Bool, and Int8). We could create them, but we won’t. We won’t say anything else about them here\n\nComposite Types: types that contain additional data called fields. An instance can be treated as a single value. This is what we typically define and use\n\nNOTE: all objects in Julia are instances of either primitive or composite types, and can be related to one another by sharing common abstract type ancestors\n\n","type":"content","url":"/l02-01-julia-types-methods#types-of-types","position":9},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl2":"Abstract Types"},"type":"lvl2","url":"/l02-01-julia-types-methods#abstract-types","position":10},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl2":"Abstract Types"},"content":"Abstract types help organize composite types into families\n\nFor example, the number system in Julia looks like this (really -- look \n\nhere)abstract type Number end\nabstract type Real     <: Number end\nabstract type AbstractFloat <: Real end\nabstract type Integer  <: Real end\nabstract type Signed   <: Integer end\nabstract type Unsigned <: Integer end\n\nNote:\n\nNumber’s parent type is Any\n\nReal is a special kind of Number and can be broken into two subgroups: AbstractFloat and Integer\n\n","type":"content","url":"/l02-01-julia-types-methods#abstract-types","position":11},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Why Abstract Types?","lvl2":"Abstract Types"},"type":"lvl3","url":"/l02-01-julia-types-methods#why-abstract-types","position":12},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Why Abstract Types?","lvl2":"Abstract Types"},"content":"We said before we can’t create an instance of abstract types...\n\nSo, why do we have them?\n\nThe primary reason to have abstract types is to introduced shared functionality via methods defined on the abstract type\n\nExample: suppose you needed to define a function isint to determine if an object is an integer\n\nWithout abstract types, you could have a long sequence of checks for if a variable is any integer type:\n\nfunction isint1(x)\n\tfor T in [\n\t\tInt8, UInt8, Int16, UInt16, \n\t\tInt32, UInt32, Int64, UInt64, \n\t\tInt128, UInt128\n\t]\n\t\tif isa(x, T)\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend\n\nisint1(10), isint1(\"Hello\")\n\nWith abstract types we can define two methods:\n\nisint(x) = false\nisint(x::Integer) = true\n\nisint(10), isint(\"Hello\")\n\nThis has many benefits\n\nMuch simpler to write/reason about\n\nMore “fool proof”: what if we forgot one of the “UIntXX” types?\n\nMore “future proof”: what if a new type of integer gets introduced (e.g. UInt256 like is widely used in blockchain data!)\n\nPushes work into the compiler:\n\n@code_lowered isint1(\"hello\")\n\n@code_lowered isint1(UInt128(12341234123423134))\n\n@code_lowered isint(\"hello\") \n\n@code_lowered isint(UInt128(12341234123423134))\n\n","type":"content","url":"/l02-01-julia-types-methods#why-abstract-types","position":13},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl2":"Composite Types"},"type":"lvl2","url":"/l02-01-julia-types-methods#composite-types","position":14},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl2":"Composite Types"},"content":"Abstract types are very useful when used in conjunction with multiple dispatch (defining multiple methods of function with same name, but varying code depending on argument types)\n\nHowever, most often we create types to hold collections of related data together\n\nWe do this using composite types\n\nA composite type can be created as follows:struct Name <: AbstractParentType\n    field1::Field1Type\n\t# more fields\nend\n\nNote that the <: AbstractParentType is optional, as are types on all fields\n\n","type":"content","url":"/l02-01-julia-types-methods#composite-types","position":15},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Composite Types: Examples","lvl2":"Composite Types"},"type":"lvl3","url":"/l02-01-julia-types-methods#composite-types-examples","position":16},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Composite Types: Examples","lvl2":"Composite Types"},"content":"\n\nstruct Foo\n   bar\n   baz::Int\n   qux::Float64\nend\n\nfoo = Foo(\"Hello, world.\", 23, 1.5)\n\ntypeof(foo)\n\n# this will not work. Uncomment and try it out\n# Foo((), 23.5, 1)\n\nfieldnames(Foo)\n\nfoo.bar\n\nfoo.baz\n\nfoo.qux\n\n","type":"content","url":"/l02-01-julia-types-methods#composite-types-examples","position":17},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Composite Types and Dispatch","lvl2":"Composite Types"},"type":"lvl3","url":"/l02-01-julia-types-methods#composite-types-and-dispatch","position":18},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Composite Types and Dispatch","lvl2":"Composite Types"},"content":"Above we saw an example of defining multiple methods of isint, using an abstract type to route dispatch\n\nWe can also use composite types\n\nisint(x::Foo) = isint(x.bar)\n\nisint(10), isint(1.0), isint(UInt128(234901324987213)), isint(Foo(\"not an int\", 12, 1.0))\n\n@code_lowered isint(Foo(\"not an int\", 12, 1.0))\n\n@code_lowered isint(UInt128(12341234123423134))\n\nisint(foo)\n\nfoo, isint(foo)\n\nisint(Foo(1, 23, 1.5))\n\n","type":"content","url":"/l02-01-julia-types-methods#composite-types-and-dispatch","position":19},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Exercises","lvl2":"Composite Types"},"type":"lvl3","url":"/l02-01-julia-types-methods#exercises","position":20},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Exercises","lvl2":"Composite Types"},"content":"Create an abstract type called Person\n\nCreate two composite subtypes of Person called Friend and Foe\n\nEach of these should have fields name and height_inches\n\nFor friend you should also have a field favorite_color\n\nMAKE SURE TO ADD TYPES FOR ALL FIELDS\n\nCreate a third composite subtype of Person called Stranger, but without any fields\n\nSuppose we are trying to decide who to invite to a dinner party. Our rule is that friends should get a definite yes. Enemies a definite no. Strangers a 50%/50% toss up. However, if our spouse says we should invite a person, the answer is always yes\n\nCreate a function should_invite_to_party that implements that logic\n\nHINT: you will need 4 methods. 3 of these have only one argument, the 4th has two\n\nIn the cell at the bottom we have written a test case. You will know you’ve done this correctly when all the tests pass\n\n# Your code here\n\nusing Test\n\nfunction tests()\n\t@testset \"people\" begin\n\t\n\t\t@test fieldnames(Friend) == (:name, :height_inches, :favorite_color)\n\t\t@test fieldnames(Foe) == (:name, :height_inches)\n\t\t@test fieldnames(Stranger) == tuple()\n\n\t\tjim = Friend(\"Jim\", 64, \"blue\")\n\t\tdwight = Foe(\"Dwight\", 61)\n\t\tcreed = Stranger()\n\n\t\t@test jim isa Person\n\t\t@test dwight isa Person\n\t\t@test creed isa Person\n\n\t\t@test should_invite_to_party(jim) \n\t\t@test !should_invite_to_party(dwight)\n\t\t@test should_invite_to_party(dwight, true)\n\t\t\n\t\tcreed_invites = map(i->should_invite_to_party(creed), 1:100)\n\t\t@test any(creed_invites)\n\t\t@test any(map(!, creed_invites))\n\n\t\tcreed_invites_spouse = map(i->should_invite_to_party(creed, true), 1:100)\n\t\t@test all(creed_invites_spouse)\t\n\tend\nend\n\n# uncomment and run this cell when you are ready to test your code\ntests()","type":"content","url":"/l02-01-julia-types-methods#exercises","position":21},{"hierarchy":{"lvl1":"Julia Code Organization"},"type":"lvl1","url":"/l02-02-code-organization","position":0},{"hierarchy":{"lvl1":"Julia Code Organization"},"content":"Computational Analysis of Social Complexity\n\nFall 2025, Spencer Lyon\n\nPrerequisites\n\nLaptop or personal computer with internet connection\n\nJulia intro lecture\n\nOutcomes\n\nCreating julia modules\n\nImporting Julia source fode files with the include function\n\nExporting types and functions to create\n\nReferences\n\nLecture notes\n\nJulia documentation on \n\nmodules\n\n","type":"content","url":"/l02-02-code-organization","position":1},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":"Introduction"},"type":"lvl2","url":"/l02-02-code-organization#introduction","position":2},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":"Introduction"},"content":"Julia can be succesfully used for exploratory analysis and one-off scripts\n\nAs projects grow, it is often useful to add structure and organization to the code\n\nIn Julia, the main building blocks for code organization and re-use include\n\nTypes/structs\n\nFunctions/methods\n\n.jl source code files\n\nModules\n\nPackages\n\nIn this not we’ll learn how to manage .jl files and Modules\n\nWe’ll pick up with Packages in another lecture\n\n","type":"content","url":"/l02-02-code-organization#introduction","position":3},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":".jl files"},"type":"lvl2","url":"/l02-02-code-organization#id-jl-files","position":4},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":".jl files"},"content":"Julia source code typically lives in a plain text file with a .jl extension\n\nWhile the extension is optional and not enforced by the Julia REPL or runtime, it is a strong convention followed by the community and by 3rd party tools like code editors and GitHub\n\nSuppose we have the following code for simulating Markov Chains in Julia\n\n# Markov Chain code\n\nstruct MarkovChain{T}\n    P::Matrix{Float64}\n    initial_state::Vector{Float64}\n    state_values::Vector{T}\n\n    P_dists::Vector{Vector{Float64}}\nend\n\nfunction MarkovChain(P::Matrix{Float64}, initial_state::Vector{Float64}, state_values::Vector{T}) where T\n    P_dists = [cumsum(row) for row in eachrow(P)]\n    return MarkovChain{T}(P, initial_state, state_values, P_dists)\nend\n\nfunction simulate_indices(mc::MarkovChain, n_steps::Int)\n    init_dist = cumsum(mc.initial_state)\n    states = Vector{Int}(undef, n_steps)\n    states[1] = searchsortedfirst(init_dist, rand())\n    for i in 2:n_steps\n        states[i] = searchsortedfirst(mc.P_dists[states[i-1]], rand())\n    end\n    return states\nend\n\nfunction simulate_values(mc::MarkovChain{T}, n_steps::Int)::Vector{T} where T\n    states = simulate_indices(mc, n_steps)\n    return mc.state_values[states]\nend\n\nP1 = [0.5 0.5; 0.5 0.5]\nmc1 = MarkovChain(P1, [1.0, 0.0], [\"A\", \"B\"])\n\ntypeof(mc1)\n\nmc1.P_dists\n\ninds = simulate_indices(mc1, 10)\n\nvals = simulate_values(mc1, 10)\nvals\n\nAs you can see, we can use this code from inside a Jupyter notebook by running the defining cell and then calling the routines\n\nHowever, what if we wanted to reuse the code for another notebook\n\nWe have two options:\n\nCopy/paste it to the new notebook\n\nStore the code in a .jl file and import it from both places\n\nLet’s pick the latter\n\n","type":"content","url":"/l02-02-code-organization#id-jl-files","position":5},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":"include"},"type":"lvl2","url":"/l02-02-code-organization#include","position":6},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":"include"},"content":"I have created markov.jl with that code:\n\nprintln(String(read(\"markov.jl\")))\n\nTo make use of this code in julia I can run include(\"markov.jl\")\n\nYou can think of the include function as copy/pasting AND evaluating the code from a file in whatever setting you are in\n\ninclude(\"markov.jl\")\n\nNotice that in the markov.jl file I added two extra functions (rand and stationary_ditributions)\n\nWe can verify that these were defined for us when we ran include by calling them:\n\nrand(mc1, 4)\n\nstationary_distributions(mc1)\n\n","type":"content","url":"/l02-02-code-organization#include","position":7},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":"Modules"},"type":"lvl2","url":"/l02-02-code-organization#modules","position":8},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":"Modules"},"content":"Being able to define code in a .jl file and load it in a notebook (or other .jl file!) is already a huge win for organization and reusability\n\nBut we can do better!\n\nOne issue with our approach here is that all types, functions, and methods we define in our included files will become part of our working Julia session.\n\nThis is not always wanted\n\nSuppose instead we really only wanted to make the MarkovChain, rand, and stationary_distributions code part of our session when loading our file\n\nTo do this, we will need to organize our code into a Module\n\nTo create module we use the syntaxmodule NAME\n\n# code here\n\nend\n\nHere we use the module keyword, followed by the name of the module\n\nBetween the module name and end we insert any code we want to include in the module\n\nBy convention, the contents of a module are not indented (this is a rare exception to indenting code that comes before end)\n\nI’ve created a module for our Markov chain code in module.jl:\n\nprintln(String(read(\"module.jl\")))\n\nNotice a few things:\n\nI used the export keyword to list types/functions I want to be added to the caller’s namespace when someone runs using Markov\n\nI used include to add the actual source code in the module\n\nThis is a very common pattern in Julia and is one we will see throughout our course\n\n","type":"content","url":"/l02-02-code-organization#modules","position":9},{"hierarchy":{"lvl1":"Julia Code Organization","lvl3":"Using Modules","lvl2":"Modules"},"type":"lvl3","url":"/l02-02-code-organization#using-modules","position":10},{"hierarchy":{"lvl1":"Julia Code Organization","lvl3":"Using Modules","lvl2":"Modules"},"content":"To use a module we first have to evaluate the code defining it\n\nTo do that we can include(\"module.jl\")\n\nWarning\n\nI restarted my kernel here!!!!\n\ninclude(\"module.jl\")\n\n\nNotice the printout shows that we now have a Main.Markov object\n\nNOTE: Main is the name of the default module the user executed code is evaluated in to\n\nWe can now access Markov.<NAME> where <NAME> is any type or function in the module\n\nP2 = [0.2 0.8; 0.5 0.5]\nmc2 = Markov.MarkovChain(P2, [1.0, 0.0], [10, 20])\n\nMarkov.rand(mc2, 2)\n\nNotice that I had to use Markov. to access members of the module\n\nNow taht the module is defined I can call using Markov to make it possible to use any exported function without the Markov. prefix\n\nusing Main.Markov\nstationary_distributions(mc2)\n\n","type":"content","url":"/l02-02-code-organization#using-modules","position":11},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":"Exercise"},"type":"lvl2","url":"/l02-02-code-organization#exercise","position":12},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":"Exercise"},"content":"Now it is your turn\n\nLet’s create a module for working with geometric shapes\n\nCreate two new .jl files\n\nOne called shapes.jl: here define the following:\n\nAn abstract type Shape2D\n\nConcrete types Circle, Rectangle, and Triangle that are subtypes of Shape2D\n\nMethods for area and perimeter for each shape type\n\nA function is_inside(shape, x, y) that checks if a point (x, y) is inside the shape\n\nOne called GeometricShapes.jl: here wrap the code from shapes.jl in a module named GeometricShapes\n\nExport the types: Shape2D, Circle, Rectangle, Triangle\n\nExport the functions: area, perimeter, is_inside\n\ninclude your new module and test it by:\n\nCreating instances of each shape\n\nComputing their areas and perimeters\n\nTesting if various points are inside or outside the shapes","type":"content","url":"/l02-02-code-organization#exercise","position":13},{"hierarchy":{"lvl1":"Julia Package Development"},"type":"lvl1","url":"/l02-03-julia-packages","position":0},{"hierarchy":{"lvl1":"Julia Package Development"},"content":"Computational Analysis of Social Complexity\n\nFall 2025, Spencer Lyon\n\nPrerequisites\n\nLaptop or personal computer with internet connection\n\nJulia intro lecture\n\nJulia Modules lecture\n\nOutcomes\n\nInstalling, uninstalling, and updating packages\n\nManaging a Project.toml file and understanding the related Manifest.toml\n\nCreate new Julia packages to organize code snippets\n\nReferences\n\nLecture notes\n\nJulia documentation on \n\npackages\n\nPkg.jl standard library \n\ndocs\n\n","type":"content","url":"/l02-03-julia-packages","position":1},{"hierarchy":{"lvl1":"Julia Package Development","lvl2":"Introduction"},"type":"lvl2","url":"/l02-03-julia-packages#introduction","position":2},{"hierarchy":{"lvl1":"Julia Package Development","lvl2":"Introduction"},"content":"Julia is a very powerful, modern language\n\nIt comes packed with many essential components for creating high performing numerical programs\n\nArrays\n\nParallel processing\n\nMulti threading\n\nCalling C code\n\n... and many more\n\nHowever, Julia also has a thriving 3rd party library ecosystem (\n\nML, \n\nPlotting, \n\nNotebooks, \n\nDifferential Equations, and more)\n\nJulia libraries are known as packages\n\nToday we will learn how to manage and develop packages\n\n","type":"content","url":"/l02-03-julia-packages#introduction","position":3},{"hierarchy":{"lvl1":"Julia Package Development","lvl2":"Package Management"},"type":"lvl2","url":"/l02-03-julia-packages#package-management","position":4},{"hierarchy":{"lvl1":"Julia Package Development","lvl2":"Package Management"},"content":"To start, let’s learn how to manage Julia packages\n\nThere are two primary methods for managing packages:\n\nImporting and calling functions from the Pkg standard library package\n\nUsing the pkg REPL mode from the main Julia REPL\n\nWe will learn both here\n\nFirst, we’ll import the Pkg package\n\nNote\n\nExamples of the pkg REPL mode will be pasted here for you to view\n\nimport Pkg\n\n","type":"content","url":"/l02-03-julia-packages#package-management","position":5},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Installing","lvl2":"Package Management"},"type":"lvl3","url":"/l02-03-julia-packages#installing","position":6},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Installing","lvl2":"Package Management"},"content":"To install a package use Pkg.add(\"PACKAGE_NAME\")\n\nBelow we install the popular CSV package used for handling CSV files in Julia\n\nPkg.add(\"CSV\")\n\nTo use the pkg REPL mode, I first start the repl by running julia in my terminal\n\nThen I press ] to enter Pkg mode\n\nREPL prompt chanegs to (@v1.11) pkg> (where v1.11 represents my Julia system version)\n\nOnce here I run add CSV to get the following output:(@v1.11) pkg> add CSV\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.11/Project.toml`\n  [336ed68f] + CSV v0.10.15\n    Updating `~/.julia/environments/v1.11/Manifest.toml`\n  [336ed68f] + CSV v0.10.15\n  [944b1d66] + CodecZlib v0.7.8\n  [34da2185] + Compat v4.18.0\n  [9a962f9c] + DataAPI v1.16.0\n  [e2d170a0] + DataValueInterfaces v1.0.0\n  [48062228] + FilePathsBase v0.9.24\n  [842dd82b] + InlineStrings v1.4.4\n  [82899510] + IteratorInterfaceExtensions v1.0.0\n  [bac558e1] + OrderedCollections v1.8.1\n  [2dfb63ee] + PooledArrays v1.4.3\n  [91c51154] + SentinelArrays v1.4.8\n  [3783bdb8] + TableTraits v1.0.1\n  [bd369af6] + Tables v1.12.1\n  [3bb67fe8] + TranscodingStreams v0.11.3\n  [ea10d353] + WeakRefStrings v1.4.2\n  [76eceee3] + WorkerUtilities v1.6.1\n  [9fa8497b] + Future v1.11.0\n\n","type":"content","url":"/l02-03-julia-packages#installing","position":7},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Checking Status","lvl2":"Package Management"},"type":"lvl3","url":"/l02-03-julia-packages#checking-status","position":8},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Checking Status","lvl2":"Package Management"},"content":"To check the status of my packages, I can use the Pkg.status function  or status command at the pkg REPL\n\nPkg.status()\n\n(@v1.11) pkg> status\nStatus `~/.julia/environments/v1.11/Project.toml`\n  [336ed68f] CSV v0.10.15\n⌃ [7073ff75] IJulia v1.29.2\nInfo Packages marked with ⌃ have new versions available and may be upgradable.\n\nThe printout here will show one line per explicity installed package (not transitive dependencies)\n\nThe format of each line is _ [ID] NAME VERSION where\n\nID is the beginning of a universially unique identifier (UUID) that identifies the package in the Julia ecosystem\n\nNAME is the name of the package\n\nVERSION is the installed version number\n\n_ is a placeholder for possible version updates. These placeholders will be explained beneath the list of packages\n\n","type":"content","url":"/l02-03-julia-packages#checking-status","position":9},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Updating","lvl2":"Package Management"},"type":"lvl3","url":"/l02-03-julia-packages#updating","position":10},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Updating","lvl2":"Package Management"},"content":"Notice how our printout shows we have version v1.29.2 of IJulia, but that there is an update available\n\nTo update to the latest verison (reccomended for security and features) we use the Pkg.udpate function or up REPL command\n\nIf we run pkg> up, Julia will attempt to get the latest version of all installed packages (same for Pkg.update())\n\nIf instead we do pkg> up IJulia, Julia will only update IJulia (same for Pkg.update(\"IJulia\"))\n\n(@v1.11) pkg> up IJulia\n    Updating registry at `~/.julia/registries/General.toml`\n    Updating `~/.julia/environments/v1.11/Project.toml`\n  [7073ff75] ↑ IJulia v1.29.2 ⇒ v1.30.0\n    Updating `~/.julia/environments/v1.11/Manifest.toml`\n  [7073ff75] ↑ IJulia v1.29.2 ⇒ v1.30.0\n  [b85f4697] - SoftGlobalScope v1.1.0\n\nNow running status does not show that IJulia has a newer available version\n\nPkg.status()\n\n","type":"content","url":"/l02-03-julia-packages#updating","position":11},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Uninstalling","lvl2":"Package Management"},"type":"lvl3","url":"/l02-03-julia-packages#uninstalling","position":12},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Uninstalling","lvl2":"Package Management"},"content":"To uninstall a package we can use the Pkg.rm(\"NAME\") functino or pkg> rm NAME REPL command:|\n\nPkg.rm(\"CSV\")\n\nStatus now shows we no longer have CSV\n\nPkg.status()\n\n","type":"content","url":"/l02-03-julia-packages#uninstalling","position":13},{"hierarchy":{"lvl1":"Julia Package Development","lvl2":"Environments"},"type":"lvl2","url":"/l02-03-julia-packages#environments","position":14},{"hierarchy":{"lvl1":"Julia Package Development","lvl2":"Environments"},"content":"Notice above when managing packages, I always saw the following at the top of the file:   Resolving package versions...\n    Updating `~/.julia/environments/v1.11/Project.toml`\n\nThis was a hint to how Julia keeps its packages organized...\n\nWhenever we are working in Julia, there is always an environment active\n\nBy default, the environment is specific to the user account (~/ is UNIX shorthand for current user’s home directory) and the Julia version number (v1.11)\n\nThis means that all packages we install will be available any time someone starts Julia v1.11 from my user account\n\n","type":"content","url":"/l02-03-julia-packages#environments","position":15},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Environment Management","lvl2":"Environments"},"type":"lvl3","url":"/l02-03-julia-packages#environment-management","position":16},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Environment Management","lvl2":"Environments"},"content":"Having a single, global environment is very convenient for simple tasks and exploration\n\nHowever, for larger software or research projects, it is a best practice to have an environment specific for that project\n\nThe Julia package manager has built in support for managing isolated sets of packages in named environments\n\n","type":"content","url":"/l02-03-julia-packages#environment-management","position":17},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Activate","lvl2":"Environments"},"type":"lvl3","url":"/l02-03-julia-packages#activate","position":18},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Activate","lvl2":"Environments"},"content":"To create an environment, start Julia within the folder for the project (use pwd()) to check your folder\n\nThen run Pkg.activate(\".\") or pkg> activate . to create a new project, or activate an existing project specific to the current folder\n\nWhen you run this command, no files will have been changed, but checking status will show you are in a different environment\n\nPkg.activate(\".\")\n\nPkg.status()\n\n","type":"content","url":"/l02-03-julia-packages#activate","position":19},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Manage Packages","lvl2":"Environments"},"type":"lvl3","url":"/l02-03-julia-packages#manage-packages","position":20},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Manage Packages","lvl2":"Environments"},"content":"Now that we have a new environment activated, we can install packages specific to this project\n\nPkg.add([\"VegaLite\", \"VegaDatasets\"])\n\nPkg.status()\n\nNote two things:\n\nWe can now use the packages\n\nThe Pkg.add command had this line in the printout: Updating ~/Teaching/UCF/CAP-6318/book-myst/week02/Project.toml\n\nWe’ll demonstrate we can use the packages below, then we’ll dig into the Project.toml\n\nusing VegaLite, VegaDatasets\n\ndataset(\"cars\") |>\n@vlplot(\n    :point,\n    x=:Horsepower,\n    y=:Miles_per_Gallon,\n    color=:Origin,\n    width=400,\n    height=400\n)\n\n","type":"content","url":"/l02-03-julia-packages#manage-packages","position":21},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Package.toml","lvl2":"Environments"},"type":"lvl3","url":"/l02-03-julia-packages#package-toml","position":22},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Package.toml","lvl2":"Environments"},"content":"Julia environments are managed and described using in a format called TOML (Tom’s obvious markup language) in a file Project.toml\n\nThis file will be created and updated as needed by Pkg as we run Pkg commands\n\nLet’s see what our new Project.toml looks like:\n\nprintln(String(read(\"Project.toml\")))\n\nThis shows us we have a [deps] section with entries for the three packages we installed\n\nEach package line has the NAME = UUID syntax\n\nThere can be other top level items (not in a section) and other sections\n\nWe’ll discuss these as they come up\n\n","type":"content","url":"/l02-03-julia-packages#package-toml","position":23},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Manifest.toml","lvl2":"Environments"},"type":"lvl3","url":"/l02-03-julia-packages#manifest-toml","position":24},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Manifest.toml","lvl2":"Environments"},"content":"Notice that the Project.toml file does not have any information about the version of our installed packages\n\nThere is a companion file called Manifest.toml that does have this information\n\nLet’s take a look:\n\nprintln(String(read(\"Manifest.toml\")))\n\nThe Manifest.toml file is a very comprehensive overview of ALL details about a Julia environment\n\nThis file is rarely (if ever) touched by humans\n\nIt can be used to reproduce an exact replica of the Julia version, packages, and package versions on any machine\n\n","type":"content","url":"/l02-03-julia-packages#manifest-toml","position":25},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Set up environment on new machine","lvl2":"Environments"},"type":"lvl3","url":"/l02-03-julia-packages#set-up-environment-on-new-machine","position":26},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Set up environment on new machine","lvl2":"Environments"},"content":"If you are given a Project.toml/Manifest.toml combo, you can easily create a duplicate of teh author’s Julia environment\n\nTo do this follow these two steps:\n\nCall Pkg.activate(\".\")  (or pkg> activate) from the directory containing the .toml files\n\nCall Pkg.instantiate() (or pkg> instantiate)\n\nThis will first activate the Project’s environment in your current Julia session and then install all dependencies\n\nusing Pkg\nPkg.activate(\".\")\nPkg.instantiate()\n\n","type":"content","url":"/l02-03-julia-packages#set-up-environment-on-new-machine","position":27},{"hierarchy":{"lvl1":"Julia Package Development","lvl2":"Package Development"},"type":"lvl2","url":"/l02-03-julia-packages#package-development","position":28},{"hierarchy":{"lvl1":"Julia Package Development","lvl2":"Package Development"},"content":"The vast majority of Julia itself -- including the packages in its standard library -- are written in Julia\n\nThis means that to be a package author you really only need to know Julia\n\nSince you know Julia, you can author packages!\n\nThe Pkg module has a \n\ngenerate function to help us develop packages, however Julia authors reccomend using the first party PkgTemplates.jl package to start a new package\n\nSo, we’ll start by installing PkgTemplates\n\nusing Pkg\nPkg.add(\"PkgTemplates\")\n\nusing PkgTemplates\n\n","type":"content","url":"/l02-03-julia-packages#package-development","position":29},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"CAP6318","lvl2":"Package Development"},"type":"lvl3","url":"/l02-03-julia-packages#cap6318","position":30},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"CAP6318","lvl2":"Package Development"},"content":"As we progress throughout the semseter we will build up a toolbox of useful types and functions\n\nLet’s organize these into a helpful package called CAP6318\n\nWe can also use this package as a way to specify dependencies specifically required for the course\n\nTo create our package we will need to follow the \n\nPkgTemplates.jl documentation to (1) establish the template for our project and (2) run the template on our project name\n\nt = Template(;\n    user=\"sglyon\", # TODO: you change this!\n    plugins=[PkgTemplates.Develop(), ]\n)\n\npackage_dir = t(\"CAP6318\")\n\nNotice that the code generated a new project in ~/.julia/dev/CAP6318\n\nLet’s take a look at was created for us\n\nLet’s see what was created for us\n\ncmd =`tree $package_dir`\nprintln(\"About to run: $cmd\")\nrun(cmd);\n\nHere we see a LICENSE, Manifest.toml/Project.toml pair, and a README.md (for usage instructions) in the top folder\n\nThen inside src/ we have a module file CAP6318.jl\n\nInside test/ we have a runtests.jl file\n\nLet’s peek inside the files\n\nprint_pkg_file(parts::String...) = println(String(read(joinpath(package_dir, parts...))))\nprint_pkg_file(\"Project.toml\")\n\nprint_pkg_file(\"src\", \"CAP6318.jl\")\n\nprint_pkg_file(\"test\", \"runtests.jl\")\n\nOk, we have a nicely structured starting point\n\nWe will add to this throughout the course\n\n","type":"content","url":"/l02-03-julia-packages#cap6318","position":31},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Exercise","lvl2":"Package Development"},"type":"lvl3","url":"/l02-03-julia-packages#exercise","position":32},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Exercise","lvl2":"Package Development"},"content":"Perform the following tasks\n\nActivate the project by doing activate CAP6318. Because we specified Develop() in our template and this is the package name we do not need to be in the same directory or pass the directory path\n\nInstall CSV, DataFrames, VegaLite, Graphs in the CAP6318 project. We’ll use them later\n\nEnsure that you installed these correctly by using the print_pkg_file function above and looking for the [deps] section\n\nCreate a new function greet() = println(\"Hello from CAP6318\") in your src/CAP6318.jl module file. Note you will have to open this file in your text editor\n\nCall using CAP6318 then run greet() to see your message","type":"content","url":"/l02-03-julia-packages#exercise","position":33}]}