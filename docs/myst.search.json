{"version":"1","records":[{"hierarchy":{"lvl1":"Welcome"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Welcome"},"content":"Computational Analysis of Social Complexity\n\nFall 2025, Spencer Lyon\n\nWelcome to week 1!\n\nThis week we will get to know eachother and get on the same page with respect to what this class is all about.\n\nWe will also dive right in to the computational infrastructure we will need by installing the Julia programming langauge and learning a bit about how to use it.\n\nEach week lecture notes will be distributed as a collection of Jupyter notebooks. The notebooks will follow a strict naming convention, where each notebook has a name such as L@@.##_XXX.ipynb where @@ is a two digit lecture number and ## is a two digit file number and XXX is one or more words describing the content of the notebook. We will work through the notebooks in the order indicated by the ##. The XXX are to provide easier access when reviewing notes after class.\n\n","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Welcome","lvl2":"About Me"},"type":"lvl2","url":"/#about-me","position":2},{"hierarchy":{"lvl1":"Welcome","lvl2":"About Me"},"content":"Spencer Lyon (\n\nspencer​.lyon@ucf​.edu)\n\nEconomics PhD from NYU (2018)\n\nLove to teach: mostly economics, data science, AI/ML – all have\nprogramming/computational element\n\nMoved to Orlando in July 2018 with wife and 5 (yes!) kids\n\nRun consulting (training/projects) business:   Valorum Data\n\nWorking on a couple startups\n\n","type":"content","url":"/#about-me","position":3},{"hierarchy":{"lvl1":"Welcome","lvl2":"About you"},"type":"lvl2","url":"/#about-you","position":4},{"hierarchy":{"lvl1":"Welcome","lvl2":"About you"},"content":"Background?\n\nProgress in program?\n\nAreas of interest? (meaningful answers here! they matter…)\n\nRumors about the course?\n\n","type":"content","url":"/#about-you","position":5},{"hierarchy":{"lvl1":"Welcome","lvl2":"About the course"},"type":"lvl2","url":"/#about-the-course","position":6},{"hierarchy":{"lvl1":"Welcome","lvl2":"About the course"},"content":"Interdisciplinary by nature\n\n“Living course”: only been taught a handful of times, content is flexible\n\nMore ideas/topics than time!\n\nHas been altered fairly significantly over the past few years (but the heart/soul of the course remains the same)\n\nNo required topics or standard textbook, so we get to pick!\n\nTheoretical concepts\n\nGraphs: less detail than network science course, but more algorithms\n\nGame Theory: strategic interaction/competition\n\nAgent Based Models: simulation of rule based systems\n\nAuction theory: Game theory at scale in bidding markets\n\nBlockchain: cryptographically secure, public, distributed ledger\n\nSocial, information, financial networks\n\nApplications\n\nTwitter\n\nEconomic markets and trade\nnetwork\n\nMore...\n\n","type":"content","url":"/#about-the-course","position":7},{"hierarchy":{"lvl1":"Welcome","lvl2":"Expectations"},"type":"lvl2","url":"/#expectations","position":8},{"hierarchy":{"lvl1":"Welcome","lvl2":"Expectations"},"content":"Take the time in the first 2 weeks to learn Julia\n\nYou’ll be glad you did\n\nContent moves quick and you don’t want syntax/programming to distract you or hold you back\n\nStudy reading assignments before class\n\nComplete assignments on time -- no exceptions\n\nParticipate in in-class discussions\n\nSpend ~3-6 hours outside of class per week\n\nCommunication\n\nPost all content related questions to class discussion forum\n\nRespond to peers’ questions and engage in discussions\n\nPersonal questions should go directly to me via email\n\nI do not use email on Sunday. Other days I will respond within 48 hours.\n\nDeliverables\n\nHomework (~8 – 30%)\n\nExam (2 – 30%)\n\nProjects (2 – 30%)\n\nCitizenship (throughout - 10%)\n\nFirst best: attend class in person, actively participate\n\nAcceptable: attend virtually, but keep video on and be ready to speak up when called on\n\nUnacceptable: attend virtually, but keep video off and/or don’t participate in discussions\n\n","type":"content","url":"/#expectations","position":9},{"hierarchy":{"lvl1":"Welcome","lvl2":"Tools/Resources"},"type":"lvl2","url":"/#tools-resources","position":10},{"hierarchy":{"lvl1":"Welcome","lvl2":"Tools/Resources"},"content":"Core textbooks\n\nNetworks, Crowds, and Markets by David Easley and Jon Kleinberg\n\nEconomics Networks by John Stachurski and Thomas Sargent\n\nWill be supplemented by lecture notes for more computational content\n\nJulia Programming language\n\nLecture notes are accessible via the \n\ncourse website\n\nLecture notes AND assignments in Jupyter notebooks\n\nAll course administration will happen through webcourses (Canvas)\n\nAssignments me <-> you\n\nFeedback on assignments me -> you\n\nDiscussion me + you <-> me + you\n\nOfficial grades will be visible on canvas","type":"content","url":"/#tools-resources","position":11},{"hierarchy":{"lvl1":"Julia Setup"},"type":"lvl1","url":"/l01-02-setup","position":0},{"hierarchy":{"lvl1":"Julia Setup"},"content":"Computational Analysis of Social Complexity\n\nFall 2025, Spencer Lyon\n\nPrerequisites\n\nLaptop or personal computer with internet connection\n\nOutcomes\n\nInstall Julia and IJulia locally\n\nInstall VS Code\n\nOpen lecture notes locally\n\nReferences\n\nLecture notes\n\nQuantEcon lectures\n\nSetting up Julia\n\nGit, GitHub, Version Control\n\nJulia tools and editors\n\n","type":"content","url":"/l01-02-setup","position":1},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Step 1: Install Julia"},"type":"lvl2","url":"/l01-02-setup#step-1-install-julia","position":2},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Step 1: Install Julia"},"content":"The first step is to install Julia\n\n","type":"content","url":"/l01-02-setup#step-1-install-julia","position":3},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Install Julia","lvl2":"Step 1: Install Julia"},"type":"lvl3","url":"/l01-02-setup#task-install-julia","position":4},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Install Julia","lvl2":"Step 1: Install Julia"},"content":"Windows: windows users can install Julia from the microsoft store OR by running winget install --name Julia --id 9NJNWW8PVKMN -e -s msstore from powershell\n\nMac/Linux: Open terminal and run curl -fsSL https://install.julialang.org | sh (it is safe -- I promise ;))\n\n","type":"content","url":"/l01-02-setup#task-install-julia","position":5},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Launch Julia REPL","lvl2":"Step 1: Install Julia"},"type":"lvl3","url":"/l01-02-setup#task-launch-julia-repl","position":6},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Launch Julia REPL","lvl2":"Step 1: Install Julia"},"content":"Launch the Julia REPL (read-eval-print-loop) by clicking on the Julia icon or running julia from your shell (PowerShell or Terminal)\n\nYou will be greeted with a prompt that looks like this:   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.11.6 (2025-07-09)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> \n\nYou are now in what is called the Julia REPL (read-eval-print-loop). This is a place where you can type Julia commands and have them executed immediately.\n\nTest it out by typing rand(2, 2) and pressing enter\n\nYou should see something like this (note the numbers will be different for you):julia> rand(2, 2)\n2×2 Matrix{Float64}:\n 0.698944  0.676245\n 0.17375   0.448243\n\nCongratulations! You have successfully installed Julia and are ready to move on to the next step!\n\n","type":"content","url":"/l01-02-setup#task-launch-julia-repl","position":7},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Step 2: Install IJulia.jl"},"type":"lvl2","url":"/l01-02-setup#step-2-install-ijulia-jl","position":8},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Step 2: Install IJulia.jl"},"content":"With Julia installed we are now ready to install some Julia packages\n\nThe first package we’ll be using is called IJulia\n\nThis is a package integrates with Jupyter to allow us to run Julia code from notebooks\n\nSame Jupyter you may have used with Python\n\n","type":"content","url":"/l01-02-setup#step-2-install-ijulia-jl","position":9},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Install IJulia","lvl2":"Step 2: Install IJulia.jl"},"type":"lvl3","url":"/l01-02-setup#task-install-ijulia","position":10},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Install IJulia","lvl2":"Step 2: Install IJulia.jl"},"content":"Launch the Julia REPL (by typing julia from the Linux/OSX terminal prompt or using the start menu on Windows)\n\nAt the juila> prompt, type ]\n\nPrompt will switch to (@v1.11) pkg> \n\nOnce there type add IJulia and press enter\n\nIJulia.jl will be downloaded and installed on your machine\n\n","type":"content","url":"/l01-02-setup#task-install-ijulia","position":11},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Start IJulia","lvl2":"Step 2: Install IJulia.jl"},"type":"lvl3","url":"/l01-02-setup#task-start-ijulia","position":12},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Start IJulia","lvl2":"Step 2: Install IJulia.jl"},"content":"At the juila> prompt (press backspace to exit Pkg mode if needed), type using IJulia\n\nThen run the command: IJulia.notebook()\n\nA web browser should pop open with the IJulia.jl interface (should look similar to what I’m using)\n\n","type":"content","url":"/l01-02-setup#task-start-ijulia","position":13},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Step 3: Install Visual Studio Code"},"type":"lvl2","url":"/l01-02-setup#step-3-install-visual-studio-code","position":14},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Step 3: Install Visual Studio Code"},"content":"While we can and will use the native Julia REPL and first-party Jupyter software for our lecture notes, it is also helpful to have the ability to edit and run Julia code in a more full-featured editor\n\nFor this we will use Visual Studio Code (VSCode)\n\nVSCode is a free, open-source, cross-platform editor that has a large community of users and developers\n\nIt also has great support for Julia\n\nLearning how to use a general purpose text editor will help you in the long run\n\nYou can use it for Julia, Python, R, C, C++, etc.\n\nYou can use it for writing papers, taking notes, etc.\n\nNote on VS Code alternatives: There are several popular forks/alternatives to VS Code that provide enhanced features, particularly for AI-assisted coding:\n\nCursor: An AI-first code editor built on VS Code with enhanced AI capabilities\n\nWindsurf: Another AI-powered editor with advanced coding assistance features\n\nThese alternatives generally maintain compatibility with VS Code extensions (including the Julia extension), so you can use any of them for this course if you prefer. The instructions below will work for VS Code and most of its forks.\n\n","type":"content","url":"/l01-02-setup#step-3-install-visual-studio-code","position":15},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Download/Install VS Code","lvl2":"Step 3: Install Visual Studio Code"},"type":"lvl3","url":"/l01-02-setup#task-download-install-vs-code","position":16},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Download/Install VS Code","lvl2":"Step 3: Install Visual Studio Code"},"content":"Download and install VSCode from \n\nhere\n\nFollow all system prompts and accept default options\n\nOpen/launch VSCode\n\n","type":"content","url":"/l01-02-setup#task-download-install-vs-code","position":17},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Install Julia extension","lvl2":"Step 3: Install Visual Studio Code"},"type":"lvl3","url":"/l01-02-setup#task-install-julia-extension","position":18},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Install Julia extension","lvl2":"Step 3: Install Visual Studio Code"},"content":"VSCode has a large ecosystem of extensions that add functionality to the editor\n\nWe will install the Julia extension to add Julia support to VSCode\n\nIn VSCode, click on the “Extensions” icon in the left-hand toolbar (looks like a box with four squares in it)\n\nSearch for “Julia” and click the “Install” button on the “Julia” extension (subtitle is “Julia Language Support”)\n\n","type":"content","url":"/l01-02-setup#task-install-julia-extension","position":19},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: run Julia code in VSCode","lvl2":"Step 3: Install Visual Studio Code"},"type":"lvl3","url":"/l01-02-setup#task-run-julia-code-in-vscode","position":20},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: run Julia code in VSCode","lvl2":"Step 3: Install Visual Studio Code"},"content":"We can now run Julia code in VSCode\n\nOpen a new file in VSCode (File -> New File)\n\nType the following code into the file:println(\"Hello world!\")\n\nSave the file as hello.jl in a location you can find later\n\nPress Ctrl + Shift + P (or Cmd + Shift + P on Mac) to open the command palette\n\nType “Julia” and select “Julia: Run file in new process”\n\nYou should see the output of the code show up in a new terminal window within VS Code\n\n","type":"content","url":"/l01-02-setup#task-run-julia-code-in-vscode","position":21},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: run code with shift + Enter","lvl2":"Step 3: Install Visual Studio Code"},"type":"lvl3","url":"/l01-02-setup#task-run-code-with-shift-enter","position":22},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: run code with shift + Enter","lvl2":"Step 3: Install Visual Studio Code"},"content":"Go back to hello.jl and add the coden = 5\nP = rand(n, n)\n\nThen, put your cursor on the line that contains n = and press shift and enter at the same time\n\nThis will start a new Julia REPL within your VS Code session and execute the code for you\n\nIt will also move your cursor down to the P = line. Press shift + enter again to execute that line\n\n","type":"content","url":"/l01-02-setup#task-run-code-with-shift-enter","position":23},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Open Notebooks Locally"},"type":"lvl2","url":"/l01-02-setup#open-notebooks-locally","position":24},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Open Notebooks Locally"},"content":"You should view/follow along with lectures on the your computer\n\nBeing able to run code on your machine is critical for success in this course and will allow you to take skills with you after the course\n\n","type":"content","url":"/l01-02-setup#open-notebooks-locally","position":25},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Download notebooks","lvl2":"Open Notebooks Locally"},"type":"lvl3","url":"/l01-02-setup#task-download-notebooks","position":26},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Download notebooks","lvl2":"Open Notebooks Locally"},"content":"Go to the course website and download the notebooks for the first week\n\nMove the downloaded folder from your “Downloads” folder to wherever you’d like to store materials for the semester\n\nFollow the instructions above to start Julia, load IJulia, and open the Jupyter notebook with IJulia\n\nInside your local Jupyter notebook instance (in your web browser), navigate to where you copied the “Handouts” folder and open up this notebook\n\n","type":"content","url":"/l01-02-setup#task-download-notebooks","position":27},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Open notebook in vscode","lvl2":"Open Notebooks Locally"},"type":"lvl3","url":"/l01-02-setup#task-open-notebook-in-vscode","position":28},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Open notebook in vscode","lvl2":"Open Notebooks Locally"},"content":"You can also run Jupyter notebooks directly in VS Code\n\nOpen VS Code and click on the “File” menu and select “Open Folder”\n\nNavigate to where you copied the notebooks for the first week\n\nClick on the “L01.02_setup.ipynb” file in the left-hand toolbar\n\nYou should see the notebook open in VS Code\n\nYou can run cells by clicking the “Run Cell” button in the top right of each cell, or by pressing Shift + Enter while your cursor is in the cell\n\nA menu will appear, choose the option containing Julia Release\n\nTest this out below\n\n# some random Julia code\nprintln(\"That's all, folks!\")","type":"content","url":"/l01-02-setup#task-open-notebook-in-vscode","position":29},{"hierarchy":{"lvl1":"Julia Foundations"},"type":"lvl1","url":"/l01-03-julia-basics","position":0},{"hierarchy":{"lvl1":"Julia Foundations"},"content":"Computational Analysis of Social Complexity\n\nFall 2025, Spencer Lyon\n\nPrerequisites\n\nLaptop or personal computer with internet connection\n\nOutcomes\n\nUnderstand the main benefits and features of Julia\n\nSee how to define variables, functions, and types in Julia\n\nInstall commonly used packages for Graphs, DataFrames, Plotting and more\n\nReferences\n\nPackages and Software Engineering sections of QuantEcon julia lectures\n\nJulia \n\ndocumentation\n\nDocumentation for packages: \n\nGraphs, \n\nDataFrames, \n\nPlots\n\n","type":"content","url":"/l01-03-julia-basics","position":1},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"What is Julia?"},"type":"lvl2","url":"/l01-03-julia-basics#what-is-julia","position":2},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"What is Julia?"},"content":"Julia is a relatively new programming language (first public release in 2012, 1.0 release in 2018)\n\nGeneral purpose, but specializes in numerical computation\n\nLeverages advanced compiler technology to generate very efficient code\n\nIt can be as clear to read and write as Python, and as quick to evaluate as C!\n\n","type":"content","url":"/l01-03-julia-basics#what-is-julia","position":3},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Core Types"},"type":"lvl2","url":"/l01-03-julia-basics#core-types","position":4},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Core Types"},"content":"We’ll start by learning about the core datatypes built in to Julia\n\nAlong the way we’ll pick up some of the key syntax elements\n\nWe will move quickly, so some prior programming experience would be helpful\n\n","type":"content","url":"/l01-03-julia-basics#core-types","position":5},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Numbers","lvl2":"Core Types"},"type":"lvl3","url":"/l01-03-julia-basics#numbers","position":6},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Numbers","lvl2":"Core Types"},"content":"Let’s start with numbers\n\nTo work with a number, just type it!\n\n42\n\nWe can also do basic arithmetic in the way you would expect\n\n10 * 3\n\n1 + 2\n\nSo far we’ve worked with integers (whole numbers)\n\nJulia can also work with numbers containing a decimal\n\nIn Julia these are called floating point numbers\n\n1.234 ^ 2.2  # use `^` for exponentiation, not `**` like in python\n\n553.34 / 12.9\n\nWe can mix and match integers and floats\n\n25 / 2.5\n\n25 / 2  # dividing integers returns a float (notice the `.`)\n\nnotice we used # to define a comment\n\n","type":"content","url":"/l01-03-julia-basics#numbers","position":7},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Text Data"},"type":"lvl2","url":"/l01-03-julia-basics#text-data","position":8},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Text Data"},"content":"Not all data is numerical\n\nSome is textual\n\nTo represent text in Julia we use a String\n\nTo define a String we use quotation marks (\") as below\n\n\"My name is Spencer\"\n\n\"1\"  # an integer in a string\n\nYou cannot use single quotes for strings as in other languages (like Python or Javascript)\n\nGo ahead... try it by removing the # and excuting the cell below\n\n# 'hello'\n\n\"\"\"\nThis\n\nis\n\nalso\n\na\n\nstring\n\"\"\"\n\n","type":"content","url":"/l01-03-julia-basics#text-data","position":9},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Arrays"},"type":"lvl2","url":"/l01-03-julia-basics#arrays","position":10},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Arrays"},"content":"When doing numerical work, we often need to deal with multiple pieces of data at the same time\n\nIn Julia the default way of doing this is to use an array\n\nArrays are defined with [ and ] as below\n\n[1, 2, 3.14]  # a 3 element array\n\n[1 2 3]  # a 1x3 matrix\n\n[1 2; 3 4]  # a 2x2 matrix\n\n[1 2\n 3 4]  # another way to write a 2x2 matrix\n\n[1 \"hello\"; 2 \"world\"]  # a 2x2 matrix with int and string\n\n","type":"content","url":"/l01-03-julia-basics#arrays","position":11},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Accessing array items","lvl2":"Arrays"},"type":"lvl3","url":"/l01-03-julia-basics#accessing-array-items","position":12},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Accessing array items","lvl2":"Arrays"},"content":"We can use [N] to access the Nth element\n\nWe can also use [i:j] to access items i through j\n\nFinally we can use [[n1, n2]] to access the n1th and n2th elements\n\n[100, 101, 102, 103][2]\n\n[100, 101, 102, 103][2:4]\n\n[100, 101, 102, 103][[1, 3]]\n\nNote that unlike Python, Julia starts counting at 1\n\nAlso note that end can be used to refer to the last element, end-1 to second to last, and so on\n\n[1, 2, 3, 4][end]\n\n[1, 2, 3, 4][end-2]\n\n","type":"content","url":"/l01-03-julia-basics#accessing-array-items","position":13},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Tuples"},"type":"lvl2","url":"/l01-03-julia-basics#tuples","position":14},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Tuples"},"content":"There is another data type for holding “lists” of data called a tuple\n\nTuples are create using parenthesis instead of square brackets as follows\n\n(1, 2, 3, \"hello\")\n\n(\"hello\", 5)\n\n(\"hello\", 5)[2]\n\nThe main differences between tuples and arrays are\n\nTuples are meant to hold immutable or non-changing data\n\nTuples aren’t usually meant for computation or linear algebra\n\n","type":"content","url":"/l01-03-julia-basics#tuples","position":15},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Dictionary"},"type":"lvl2","url":"/l01-03-julia-basics#dictionary","position":16},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Dictionary"},"content":"Very often in programming we want to be able to associate a key or name to a specific value\n\nOne data type for doing that is a Dict\n\nDicts are created with the somewhat inconvenient syntax Dict(name => value, ...) where the ... means we can repeat the pattern multiple times\n\nThey keys and values can be of any type\n\nDict(\"x\" => 1, 2 => \"y\", [\"w\", \"z\"] => [1, 2, 3])\n\n# use `[name]` to access element with `name`\nDict(\"x\" => 1, 2 => \"y\", [\"w\", \"z\"] => [1, 2, 3])[2]\n\nDict(\"x\" => 1, \"y\" =>2)\n\nDictionaries are often used for passing around groups of parameters\n\nWe’ll see examples later on\n\n","type":"content","url":"/l01-03-julia-basics#dictionary","position":17},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Named Tuples"},"type":"lvl2","url":"/l01-03-julia-basics#named-tuples","position":18},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Named Tuples"},"content":"The final “collection” we’ll talk about is the named tuple\n\nIt is a hybrid between a tuple and a dictionary\n\nTo create them we use the synax (name = value, ...)\n\nThey names or keys need to be just names (not numbers or arrays). The values can be anything\n\n(x = 1, y = 2, z=\"hello\")\n\n(x = 1, y = 2, z=\"hello\").z # use `.name` to access item\n\nNamed tuples are a newer feature of Julia\n\nThey are often used for the same purpsoes as dictionaries because the syntax is much cleaner\n\n","type":"content","url":"/l01-03-julia-basics#named-tuples","position":19},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Variables"},"type":"lvl2","url":"/l01-03-julia-basics#variables","position":20},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Variables"},"content":"Often when programming, we need to refer to the same piece of data more than once\n\nTo do this we use a variable\n\nVariables are defined using an =, as in name = value\n\nx = 1\n\ny = 42\n\nx + y  # 'use' or 'refer to' x and y\n\nm1 = [1 0; 0 1]\n\nm2 = [1 2; 3 4]\n\nm1 * m2  # matrix multiplication\n\nm2 * m2  # again -- but with something besides identity matrix!\n\nd = Dict(\"X\" => 1, \"Y\" => 2)\n\nd[\"X\"]\n\n","type":"content","url":"/l01-03-julia-basics#variables","position":21},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Functions"},"type":"lvl2","url":"/l01-03-julia-basics#functions","position":22},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Functions"},"content":"Most Julia programs do more than basic arithmetic operations on data\n\nTo apply an operation to a piece of data, we call a function\n\nTo call a function we use the function_name(data1, data2)\n\nA very handy function is the typeof function\n\ntypeof(1)\n\ntypeof(2.0)\n\ntypeof([1,2,3])\n\ntypeof([1 2; 3 4.0])\n\nMany standard operations are built in to Julia as functions\n\nsum([1, 2, 3])  # compute sum of array of numbers\n\ninv([1 2; 3 4])  # matrix inverse\n\nsize([1 2; 3 4])  # number of (rows, columns)  in matrix\n\nlength([1, 2, 3])  # number of elements in array\n\nlength([1 2; 3 4])  # returns total number of elements in a Matrix\n\nrand(2, 2, 2)  # a 2x2x2 array of random numbers, sampled from uniform[0,1] dist\n\nJulia has 1000s of functions\n\nWe’ll learn more as we go along...\n\nJust watch for the pattern with parentisis: name(args)\n\n","type":"content","url":"/l01-03-julia-basics#functions","position":23},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Defining Functions","lvl2":"Functions"},"type":"lvl3","url":"/l01-03-julia-basics#defining-functions","position":24},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Defining Functions","lvl2":"Functions"},"content":"Functions are used to execute a predefined set of operations\n\nDefining our own funcitons allows us to break programs into small, easily written an understood components\n\nWe define functions using the syntaxfunction name(arg1, arg2)\n    # steps\nend\n\nfunction mean(x)\n    total = sum(x)\n    N = length(x)\n    total / N\nend\n\nmean([1, 2, 3])\n\n# mean of 1000 random samples from U[0,1] -- should be ~ 0.5\nmean(rand(1000))\n\nIf a function only contains one line of code, you can also use a shorthand notation:function_name(arg1, arg2) = # step\n\nadd_two(x) = x + 2\n\nadd_two(40)\n\n","type":"content","url":"/l01-03-julia-basics#defining-functions","position":25},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Getting help for functions"},"type":"lvl2","url":"/l01-03-julia-basics#getting-help-for-functions","position":26},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Getting help for functions"},"content":"Given that there are so many functions, sometimes it is hard to remember exactly what a function does\n\nThankfully we can get help from Julia\n\nIf we type ?function_name, Julia will present us with documentation about the function\n\n?map\n\n?extrema\n\n","type":"content","url":"/l01-03-julia-basics#getting-help-for-functions","position":27},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Control Flow"},"type":"lvl2","url":"/l01-03-julia-basics#control-flow","position":28},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Control Flow"},"content":"Julia has the basic elements of control flow:\n\nif-else statements\n\nfor loops\n\nif 1 > 2 # no parenthesis needed\n    println(\"what???\")\nelse     # else is optional\n    return mean([1, 2, 3])\n    print(\"phew\")\nend      # all \"blocks\" terminate with word `end`\n\nfor i in 1:5 # range of numbers 1 to 5\n    println(i, \" \", i^2)\nend\n\nWe will see many more examples as we go forward\n\n","type":"content","url":"/l01-03-julia-basics#control-flow","position":29},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Packages"},"type":"lvl2","url":"/l01-03-julia-basics#packages","position":30},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Packages"},"content":"Julia comes ready to go with many powerful functions and data types\n\nHowever, there is a very active community of Julia programmers who are experts in different subfields of science and engineering\n\nThis has led to the development of vibrant and exciting ecosystem of packages or toolboxes for performing specific tasks\n\nWe can access these routines by using Julia packages\n\n","type":"content","url":"/l01-03-julia-basics#packages","position":31},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Loading packages","lvl2":"Packages"},"type":"lvl3","url":"/l01-03-julia-basics#loading-packages","position":32},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Loading packages","lvl2":"Packages"},"content":"By default Julia ships with a “standard library”\n\nThese are packages that come bundled with Julia itself and are pre-installed\n\nTo load a package and all of its types/functions use the using keyword\n\nFor example, we can load the Dates package and start using it\n\nusing Dates\n\nt1 = Dates.now()\n\nDates.format(t1, \"yyyy-mm-dd\")\n\nt2 = Dates.now()\n\nt2 > t1\n\nt3 = DateTime(1776, 7, 4)\n\n\"America is $(t1 - t3) ($(floor(t1 - t3, Dates.Day))) old\"\n\n","type":"content","url":"/l01-03-julia-basics#loading-packages","position":33},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Installing Packages","lvl2":"Packages"},"type":"lvl3","url":"/l01-03-julia-basics#installing-packages","position":34},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Installing Packages","lvl2":"Packages"},"content":"In addition to the standard library, we can also use packages created by other Julia users\n\nTo use a 3rd party package, we first need to install it\n\nThere are two ways to do this\n\n1]add PackageName\n\n2using Pkg  # a standard library package\nPkg.add(\"PackageName\")\n\nLet’s try them both\n\n]add Plots\n\nusing Pkg\nPkg.add(\"DataFrames\")\n\nAfter installing packages, we can load and use them just as we did the standard library packages\n\nusing Plots  # Python: from Plots import *\n\nplot([sin, cos], -2pi, 2pi)\n\nusing DataFrames\ndf = DataFrame(c1=1:10, c2=(1:10).^2)\n\n","type":"content","url":"/l01-03-julia-basics#installing-packages","position":35},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Package Composability","lvl2":"Packages"},"type":"lvl3","url":"/l01-03-julia-basics#package-composability","position":36},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Package Composability","lvl2":"Packages"},"content":"One unique feature sof Julia is that most of the language itself, in addition to packages, are written in Julia\n\nFor other languages like Python or R the “built in” part of the language is often written in another language like C\n\nThis difference has a large impact for Julia users\n\nBuilt in code and user code (including packages) are given the same “treatment”\n\nAnything the language creators can do, so can you\n\nA practical implication of this is that packages can operate on built in types (like we saw in our examples above) as well as types from other packages\n\nLet’s see what this looks like by plotting a DataFrame\n\n# install \"StatsPlots\", which links Plots and DataFrames\nPkg.add(\"StatsPlots\")\n\nusing StatsPlots\n\n@df df scatter(:c1, :c2)\n\nPkg.add(\"RDatasets\") # common datasets from R programming language\nusing RDatasets\nschool = RDatasets.dataset(\"mlmRev\",\"Hsb82\")\n@df school density(:MAch, group = :Sx)\n\n@df school density(:MAch, group = (:Sx, :Sector))","type":"content","url":"/l01-03-julia-basics#package-composability","position":37},{"hierarchy":{"lvl1":"Julia Types and Methods"},"type":"lvl1","url":"/l02-01-julia-types-methods","position":0},{"hierarchy":{"lvl1":"Julia Types and Methods"},"content":"Computational Analysis of Social Complexity\n\nFall 2025, Spencer Lyon\n\nPrerequisites\n\nLaptop or personal computer with internet connection\n\nJulia intro lecture\n\nOutcomes\n\nUnderstand key components of Julia’s type system: abstract types, primitive types, composite types, and parametric types\n\nBe able to define our own custom types to hold data\n\nUnderstand the concept of multiple dispatch\n\nBe able to leverage the mulitple dispatch system to define custom behavior for built-in and custom types\n\nReferences\n\nLecture notes\n\nJulia documentation on \n\ntypes and \n\nmethods (these are technical, but comprehensive and well-written)\n\nQuantEcon lectures on \n\ntypes and generic programming\n\n","type":"content","url":"/l02-01-julia-types-methods","position":1},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl2":"Types in Julia"},"type":"lvl2","url":"/l02-01-julia-types-methods#types-in-julia","position":2},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl2":"Types in Julia"},"content":"Julia is both very expressive and runtime efficient\n\nThis is made possible because of the underlying compiler technology\n\nThe main strategy for user interaction with the compiler is by defining custom types and methods that operate on those types\n\nTypes and multiple dispatch go hand in hand and are key to effective Julia\n\n","type":"content","url":"/l02-01-julia-types-methods#types-in-julia","position":3},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"What is a type?","lvl2":"Types in Julia"},"type":"lvl3","url":"/l02-01-julia-types-methods#what-is-a-type","position":4},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"What is a type?","lvl2":"Types in Julia"},"content":"Each piece of data in a program resides in memory (RAM) on the host computer\n\nWe often assign names to data, which we call variables (in x = \"hello\", x is a variable)\n\nAt its most basic level, a variable is composed of\n\nAn arrangment of 0’s and 1’s called bits\n\nAn address to where in memory the data is recorded\n\nA Symbol representing the name we gave the data\n\nA type in Julia represents what kind of object is represented at a certain memory address\n\nJulia uses this type information to enable syntax (e.g. the $ in a string to interpolate or the . access for an objects fields) and ultimiately decide what behaviors are defined to operate on the data\n\n","type":"content","url":"/l02-01-julia-types-methods#what-is-a-type","position":5},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Organizing types","lvl2":"Types in Julia"},"type":"lvl3","url":"/l02-01-julia-types-methods#organizing-types","position":6},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Organizing types","lvl2":"Types in Julia"},"content":"In Julia types are organized into a hierarchy\n\nAt the top of the hierarcy is Any -- all objects are instances of Any\n\nAt the bottom of the hierarchy is Union{} -- no objects are instances of Union{}\n\nIn between these endpoints we have a rich family of types\n\nEach type can have at most one parent type (if not specified, default parent is Any)\n\nTypes can actually come in a few different flavors...\n\n","type":"content","url":"/l02-01-julia-types-methods#organizing-types","position":7},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Types of Types","lvl2":"Types in Julia"},"type":"lvl3","url":"/l02-01-julia-types-methods#types-of-types","position":8},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Types of Types","lvl2":"Types in Julia"},"content":"Abstract Types: cannot be created directly, but serve as nodes in a type hierarchy. Help us organize types into families and provide shared behavior for all members of the family\n\nPrimitive types: provided to us by Julia and represent a collection of bits (e.g. Float64, Bool, and Int8). We could create them, but we won’t. We won’t say anything else about them here\n\nComposite Types: types that contain additional data called fields. An instance can be treated as a single value. This is what we typically define and use\n\nNOTE: all objects in Julia are instances of either primitive or composite types, and can be related to one another by sharing common abstract type ancestors\n\n","type":"content","url":"/l02-01-julia-types-methods#types-of-types","position":9},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl2":"Abstract Types"},"type":"lvl2","url":"/l02-01-julia-types-methods#abstract-types","position":10},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl2":"Abstract Types"},"content":"Abstract types help organize composite types into families\n\nFor example, the number system in Julia looks like this (really -- look \n\nhere)abstract type Number end\nabstract type Real     <: Number end\nabstract type AbstractFloat <: Real end\nabstract type Integer  <: Real end\nabstract type Signed   <: Integer end\nabstract type Unsigned <: Integer end\n\nNote:\n\nNumber’s parent type is Any\n\nReal is a special kind of Number and can be broken into two subgroups: AbstractFloat and Integer\n\n","type":"content","url":"/l02-01-julia-types-methods#abstract-types","position":11},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Why Abstract Types?","lvl2":"Abstract Types"},"type":"lvl3","url":"/l02-01-julia-types-methods#why-abstract-types","position":12},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Why Abstract Types?","lvl2":"Abstract Types"},"content":"We said before we can’t create an instance of abstract types...\n\nSo, why do we have them?\n\nThe primary reason to have abstract types is to introduced shared functionality via methods defined on the abstract type\n\nExample: suppose you needed to define a function isint to determine if an object is an integer\n\nWithout abstract types, you could have a long sequence of checks for if a variable is any integer type:\n\nfunction isint1(x)\n\tfor T in [\n\t\tInt8, UInt8, Int16, UInt16, \n\t\tInt32, UInt32, Int64, UInt64, \n\t\tInt128, UInt128\n\t]\n\t\tif isa(x, T)\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend\n\nisint1(10), isint1(\"Hello\")\n\nWith abstract types we can define two methods:\n\nisint(x) = false\nisint(x::Integer) = true\n\nisint(10), isint(\"Hello\")\n\nThis has many benefits\n\nMuch simpler to write/reason about\n\nMore “fool proof”: what if we forgot one of the “UIntXX” types?\n\nMore “future proof”: what if a new type of integer gets introduced (e.g. UInt256 like is widely used in blockchain data!)\n\nPushes work into the compiler:\n\n@code_lowered isint1(\"hello\")\n\n@code_lowered isint1(UInt128(12341234123423134))\n\n@code_lowered isint(\"hello\") \n\n@code_lowered isint(UInt128(12341234123423134))\n\n","type":"content","url":"/l02-01-julia-types-methods#why-abstract-types","position":13},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl2":"Composite Types"},"type":"lvl2","url":"/l02-01-julia-types-methods#composite-types","position":14},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl2":"Composite Types"},"content":"Abstract types are very useful when used in conjunction with multiple dispatch (defining multiple methods of function with same name, but varying code depending on argument types)\n\nHowever, most often we create types to hold collections of related data together\n\nWe do this using composite types\n\nA composite type can be created as follows:struct Name <: AbstractParentType\n    field1::Field1Type\n\t# more fields\nend\n\nNote that the <: AbstractParentType is optional, as are types on all fields\n\n","type":"content","url":"/l02-01-julia-types-methods#composite-types","position":15},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Composite Types: Examples","lvl2":"Composite Types"},"type":"lvl3","url":"/l02-01-julia-types-methods#composite-types-examples","position":16},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Composite Types: Examples","lvl2":"Composite Types"},"content":"\n\nstruct Foo\n   bar\n   baz::Int\n   qux::Float64\nend\n\nfoo = Foo(\"Hello, world.\", 23, 1.5)\n\ntypeof(foo)\n\n# this will not work. Uncomment and try it out\n# Foo((), 23.5, 1)\n\nfieldnames(Foo)\n\nfoo.bar\n\nfoo.baz\n\nfoo.qux\n\n","type":"content","url":"/l02-01-julia-types-methods#composite-types-examples","position":17},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Composite Types and Dispatch","lvl2":"Composite Types"},"type":"lvl3","url":"/l02-01-julia-types-methods#composite-types-and-dispatch","position":18},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Composite Types and Dispatch","lvl2":"Composite Types"},"content":"Above we saw an example of defining multiple methods of isint, using an abstract type to route dispatch\n\nWe can also use composite types\n\nisint(x::Foo) = isint(x.bar)\n\nisint(10), isint(1.0), isint(UInt128(234901324987213)), isint(Foo(\"not an int\", 12, 1.0))\n\n@code_lowered isint(Foo(\"not an int\", 12, 1.0))\n\n@code_lowered isint(UInt128(12341234123423134))\n\nisint(foo)\n\nfoo, isint(foo)\n\nisint(Foo(1, 23, 1.5))\n\n","type":"content","url":"/l02-01-julia-types-methods#composite-types-and-dispatch","position":19},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Exercises","lvl2":"Composite Types"},"type":"lvl3","url":"/l02-01-julia-types-methods#exercises","position":20},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Exercises","lvl2":"Composite Types"},"content":"Create an abstract type called Person\n\nCreate two composite subtypes of Person called Friend and Foe\n\nEach of these should have fields name and height_inches\n\nFor friend you should also have a field favorite_color\n\nMAKE SURE TO ADD TYPES FOR ALL FIELDS\n\nCreate a third composite subtype of Person called Stranger, but without any fields\n\nSuppose we are trying to decide who to invite to a dinner party. Our rule is that friends should get a definite yes. Enemies a definite no. Strangers a 50%/50% toss up. However, if our spouse says we should invite a person, the answer is always yes\n\nCreate a function should_invite_to_party that implements that logic\n\nHINT: you will need 4 methods. 3 of these have only one argument, the 4th has two\n\nIn the cell at the bottom we have written a test case. You will know you’ve done this correctly when all the tests pass\n\n# Your code here\n\nusing Test\n\nfunction tests()\n\t@testset \"people\" begin\n\t\n\t\t@test fieldnames(Friend) == (:name, :height_inches, :favorite_color)\n\t\t@test fieldnames(Foe) == (:name, :height_inches)\n\t\t@test fieldnames(Stranger) == tuple()\n\n\t\tjim = Friend(\"Jim\", 64, \"blue\")\n\t\tdwight = Foe(\"Dwight\", 61)\n\t\tcreed = Stranger()\n\n\t\t@test jim isa Person\n\t\t@test dwight isa Person\n\t\t@test creed isa Person\n\n\t\t@test should_invite_to_party(jim) \n\t\t@test !should_invite_to_party(dwight)\n\t\t@test should_invite_to_party(dwight, true)\n\t\t\n\t\tcreed_invites = map(i->should_invite_to_party(creed), 1:100)\n\t\t@test any(creed_invites)\n\t\t@test any(map(!, creed_invites))\n\n\t\tcreed_invites_spouse = map(i->should_invite_to_party(creed, true), 1:100)\n\t\t@test all(creed_invites_spouse)\t\n\tend\nend\n\n# uncomment and run this cell when you are ready to test your code\ntests()","type":"content","url":"/l02-01-julia-types-methods#exercises","position":21}]}