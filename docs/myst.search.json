{"version":"1","records":[{"hierarchy":{"lvl1":"Welcome"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Welcome"},"content":"Computational Analysis of Social Complexity\n\nFall 2025, Spencer Lyon\n\nWelcome to week 1!\n\nThis week we will get to know eachother and get on the same page with respect to what this class is all about.\n\nWe will also dive right in to the computational infrastructure we will need by installing the Julia programming langauge and learning a bit about how to use it.\n\nEach week lecture notes will be distributed as a collection of Jupyter notebooks. The notebooks will follow a strict naming convention, where each notebook has a name such as L@@.##_XXX.ipynb where @@ is a two digit lecture number and ## is a two digit file number and XXX is one or more words describing the content of the notebook. We will work through the notebooks in the order indicated by the ##. The XXX are to provide easier access when reviewing notes after class.\n\n","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Welcome","lvl2":"About Me"},"type":"lvl2","url":"/#about-me","position":2},{"hierarchy":{"lvl1":"Welcome","lvl2":"About Me"},"content":"Spencer Lyon (\n\nspencer​.lyon@ucf​.edu)\n\nEconomics PhD from NYU (2018)\n\nLove to teach: mostly economics, data science, AI/ML – all have\nprogramming/computational element\n\nMoved to Orlando in July 2018 with wife and 5 (yes!) kids\n\nRun consulting (training/projects) business:   Valorum Data\n\nWorking on a couple startups\n\n","type":"content","url":"/#about-me","position":3},{"hierarchy":{"lvl1":"Welcome","lvl2":"About you"},"type":"lvl2","url":"/#about-you","position":4},{"hierarchy":{"lvl1":"Welcome","lvl2":"About you"},"content":"Background?\n\nProgress in program?\n\nAreas of interest? (meaningful answers here! they matter…)\n\nRumors about the course?\n\n","type":"content","url":"/#about-you","position":5},{"hierarchy":{"lvl1":"Welcome","lvl2":"About the course"},"type":"lvl2","url":"/#about-the-course","position":6},{"hierarchy":{"lvl1":"Welcome","lvl2":"About the course"},"content":"Interdisciplinary by nature\n\n“Living course”: only been taught a handful of times, content is flexible\n\nMore ideas/topics than time!\n\nHas been altered fairly significantly over the past few years (but the heart/soul of the course remains the same)\n\nNo required topics or standard textbook, so we get to pick!\n\nTheoretical concepts\n\nGraphs: less detail than network science course, but more algorithms\n\nGame Theory: strategic interaction/competition\n\nAgent Based Models: simulation of rule based systems\n\nAuction theory: Game theory at scale in bidding markets\n\nBlockchain: cryptographically secure, public, distributed ledger\n\nSocial, information, financial networks\n\nApplications\n\nTwitter\n\nEconomic markets and trade\nnetwork\n\nMore...\n\n","type":"content","url":"/#about-the-course","position":7},{"hierarchy":{"lvl1":"Welcome","lvl2":"Expectations"},"type":"lvl2","url":"/#expectations","position":8},{"hierarchy":{"lvl1":"Welcome","lvl2":"Expectations"},"content":"Take the time in the first 2 weeks to learn Julia\n\nYou’ll be glad you did\n\nContent moves quick and you don’t want syntax/programming to distract you or hold you back\n\nStudy reading assignments before class\n\nComplete assignments on time -- no exceptions\n\nParticipate in in-class discussions\n\nSpend ~3-6 hours outside of class per week\n\nCommunication\n\nPost all content related questions to class discussion forum\n\nRespond to peers’ questions and engage in discussions\n\nPersonal questions should go directly to me via email\n\nI do not use email on Sunday. Other days I will respond within 48 hours.\n\nDeliverables\n\nHomework (~8 – 30%)\n\nExam (2 – 30%)\n\nProjects (2 – 30%)\n\nCitizenship (throughout - 10%)\n\nFirst best: attend class in person, actively participate\n\nAcceptable: attend virtually, but keep video on and be ready to speak up when called on\n\nUnacceptable: attend virtually, but keep video off and/or don’t participate in discussions\n\n","type":"content","url":"/#expectations","position":9},{"hierarchy":{"lvl1":"Welcome","lvl2":"Tools/Resources"},"type":"lvl2","url":"/#tools-resources","position":10},{"hierarchy":{"lvl1":"Welcome","lvl2":"Tools/Resources"},"content":"Core textbooks\n\nNetworks, Crowds, and Markets by David Easley and Jon Kleinberg\n\nEconomics Networks by John Stachurski and Thomas Sargent\n\nWill be supplemented by lecture notes for more computational content\n\nJulia Programming language\n\nLecture notes are accessible via the \n\ncourse website\n\nLecture notes AND assignments in Jupyter notebooks\n\nAll course administration will happen through webcourses (Canvas)\n\nAssignments me <-> you\n\nFeedback on assignments me -> you\n\nDiscussion me + you <-> me + you\n\nOfficial grades will be visible on canvas","type":"content","url":"/#tools-resources","position":11},{"hierarchy":{"lvl1":"Julia Setup"},"type":"lvl1","url":"/l01-02-setup","position":0},{"hierarchy":{"lvl1":"Julia Setup"},"content":"Computational Analysis of Social Complexity\n\nFall 2025, Spencer Lyon\n\nPrerequisites\n\nLaptop or personal computer with internet connection\n\nOutcomes\n\nInstall Julia and IJulia locally\n\nInstall VS Code\n\nOpen lecture notes locally\n\nReferences\n\nLecture notes\n\nQuantEcon lectures\n\nSetting up Julia\n\nGit, GitHub, Version Control\n\nJulia tools and editors\n\n","type":"content","url":"/l01-02-setup","position":1},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Step 1: Install Julia"},"type":"lvl2","url":"/l01-02-setup#step-1-install-julia","position":2},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Step 1: Install Julia"},"content":"The first step is to install Julia\n\n","type":"content","url":"/l01-02-setup#step-1-install-julia","position":3},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Install Julia","lvl2":"Step 1: Install Julia"},"type":"lvl3","url":"/l01-02-setup#task-install-julia","position":4},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Install Julia","lvl2":"Step 1: Install Julia"},"content":"Windows: windows users can install Julia from the microsoft store OR by running winget install --name Julia --id 9NJNWW8PVKMN -e -s msstore from powershell\n\nMac/Linux: Open terminal and run curl -fsSL https://install.julialang.org | sh (it is safe -- I promise ;))\n\n","type":"content","url":"/l01-02-setup#task-install-julia","position":5},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Launch Julia REPL","lvl2":"Step 1: Install Julia"},"type":"lvl3","url":"/l01-02-setup#task-launch-julia-repl","position":6},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Launch Julia REPL","lvl2":"Step 1: Install Julia"},"content":"Launch the Julia REPL (read-eval-print-loop) by clicking on the Julia icon or running julia from your shell (PowerShell or Terminal)\n\nYou will be greeted with a prompt that looks like this:   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.11.6 (2025-07-09)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> \n\nYou are now in what is called the Julia REPL (read-eval-print-loop). This is a place where you can type Julia commands and have them executed immediately.\n\nTest it out by typing rand(2, 2) and pressing enter\n\nYou should see something like this (note the numbers will be different for you):julia> rand(2, 2)\n2×2 Matrix{Float64}:\n 0.698944  0.676245\n 0.17375   0.448243\n\nCongratulations! You have successfully installed Julia and are ready to move on to the next step!\n\n","type":"content","url":"/l01-02-setup#task-launch-julia-repl","position":7},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Step 2: Install IJulia.jl"},"type":"lvl2","url":"/l01-02-setup#step-2-install-ijulia-jl","position":8},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Step 2: Install IJulia.jl"},"content":"With Julia installed we are now ready to install some Julia packages\n\nThe first package we’ll be using is called IJulia\n\nThis is a package integrates with Jupyter to allow us to run Julia code from notebooks\n\nSame Jupyter you may have used with Python\n\n","type":"content","url":"/l01-02-setup#step-2-install-ijulia-jl","position":9},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Install IJulia","lvl2":"Step 2: Install IJulia.jl"},"type":"lvl3","url":"/l01-02-setup#task-install-ijulia","position":10},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Install IJulia","lvl2":"Step 2: Install IJulia.jl"},"content":"Launch the Julia REPL (by typing julia from the Linux/OSX terminal prompt or using the start menu on Windows)\n\nAt the juila> prompt, type ]\n\nPrompt will switch to (@v1.11) pkg> \n\nOnce there type add IJulia and press enter\n\nIJulia.jl will be downloaded and installed on your machine\n\n","type":"content","url":"/l01-02-setup#task-install-ijulia","position":11},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Start IJulia","lvl2":"Step 2: Install IJulia.jl"},"type":"lvl3","url":"/l01-02-setup#task-start-ijulia","position":12},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Start IJulia","lvl2":"Step 2: Install IJulia.jl"},"content":"At the juila> prompt (press backspace to exit Pkg mode if needed), type using IJulia\n\nThen run the command: IJulia.notebook()\n\nA web browser should pop open with the IJulia.jl interface (should look similar to what I’m using)\n\n","type":"content","url":"/l01-02-setup#task-start-ijulia","position":13},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Step 3: Install Visual Studio Code"},"type":"lvl2","url":"/l01-02-setup#step-3-install-visual-studio-code","position":14},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Step 3: Install Visual Studio Code"},"content":"While we can and will use the native Julia REPL and first-party Jupyter software for our lecture notes, it is also helpful to have the ability to edit and run Julia code in a more full-featured editor\n\nFor this we will use Visual Studio Code (VSCode)\n\nVSCode is a free, open-source, cross-platform editor that has a large community of users and developers\n\nIt also has great support for Julia\n\nLearning how to use a general purpose text editor will help you in the long run\n\nYou can use it for Julia, Python, R, C, C++, etc.\n\nYou can use it for writing papers, taking notes, etc.\n\nNote on VS Code alternatives: There are several popular forks/alternatives to VS Code that provide enhanced features, particularly for AI-assisted coding:\n\nCursor: An AI-first code editor built on VS Code with enhanced AI capabilities\n\nWindsurf: Another AI-powered editor with advanced coding assistance features\n\nThese alternatives generally maintain compatibility with VS Code extensions (including the Julia extension), so you can use any of them for this course if you prefer. The instructions below will work for VS Code and most of its forks.\n\n","type":"content","url":"/l01-02-setup#step-3-install-visual-studio-code","position":15},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Download/Install VS Code","lvl2":"Step 3: Install Visual Studio Code"},"type":"lvl3","url":"/l01-02-setup#task-download-install-vs-code","position":16},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Download/Install VS Code","lvl2":"Step 3: Install Visual Studio Code"},"content":"Download and install VSCode from \n\nhere\n\nFollow all system prompts and accept default options\n\nOpen/launch VSCode\n\n","type":"content","url":"/l01-02-setup#task-download-install-vs-code","position":17},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Install Julia extension","lvl2":"Step 3: Install Visual Studio Code"},"type":"lvl3","url":"/l01-02-setup#task-install-julia-extension","position":18},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Install Julia extension","lvl2":"Step 3: Install Visual Studio Code"},"content":"VSCode has a large ecosystem of extensions that add functionality to the editor\n\nWe will install the Julia extension to add Julia support to VSCode\n\nIn VSCode, click on the “Extensions” icon in the left-hand toolbar (looks like a box with four squares in it)\n\nSearch for “Julia” and click the “Install” button on the “Julia” extension (subtitle is “Julia Language Support”)\n\n","type":"content","url":"/l01-02-setup#task-install-julia-extension","position":19},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: run Julia code in VSCode","lvl2":"Step 3: Install Visual Studio Code"},"type":"lvl3","url":"/l01-02-setup#task-run-julia-code-in-vscode","position":20},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: run Julia code in VSCode","lvl2":"Step 3: Install Visual Studio Code"},"content":"We can now run Julia code in VSCode\n\nOpen a new file in VSCode (File -> New File)\n\nType the following code into the file:println(\"Hello world!\")\n\nSave the file as hello.jl in a location you can find later\n\nPress Ctrl + Shift + P (or Cmd + Shift + P on Mac) to open the command palette\n\nType “Julia” and select “Julia: Run file in new process”\n\nYou should see the output of the code show up in a new terminal window within VS Code\n\n","type":"content","url":"/l01-02-setup#task-run-julia-code-in-vscode","position":21},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: run code with shift + Enter","lvl2":"Step 3: Install Visual Studio Code"},"type":"lvl3","url":"/l01-02-setup#task-run-code-with-shift-enter","position":22},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: run code with shift + Enter","lvl2":"Step 3: Install Visual Studio Code"},"content":"Go back to hello.jl and add the coden = 5\nP = rand(n, n)\n\nThen, put your cursor on the line that contains n = and press shift and enter at the same time\n\nThis will start a new Julia REPL within your VS Code session and execute the code for you\n\nIt will also move your cursor down to the P = line. Press shift + enter again to execute that line\n\n","type":"content","url":"/l01-02-setup#task-run-code-with-shift-enter","position":23},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Open Notebooks Locally"},"type":"lvl2","url":"/l01-02-setup#open-notebooks-locally","position":24},{"hierarchy":{"lvl1":"Julia Setup","lvl2":"Open Notebooks Locally"},"content":"You should view/follow along with lectures on the your computer\n\nBeing able to run code on your machine is critical for success in this course and will allow you to take skills with you after the course\n\n","type":"content","url":"/l01-02-setup#open-notebooks-locally","position":25},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Download notebooks","lvl2":"Open Notebooks Locally"},"type":"lvl3","url":"/l01-02-setup#task-download-notebooks","position":26},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Download notebooks","lvl2":"Open Notebooks Locally"},"content":"Go to the course website and download the notebooks for the first week\n\nMove the downloaded folder from your “Downloads” folder to wherever you’d like to store materials for the semester\n\nFollow the instructions above to start Julia, load IJulia, and open the Jupyter notebook with IJulia\n\nInside your local Jupyter notebook instance (in your web browser), navigate to where you copied the “Handouts” folder and open up this notebook\n\n","type":"content","url":"/l01-02-setup#task-download-notebooks","position":27},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Open notebook in vscode","lvl2":"Open Notebooks Locally"},"type":"lvl3","url":"/l01-02-setup#task-open-notebook-in-vscode","position":28},{"hierarchy":{"lvl1":"Julia Setup","lvl3":"Task: Open notebook in vscode","lvl2":"Open Notebooks Locally"},"content":"You can also run Jupyter notebooks directly in VS Code\n\nOpen VS Code and click on the “File” menu and select “Open Folder”\n\nNavigate to where you copied the notebooks for the first week\n\nClick on the “L01.02_setup.ipynb” file in the left-hand toolbar\n\nYou should see the notebook open in VS Code\n\nYou can run cells by clicking the “Run Cell” button in the top right of each cell, or by pressing Shift + Enter while your cursor is in the cell\n\nA menu will appear, choose the option containing Julia Release\n\nTest this out below\n\n# some random Julia code\nprintln(\"That's all, folks!\")","type":"content","url":"/l01-02-setup#task-open-notebook-in-vscode","position":29},{"hierarchy":{"lvl1":"Julia Foundations"},"type":"lvl1","url":"/l01-03-julia-basics","position":0},{"hierarchy":{"lvl1":"Julia Foundations"},"content":"Computational Analysis of Social Complexity\n\nFall 2025, Spencer Lyon\n\nPrerequisites\n\nLaptop or personal computer with internet connection\n\nOutcomes\n\nUnderstand the main benefits and features of Julia\n\nSee how to define variables, functions, and types in Julia\n\nInstall commonly used packages for Graphs, DataFrames, Plotting and more\n\nReferences\n\nPackages and Software Engineering sections of QuantEcon julia lectures\n\nJulia \n\ndocumentation\n\nDocumentation for packages: \n\nGraphs, \n\nDataFrames, \n\nPlots\n\n","type":"content","url":"/l01-03-julia-basics","position":1},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"What is Julia?"},"type":"lvl2","url":"/l01-03-julia-basics#what-is-julia","position":2},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"What is Julia?"},"content":"Julia is a relatively new programming language (first public release in 2012, 1.0 release in 2018)\n\nGeneral purpose, but specializes in numerical computation\n\nLeverages advanced compiler technology to generate very efficient code\n\nIt can be as clear to read and write as Python, and as quick to evaluate as C!\n\n","type":"content","url":"/l01-03-julia-basics#what-is-julia","position":3},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Core Types"},"type":"lvl2","url":"/l01-03-julia-basics#core-types","position":4},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Core Types"},"content":"We’ll start by learning about the core datatypes built in to Julia\n\nAlong the way we’ll pick up some of the key syntax elements\n\nWe will move quickly, so some prior programming experience would be helpful\n\n","type":"content","url":"/l01-03-julia-basics#core-types","position":5},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Numbers","lvl2":"Core Types"},"type":"lvl3","url":"/l01-03-julia-basics#numbers","position":6},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Numbers","lvl2":"Core Types"},"content":"Let’s start with numbers\n\nTo work with a number, just type it!\n\n42\n\nWe can also do basic arithmetic in the way you would expect\n\n10 * 3\n\n1 + 2\n\nSo far we’ve worked with integers (whole numbers)\n\nJulia can also work with numbers containing a decimal\n\nIn Julia these are called floating point numbers\n\n1.234 ^ 2.2  # use `^` for exponentiation, not `**` like in python\n\n553.34 / 12.9\n\nWe can mix and match integers and floats\n\n25 / 2.5\n\n25 / 2  # dividing integers returns a float (notice the `.`)\n\nnotice we used # to define a comment\n\n","type":"content","url":"/l01-03-julia-basics#numbers","position":7},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Text Data"},"type":"lvl2","url":"/l01-03-julia-basics#text-data","position":8},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Text Data"},"content":"Not all data is numerical\n\nSome is textual\n\nTo represent text in Julia we use a String\n\nTo define a String we use quotation marks (\") as below\n\n\"My name is Spencer\"\n\n\"1\"  # an integer in a string\n\nYou cannot use single quotes for strings as in other languages (like Python or Javascript)\n\nGo ahead... try it by removing the # and excuting the cell below\n\n# 'hello'\n\n\"\"\"\nThis\n\nis\n\nalso\n\na\n\nstring\n\"\"\"\n\n","type":"content","url":"/l01-03-julia-basics#text-data","position":9},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Arrays"},"type":"lvl2","url":"/l01-03-julia-basics#arrays","position":10},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Arrays"},"content":"When doing numerical work, we often need to deal with multiple pieces of data at the same time\n\nIn Julia the default way of doing this is to use an array\n\nArrays are defined with [ and ] as below\n\n[1, 2, 3.14]  # a 3 element array\n\n[1 2 3]  # a 1x3 matrix\n\n[1 2; 3 4]  # a 2x2 matrix\n\n[1 2\n 3 4]  # another way to write a 2x2 matrix\n\n[1 \"hello\"; 2 \"world\"]  # a 2x2 matrix with int and string\n\n","type":"content","url":"/l01-03-julia-basics#arrays","position":11},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Accessing array items","lvl2":"Arrays"},"type":"lvl3","url":"/l01-03-julia-basics#accessing-array-items","position":12},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Accessing array items","lvl2":"Arrays"},"content":"We can use [N] to access the Nth element\n\nWe can also use [i:j] to access items i through j\n\nFinally we can use [[n1, n2]] to access the n1th and n2th elements\n\n[100, 101, 102, 103][2]\n\n[100, 101, 102, 103][2:4]\n\n[100, 101, 102, 103][[1, 3]]\n\nNote that unlike Python, Julia starts counting at 1\n\nAlso note that end can be used to refer to the last element, end-1 to second to last, and so on\n\n[1, 2, 3, 4][end]\n\n[1, 2, 3, 4][end-2]\n\n","type":"content","url":"/l01-03-julia-basics#accessing-array-items","position":13},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Tuples"},"type":"lvl2","url":"/l01-03-julia-basics#tuples","position":14},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Tuples"},"content":"There is another data type for holding “lists” of data called a tuple\n\nTuples are create using parenthesis instead of square brackets as follows\n\n(1, 2, 3, \"hello\")\n\n(\"hello\", 5)\n\n(\"hello\", 5)[2]\n\nThe main differences between tuples and arrays are\n\nTuples are meant to hold immutable or non-changing data\n\nTuples aren’t usually meant for computation or linear algebra\n\n","type":"content","url":"/l01-03-julia-basics#tuples","position":15},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Dictionary"},"type":"lvl2","url":"/l01-03-julia-basics#dictionary","position":16},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Dictionary"},"content":"Very often in programming we want to be able to associate a key or name to a specific value\n\nOne data type for doing that is a Dict\n\nDicts are created with the somewhat inconvenient syntax Dict(name => value, ...) where the ... means we can repeat the pattern multiple times\n\nThey keys and values can be of any type\n\nDict(\"x\" => 1, 2 => \"y\", [\"w\", \"z\"] => [1, 2, 3])\n\n# use `[name]` to access element with `name`\nDict(\"x\" => 1, 2 => \"y\", [\"w\", \"z\"] => [1, 2, 3])[2]\n\nDict(\"x\" => 1, \"y\" =>2)\n\nDictionaries are often used for passing around groups of parameters\n\nWe’ll see examples later on\n\n","type":"content","url":"/l01-03-julia-basics#dictionary","position":17},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Named Tuples"},"type":"lvl2","url":"/l01-03-julia-basics#named-tuples","position":18},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Named Tuples"},"content":"The final “collection” we’ll talk about is the named tuple\n\nIt is a hybrid between a tuple and a dictionary\n\nTo create them we use the synax (name = value, ...)\n\nThey names or keys need to be just names (not numbers or arrays). The values can be anything\n\n(x = 1, y = 2, z=\"hello\")\n\n(x = 1, y = 2, z=\"hello\").z # use `.name` to access item\n\nNamed tuples are a newer feature of Julia\n\nThey are often used for the same purpsoes as dictionaries because the syntax is much cleaner\n\n","type":"content","url":"/l01-03-julia-basics#named-tuples","position":19},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Variables"},"type":"lvl2","url":"/l01-03-julia-basics#variables","position":20},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Variables"},"content":"Often when programming, we need to refer to the same piece of data more than once\n\nTo do this we use a variable\n\nVariables are defined using an =, as in name = value\n\nx = 1\n\ny = 42\n\nx + y  # 'use' or 'refer to' x and y\n\nm1 = [1 0; 0 1]\n\nm2 = [1 2; 3 4]\n\nm1 * m2  # matrix multiplication\n\nm2 * m2  # again -- but with something besides identity matrix!\n\nd = Dict(\"X\" => 1, \"Y\" => 2)\n\nd[\"X\"]\n\n","type":"content","url":"/l01-03-julia-basics#variables","position":21},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Functions"},"type":"lvl2","url":"/l01-03-julia-basics#functions","position":22},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Functions"},"content":"Most Julia programs do more than basic arithmetic operations on data\n\nTo apply an operation to a piece of data, we call a function\n\nTo call a function we use the function_name(data1, data2)\n\nA very handy function is the typeof function\n\ntypeof(1)\n\ntypeof(2.0)\n\ntypeof([1,2,3])\n\ntypeof([1 2; 3 4.0])\n\nMany standard operations are built in to Julia as functions\n\nsum([1, 2, 3])  # compute sum of array of numbers\n\ninv([1 2; 3 4])  # matrix inverse\n\nsize([1 2; 3 4])  # number of (rows, columns)  in matrix\n\nlength([1, 2, 3])  # number of elements in array\n\nlength([1 2; 3 4])  # returns total number of elements in a Matrix\n\nrand(2, 2, 2)  # a 2x2x2 array of random numbers, sampled from uniform[0,1] dist\n\nJulia has 1000s of functions\n\nWe’ll learn more as we go along...\n\nJust watch for the pattern with parentisis: name(args)\n\n","type":"content","url":"/l01-03-julia-basics#functions","position":23},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Defining Functions","lvl2":"Functions"},"type":"lvl3","url":"/l01-03-julia-basics#defining-functions","position":24},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Defining Functions","lvl2":"Functions"},"content":"Functions are used to execute a predefined set of operations\n\nDefining our own funcitons allows us to break programs into small, easily written an understood components\n\nWe define functions using the syntaxfunction name(arg1, arg2)\n    # steps\nend\n\nfunction mean(x)\n    total = sum(x)\n    N = length(x)\n    total / N\nend\n\nmean([1, 2, 3])\n\n# mean of 1000 random samples from U[0,1] -- should be ~ 0.5\nmean(rand(1000))\n\nIf a function only contains one line of code, you can also use a shorthand notation:function_name(arg1, arg2) = # step\n\nadd_two(x) = x + 2\n\nadd_two(40)\n\n","type":"content","url":"/l01-03-julia-basics#defining-functions","position":25},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Getting help for functions"},"type":"lvl2","url":"/l01-03-julia-basics#getting-help-for-functions","position":26},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Getting help for functions"},"content":"Given that there are so many functions, sometimes it is hard to remember exactly what a function does\n\nThankfully we can get help from Julia\n\nIf we type ?function_name, Julia will present us with documentation about the function\n\n?map\n\n?extrema\n\n","type":"content","url":"/l01-03-julia-basics#getting-help-for-functions","position":27},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Control Flow"},"type":"lvl2","url":"/l01-03-julia-basics#control-flow","position":28},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Control Flow"},"content":"Julia has the basic elements of control flow:\n\nif-else statements\n\nfor loops\n\nif 1 > 2 # no parenthesis needed\n    println(\"what???\")\nelse     # else is optional\n    return mean([1, 2, 3])\n    print(\"phew\")\nend      # all \"blocks\" terminate with word `end`\n\nfor i in 1:5 # range of numbers 1 to 5\n    println(i, \" \", i^2)\nend\n\nWe will see many more examples as we go forward\n\n","type":"content","url":"/l01-03-julia-basics#control-flow","position":29},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Packages"},"type":"lvl2","url":"/l01-03-julia-basics#packages","position":30},{"hierarchy":{"lvl1":"Julia Foundations","lvl2":"Packages"},"content":"Julia comes ready to go with many powerful functions and data types\n\nHowever, there is a very active community of Julia programmers who are experts in different subfields of science and engineering\n\nThis has led to the development of vibrant and exciting ecosystem of packages or toolboxes for performing specific tasks\n\nWe can access these routines by using Julia packages\n\n","type":"content","url":"/l01-03-julia-basics#packages","position":31},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Loading packages","lvl2":"Packages"},"type":"lvl3","url":"/l01-03-julia-basics#loading-packages","position":32},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Loading packages","lvl2":"Packages"},"content":"By default Julia ships with a “standard library”\n\nThese are packages that come bundled with Julia itself and are pre-installed\n\nTo load a package and all of its types/functions use the using keyword\n\nFor example, we can load the Dates package and start using it\n\nusing Dates\n\nt1 = Dates.now()\n\nDates.format(t1, \"yyyy-mm-dd\")\n\nt2 = Dates.now()\n\nt2 > t1\n\nt3 = DateTime(1776, 7, 4)\n\n\"America is $(t1 - t3) ($(floor(t1 - t3, Dates.Day))) old\"\n\n","type":"content","url":"/l01-03-julia-basics#loading-packages","position":33},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Installing Packages","lvl2":"Packages"},"type":"lvl3","url":"/l01-03-julia-basics#installing-packages","position":34},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Installing Packages","lvl2":"Packages"},"content":"In addition to the standard library, we can also use packages created by other Julia users\n\nTo use a 3rd party package, we first need to install it\n\nThere are two ways to do this\n\n1]add PackageName\n\n2using Pkg  # a standard library package\nPkg.add(\"PackageName\")\n\nLet’s try them both\n\n]add Plots\n\nusing Pkg\nPkg.add(\"DataFrames\")\n\nAfter installing packages, we can load and use them just as we did the standard library packages\n\nusing Plots  # Python: from Plots import *\n\nplot([sin, cos], -2pi, 2pi)\n\nusing DataFrames\ndf = DataFrame(c1=1:10, c2=(1:10).^2)\n\n","type":"content","url":"/l01-03-julia-basics#installing-packages","position":35},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Package Composability","lvl2":"Packages"},"type":"lvl3","url":"/l01-03-julia-basics#package-composability","position":36},{"hierarchy":{"lvl1":"Julia Foundations","lvl3":"Package Composability","lvl2":"Packages"},"content":"One unique feature sof Julia is that most of the language itself, in addition to packages, are written in Julia\n\nFor other languages like Python or R the “built in” part of the language is often written in another language like C\n\nThis difference has a large impact for Julia users\n\nBuilt in code and user code (including packages) are given the same “treatment”\n\nAnything the language creators can do, so can you\n\nA practical implication of this is that packages can operate on built in types (like we saw in our examples above) as well as types from other packages\n\nLet’s see what this looks like by plotting a DataFrame\n\n# install \"StatsPlots\", which links Plots and DataFrames\nPkg.add(\"StatsPlots\")\n\nusing StatsPlots\n\n@df df scatter(:c1, :c2)\n\nPkg.add(\"RDatasets\") # common datasets from R programming language\nusing RDatasets\nschool = RDatasets.dataset(\"mlmRev\",\"Hsb82\")\n@df school density(:MAch, group = :Sx)\n\n@df school density(:MAch, group = (:Sx, :Sector))","type":"content","url":"/l01-03-julia-basics#package-composability","position":37},{"hierarchy":{"lvl1":"Julia Types and Methods"},"type":"lvl1","url":"/l02-01-julia-types-methods","position":0},{"hierarchy":{"lvl1":"Julia Types and Methods"},"content":"Computational Analysis of Social Complexity\n\nFall 2025, Spencer Lyon\n\nPrerequisites\n\nLaptop or personal computer with internet connection\n\nJulia intro lecture\n\nOutcomes\n\nUnderstand key components of Julia’s type system: abstract types, primitive types, composite types, and parametric types\n\nBe able to define our own custom types to hold data\n\nUnderstand the concept of multiple dispatch\n\nBe able to leverage the mulitple dispatch system to define custom behavior for built-in and custom types\n\nReferences\n\nLecture notes\n\nJulia documentation on \n\ntypes and \n\nmethods (these are technical, but comprehensive and well-written)\n\nQuantEcon lectures on \n\ntypes and generic programming\n\n","type":"content","url":"/l02-01-julia-types-methods","position":1},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl2":"Types in Julia"},"type":"lvl2","url":"/l02-01-julia-types-methods#types-in-julia","position":2},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl2":"Types in Julia"},"content":"Julia is both very expressive and runtime efficient\n\nThis is made possible because of the underlying compiler technology\n\nThe main strategy for user interaction with the compiler is by defining custom types and methods that operate on those types\n\nTypes and multiple dispatch go hand in hand and are key to effective Julia\n\n","type":"content","url":"/l02-01-julia-types-methods#types-in-julia","position":3},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"What is a type?","lvl2":"Types in Julia"},"type":"lvl3","url":"/l02-01-julia-types-methods#what-is-a-type","position":4},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"What is a type?","lvl2":"Types in Julia"},"content":"Each piece of data in a program resides in memory (RAM) on the host computer\n\nWe often assign names to data, which we call variables (in x = \"hello\", x is a variable)\n\nAt its most basic level, a variable is composed of\n\nAn arrangment of 0’s and 1’s called bits\n\nAn address to where in memory the data is recorded\n\nA Symbol representing the name we gave the data\n\nA type in Julia represents what kind of object is represented at a certain memory address\n\nJulia uses this type information to enable syntax (e.g. the $ in a string to interpolate or the . access for an objects fields) and ultimiately decide what behaviors are defined to operate on the data\n\n","type":"content","url":"/l02-01-julia-types-methods#what-is-a-type","position":5},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Organizing types","lvl2":"Types in Julia"},"type":"lvl3","url":"/l02-01-julia-types-methods#organizing-types","position":6},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Organizing types","lvl2":"Types in Julia"},"content":"In Julia types are organized into a hierarchy\n\nAt the top of the hierarcy is Any -- all objects are instances of Any\n\nAt the bottom of the hierarchy is Union{} -- no objects are instances of Union{}\n\nIn between these endpoints we have a rich family of types\n\nEach type can have at most one parent type (if not specified, default parent is Any)\n\nTypes can actually come in a few different flavors...\n\n","type":"content","url":"/l02-01-julia-types-methods#organizing-types","position":7},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Types of Types","lvl2":"Types in Julia"},"type":"lvl3","url":"/l02-01-julia-types-methods#types-of-types","position":8},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Types of Types","lvl2":"Types in Julia"},"content":"Abstract Types: cannot be created directly, but serve as nodes in a type hierarchy. Help us organize types into families and provide shared behavior for all members of the family\n\nPrimitive types: provided to us by Julia and represent a collection of bits (e.g. Float64, Bool, and Int8). We could create them, but we won’t. We won’t say anything else about them here\n\nComposite Types: types that contain additional data called fields. An instance can be treated as a single value. This is what we typically define and use\n\nNOTE: all objects in Julia are instances of either primitive or composite types, and can be related to one another by sharing common abstract type ancestors\n\n","type":"content","url":"/l02-01-julia-types-methods#types-of-types","position":9},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl2":"Abstract Types"},"type":"lvl2","url":"/l02-01-julia-types-methods#abstract-types","position":10},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl2":"Abstract Types"},"content":"Abstract types help organize composite types into families\n\nFor example, the number system in Julia looks like this (really -- look \n\nhere)abstract type Number end\nabstract type Real     <: Number end\nabstract type AbstractFloat <: Real end\nabstract type Integer  <: Real end\nabstract type Signed   <: Integer end\nabstract type Unsigned <: Integer end\n\nNote:\n\nNumber’s parent type is Any\n\nReal is a special kind of Number and can be broken into two subgroups: AbstractFloat and Integer\n\n","type":"content","url":"/l02-01-julia-types-methods#abstract-types","position":11},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Why Abstract Types?","lvl2":"Abstract Types"},"type":"lvl3","url":"/l02-01-julia-types-methods#why-abstract-types","position":12},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Why Abstract Types?","lvl2":"Abstract Types"},"content":"We said before we can’t create an instance of abstract types...\n\nSo, why do we have them?\n\nThe primary reason to have abstract types is to introduced shared functionality via methods defined on the abstract type\n\nExample: suppose you needed to define a function isint to determine if an object is an integer\n\nWithout abstract types, you could have a long sequence of checks for if a variable is any integer type:\n\nfunction isint1(x)\n\tfor T in [\n\t\tInt8, UInt8, Int16, UInt16, \n\t\tInt32, UInt32, Int64, UInt64, \n\t\tInt128, UInt128\n\t]\n\t\tif isa(x, T)\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend\n\nisint1(10), isint1(\"Hello\")\n\nWith abstract types we can define two methods:\n\nisint(x) = false\nisint(x::Integer) = true\n\nisint(10), isint(\"Hello\")\n\nThis has many benefits\n\nMuch simpler to write/reason about\n\nMore “fool proof”: what if we forgot one of the “UIntXX” types?\n\nMore “future proof”: what if a new type of integer gets introduced (e.g. UInt256 like is widely used in blockchain data!)\n\nPushes work into the compiler:\n\n@code_lowered isint1(\"hello\")\n\n@code_lowered isint1(UInt128(12341234123423134))\n\n@code_lowered isint(\"hello\") \n\n@code_lowered isint(UInt128(12341234123423134))\n\n","type":"content","url":"/l02-01-julia-types-methods#why-abstract-types","position":13},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl2":"Composite Types"},"type":"lvl2","url":"/l02-01-julia-types-methods#composite-types","position":14},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl2":"Composite Types"},"content":"Abstract types are very useful when used in conjunction with multiple dispatch (defining multiple methods of function with same name, but varying code depending on argument types)\n\nHowever, most often we create types to hold collections of related data together\n\nWe do this using composite types\n\nA composite type can be created as follows:struct Name <: AbstractParentType\n    field1::Field1Type\n\t# more fields\nend\n\nNote that the <: AbstractParentType is optional, as are types on all fields\n\n","type":"content","url":"/l02-01-julia-types-methods#composite-types","position":15},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Composite Types: Examples","lvl2":"Composite Types"},"type":"lvl3","url":"/l02-01-julia-types-methods#composite-types-examples","position":16},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Composite Types: Examples","lvl2":"Composite Types"},"content":"\n\nstruct Foo\n   bar\n   baz::Int\n   qux::Float64\nend\n\nfoo = Foo(\"Hello, world.\", 23, 1.5)\n\ntypeof(foo)\n\n# this will not work. Uncomment and try it out\n# Foo((), 23.5, 1)\n\nfieldnames(Foo)\n\nfoo.bar\n\nfoo.baz\n\nfoo.qux\n\n","type":"content","url":"/l02-01-julia-types-methods#composite-types-examples","position":17},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Composite Types and Dispatch","lvl2":"Composite Types"},"type":"lvl3","url":"/l02-01-julia-types-methods#composite-types-and-dispatch","position":18},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Composite Types and Dispatch","lvl2":"Composite Types"},"content":"Above we saw an example of defining multiple methods of isint, using an abstract type to route dispatch\n\nWe can also use composite types\n\nisint(x::Foo) = isint(x.bar)\n\nisint(10), isint(1.0), isint(UInt128(234901324987213)), isint(Foo(\"not an int\", 12, 1.0))\n\n@code_lowered isint(Foo(\"not an int\", 12, 1.0))\n\n@code_lowered isint(UInt128(12341234123423134))\n\nisint(foo)\n\nfoo, isint(foo)\n\nisint(Foo(1, 23, 1.5))\n\n","type":"content","url":"/l02-01-julia-types-methods#composite-types-and-dispatch","position":19},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Exercises","lvl2":"Composite Types"},"type":"lvl3","url":"/l02-01-julia-types-methods#exercises","position":20},{"hierarchy":{"lvl1":"Julia Types and Methods","lvl3":"Exercises","lvl2":"Composite Types"},"content":"Create an abstract type called Person\n\nCreate two composite subtypes of Person called Friend and Foe\n\nEach of these should have fields name and height_inches\n\nFor friend you should also have a field favorite_color\n\nMAKE SURE TO ADD TYPES FOR ALL FIELDS\n\nCreate a third composite subtype of Person called Stranger, but without any fields\n\nSuppose we are trying to decide who to invite to a dinner party. Our rule is that friends should get a definite yes. Enemies a definite no. Strangers a 50%/50% toss up. However, if our spouse says we should invite a person, the answer is always yes\n\nCreate a function should_invite_to_party that implements that logic\n\nHINT: you will need 4 methods. 3 of these have only one argument, the 4th has two\n\nIn the cell at the bottom we have written a test case. You will know you’ve done this correctly when all the tests pass\n\n# Your code here\n\nusing Test\n\nfunction tests()\n\t@testset \"people\" begin\n\t\n\t\t@test fieldnames(Friend) == (:name, :height_inches, :favorite_color)\n\t\t@test fieldnames(Foe) == (:name, :height_inches)\n\t\t@test fieldnames(Stranger) == tuple()\n\n\t\tjim = Friend(\"Jim\", 64, \"blue\")\n\t\tdwight = Foe(\"Dwight\", 61)\n\t\tcreed = Stranger()\n\n\t\t@test jim isa Person\n\t\t@test dwight isa Person\n\t\t@test creed isa Person\n\n\t\t@test should_invite_to_party(jim) \n\t\t@test !should_invite_to_party(dwight)\n\t\t@test should_invite_to_party(dwight, true)\n\t\t\n\t\tcreed_invites = map(i->should_invite_to_party(creed), 1:100)\n\t\t@test any(creed_invites)\n\t\t@test any(map(!, creed_invites))\n\n\t\tcreed_invites_spouse = map(i->should_invite_to_party(creed, true), 1:100)\n\t\t@test all(creed_invites_spouse)\t\n\tend\nend\n\n# uncomment and run this cell when you are ready to test your code\ntests()","type":"content","url":"/l02-01-julia-types-methods#exercises","position":21},{"hierarchy":{"lvl1":"Julia Code Organization"},"type":"lvl1","url":"/l02-02-code-organization","position":0},{"hierarchy":{"lvl1":"Julia Code Organization"},"content":"Computational Analysis of Social Complexity\n\nFall 2025, Spencer Lyon\n\nPrerequisites\n\nLaptop or personal computer with internet connection\n\nJulia intro lecture\n\nOutcomes\n\nCreating julia modules\n\nImporting Julia source fode files with the include function\n\nExporting types and functions to create\n\nReferences\n\nLecture notes\n\nJulia documentation on \n\nmodules\n\n","type":"content","url":"/l02-02-code-organization","position":1},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":"Introduction"},"type":"lvl2","url":"/l02-02-code-organization#introduction","position":2},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":"Introduction"},"content":"Julia can be succesfully used for exploratory analysis and one-off scripts\n\nAs projects grow, it is often useful to add structure and organization to the code\n\nIn Julia, the main building blocks for code organization and re-use include\n\nTypes/structs\n\nFunctions/methods\n\n.jl source code files\n\nModules\n\nPackages\n\nIn this not we’ll learn how to manage .jl files and Modules\n\nWe’ll pick up with Packages in another lecture\n\n","type":"content","url":"/l02-02-code-organization#introduction","position":3},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":".jl files"},"type":"lvl2","url":"/l02-02-code-organization#id-jl-files","position":4},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":".jl files"},"content":"Julia source code typically lives in a plain text file with a .jl extension\n\nWhile the extension is optional and not enforced by the Julia REPL or runtime, it is a strong convention followed by the community and by 3rd party tools like code editors and GitHub\n\nSuppose we have the following code for simulating Markov Chains in Julia\n\n# Markov Chain code\n\nstruct MarkovChain{T}\n    P::Matrix{Float64}\n    initial_state::Vector{Float64}\n    state_values::Vector{T}\n\n    P_dists::Vector{Vector{Float64}}\nend\n\nfunction MarkovChain(P::Matrix{Float64}, initial_state::Vector{Float64}, state_values::Vector{T}) where T\n    P_dists = [cumsum(row) for row in eachrow(P)]\n    return MarkovChain{T}(P, initial_state, state_values, P_dists)\nend\n\nfunction simulate_indices(mc::MarkovChain, n_steps::Int)\n    init_dist = cumsum(mc.initial_state)\n    states = Vector{Int}(undef, n_steps)\n    states[1] = searchsortedfirst(init_dist, rand())\n    for i in 2:n_steps\n        states[i] = searchsortedfirst(mc.P_dists[states[i-1]], rand())\n    end\n    return states\nend\n\nfunction simulate_values(mc::MarkovChain{T}, n_steps::Int)::Vector{T} where T\n    states = simulate_indices(mc, n_steps)\n    return mc.state_values[states]\nend\n\nP1 = [0.5 0.5; 0.5 0.5]\nmc1 = MarkovChain(P1, [1.0, 0.0], [\"A\", \"B\"])\n\ntypeof(mc1)\n\nmc1.P_dists\n\ninds = simulate_indices(mc1, 10)\n\nvals = simulate_values(mc1, 10)\nvals\n\nAs you can see, we can use this code from inside a Jupyter notebook by running the defining cell and then calling the routines\n\nHowever, what if we wanted to reuse the code for another notebook\n\nWe have two options:\n\nCopy/paste it to the new notebook\n\nStore the code in a .jl file and import it from both places\n\nLet’s pick the latter\n\n","type":"content","url":"/l02-02-code-organization#id-jl-files","position":5},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":"include"},"type":"lvl2","url":"/l02-02-code-organization#include","position":6},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":"include"},"content":"I have created markov.jl with that code:\n\nprintln(String(read(\"markov.jl\")))\n\nTo make use of this code in julia I can run include(\"markov.jl\")\n\nYou can think of the include function as copy/pasting AND evaluating the code from a file in whatever setting you are in\n\ninclude(\"markov.jl\")\n\nNotice that in the markov.jl file I added two extra functions (rand and stationary_ditributions)\n\nWe can verify that these were defined for us when we ran include by calling them:\n\nrand(mc1, 4)\n\nstationary_distributions(mc1)\n\n","type":"content","url":"/l02-02-code-organization#include","position":7},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":"Modules"},"type":"lvl2","url":"/l02-02-code-organization#modules","position":8},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":"Modules"},"content":"Being able to define code in a .jl file and load it in a notebook (or other .jl file!) is already a huge win for organization and reusability\n\nBut we can do better!\n\nOne issue with our approach here is that all types, functions, and methods we define in our included files will become part of our working Julia session.\n\nThis is not always wanted\n\nSuppose instead we really only wanted to make the MarkovChain, rand, and stationary_distributions code part of our session when loading our file\n\nTo do this, we will need to organize our code into a Module\n\nTo create module we use the syntaxmodule NAME\n\n# code here\n\nend\n\nHere we use the module keyword, followed by the name of the module\n\nBetween the module name and end we insert any code we want to include in the module\n\nBy convention, the contents of a module are not indented (this is a rare exception to indenting code that comes before end)\n\nI’ve created a module for our Markov chain code in module.jl:\n\nprintln(String(read(\"module.jl\")))\n\nNotice a few things:\n\nI used the export keyword to list types/functions I want to be added to the caller’s namespace when someone runs using Markov\n\nI used include to add the actual source code in the module\n\nThis is a very common pattern in Julia and is one we will see throughout our course\n\n","type":"content","url":"/l02-02-code-organization#modules","position":9},{"hierarchy":{"lvl1":"Julia Code Organization","lvl3":"Using Modules","lvl2":"Modules"},"type":"lvl3","url":"/l02-02-code-organization#using-modules","position":10},{"hierarchy":{"lvl1":"Julia Code Organization","lvl3":"Using Modules","lvl2":"Modules"},"content":"To use a module we first have to evaluate the code defining it\n\nTo do that we can include(\"module.jl\")\n\nWarning\n\nI restarted my kernel here!!!!\n\ninclude(\"module.jl\")\n\n\nNotice the printout shows that we now have a Main.Markov object\n\nNOTE: Main is the name of the default module the user executed code is evaluated in to\n\nWe can now access Markov.<NAME> where <NAME> is any type or function in the module\n\nP2 = [0.2 0.8; 0.5 0.5]\nmc2 = Markov.MarkovChain(P2, [1.0, 0.0], [10, 20])\n\nMarkov.rand(mc2, 2)\n\nNotice that I had to use Markov. to access members of the module\n\nNow taht the module is defined I can call using Markov to make it possible to use any exported function without the Markov. prefix\n\nusing Main.Markov\nstationary_distributions(mc2)\n\n","type":"content","url":"/l02-02-code-organization#using-modules","position":11},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":"Exercise"},"type":"lvl2","url":"/l02-02-code-organization#exercise","position":12},{"hierarchy":{"lvl1":"Julia Code Organization","lvl2":"Exercise"},"content":"Now it is your turn\n\nLet’s create a module for working with geometric shapes\n\nCreate two new .jl files\n\nOne called shapes.jl: here define the following:\n\nAn abstract type Shape2D\n\nConcrete types Circle, Rectangle, and Triangle that are subtypes of Shape2D\n\nMethods for area and perimeter for each shape type\n\nA function is_inside(shape, x, y) that checks if a point (x, y) is inside the shape\n\nOne called GeometricShapes.jl: here wrap the code from shapes.jl in a module named GeometricShapes\n\nExport the types: Shape2D, Circle, Rectangle, Triangle\n\nExport the functions: area, perimeter, is_inside\n\ninclude your new module and test it by:\n\nCreating instances of each shape\n\nComputing their areas and perimeters\n\nTesting if various points are inside or outside the shapes","type":"content","url":"/l02-02-code-organization#exercise","position":13},{"hierarchy":{"lvl1":"Julia Package Development"},"type":"lvl1","url":"/l02-03-julia-packages","position":0},{"hierarchy":{"lvl1":"Julia Package Development"},"content":"Computational Analysis of Social Complexity\n\nFall 2025, Spencer Lyon\n\nPrerequisites\n\nLaptop or personal computer with internet connection\n\nJulia intro lecture\n\nJulia Modules lecture\n\nOutcomes\n\nInstalling, uninstalling, and updating packages\n\nManaging a Project.toml file and understanding the related Manifest.toml\n\nCreate new Julia packages to organize code snippets\n\nReferences\n\nLecture notes\n\nJulia documentation on \n\npackages\n\nPkg.jl standard library \n\ndocs\n\n","type":"content","url":"/l02-03-julia-packages","position":1},{"hierarchy":{"lvl1":"Julia Package Development","lvl2":"Introduction"},"type":"lvl2","url":"/l02-03-julia-packages#introduction","position":2},{"hierarchy":{"lvl1":"Julia Package Development","lvl2":"Introduction"},"content":"Julia is a very powerful, modern language\n\nIt comes packed with many essential components for creating high performing numerical programs\n\nArrays\n\nParallel processing\n\nMulti threading\n\nCalling C code\n\n... and many more\n\nHowever, Julia also has a thriving 3rd party library ecosystem (\n\nML, \n\nPlotting, \n\nNotebooks, \n\nDifferential Equations, and more)\n\nJulia libraries are known as packages\n\nToday we will learn how to manage and develop packages\n\n","type":"content","url":"/l02-03-julia-packages#introduction","position":3},{"hierarchy":{"lvl1":"Julia Package Development","lvl2":"Package Management"},"type":"lvl2","url":"/l02-03-julia-packages#package-management","position":4},{"hierarchy":{"lvl1":"Julia Package Development","lvl2":"Package Management"},"content":"To start, let’s learn how to manage Julia packages\n\nThere are two primary methods for managing packages:\n\nImporting and calling functions from the Pkg standard library package\n\nUsing the pkg REPL mode from the main Julia REPL\n\nWe will learn both here\n\nFirst, we’ll import the Pkg package\n\nNote\n\nExamples of the pkg REPL mode will be pasted here for you to view\n\nimport Pkg\n\n","type":"content","url":"/l02-03-julia-packages#package-management","position":5},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Installing","lvl2":"Package Management"},"type":"lvl3","url":"/l02-03-julia-packages#installing","position":6},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Installing","lvl2":"Package Management"},"content":"To install a package use Pkg.add(\"PACKAGE_NAME\")\n\nBelow we install the popular CSV package used for handling CSV files in Julia\n\nPkg.add(\"CSV\")\n\nTo use the pkg REPL mode, I first start the repl by running julia in my terminal\n\nThen I press ] to enter Pkg mode\n\nREPL prompt chanegs to (@v1.11) pkg> (where v1.11 represents my Julia system version)\n\nOnce here I run add CSV to get the following output:(@v1.11) pkg> add CSV\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.11/Project.toml`\n  [336ed68f] + CSV v0.10.15\n    Updating `~/.julia/environments/v1.11/Manifest.toml`\n  [336ed68f] + CSV v0.10.15\n  [944b1d66] + CodecZlib v0.7.8\n  [34da2185] + Compat v4.18.0\n  [9a962f9c] + DataAPI v1.16.0\n  [e2d170a0] + DataValueInterfaces v1.0.0\n  [48062228] + FilePathsBase v0.9.24\n  [842dd82b] + InlineStrings v1.4.4\n  [82899510] + IteratorInterfaceExtensions v1.0.0\n  [bac558e1] + OrderedCollections v1.8.1\n  [2dfb63ee] + PooledArrays v1.4.3\n  [91c51154] + SentinelArrays v1.4.8\n  [3783bdb8] + TableTraits v1.0.1\n  [bd369af6] + Tables v1.12.1\n  [3bb67fe8] + TranscodingStreams v0.11.3\n  [ea10d353] + WeakRefStrings v1.4.2\n  [76eceee3] + WorkerUtilities v1.6.1\n  [9fa8497b] + Future v1.11.0\n\n","type":"content","url":"/l02-03-julia-packages#installing","position":7},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Checking Status","lvl2":"Package Management"},"type":"lvl3","url":"/l02-03-julia-packages#checking-status","position":8},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Checking Status","lvl2":"Package Management"},"content":"To check the status of my packages, I can use the Pkg.status function  or status command at the pkg REPL\n\nPkg.status()\n\n(@v1.11) pkg> status\nStatus `~/.julia/environments/v1.11/Project.toml`\n  [336ed68f] CSV v0.10.15\n⌃ [7073ff75] IJulia v1.29.2\nInfo Packages marked with ⌃ have new versions available and may be upgradable.\n\nThe printout here will show one line per explicity installed package (not transitive dependencies)\n\nThe format of each line is _ [ID] NAME VERSION where\n\nID is the beginning of a universially unique identifier (UUID) that identifies the package in the Julia ecosystem\n\nNAME is the name of the package\n\nVERSION is the installed version number\n\n_ is a placeholder for possible version updates. These placeholders will be explained beneath the list of packages\n\n","type":"content","url":"/l02-03-julia-packages#checking-status","position":9},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Updating","lvl2":"Package Management"},"type":"lvl3","url":"/l02-03-julia-packages#updating","position":10},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Updating","lvl2":"Package Management"},"content":"Notice how our printout shows we have version v1.29.2 of IJulia, but that there is an update available\n\nTo update to the latest verison (reccomended for security and features) we use the Pkg.udpate function or up REPL command\n\nIf we run pkg> up, Julia will attempt to get the latest version of all installed packages (same for Pkg.update())\n\nIf instead we do pkg> up IJulia, Julia will only update IJulia (same for Pkg.update(\"IJulia\"))\n\n(@v1.11) pkg> up IJulia\n    Updating registry at `~/.julia/registries/General.toml`\n    Updating `~/.julia/environments/v1.11/Project.toml`\n  [7073ff75] ↑ IJulia v1.29.2 ⇒ v1.30.0\n    Updating `~/.julia/environments/v1.11/Manifest.toml`\n  [7073ff75] ↑ IJulia v1.29.2 ⇒ v1.30.0\n  [b85f4697] - SoftGlobalScope v1.1.0\n\nNow running status does not show that IJulia has a newer available version\n\nPkg.status()\n\n","type":"content","url":"/l02-03-julia-packages#updating","position":11},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Uninstalling","lvl2":"Package Management"},"type":"lvl3","url":"/l02-03-julia-packages#uninstalling","position":12},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Uninstalling","lvl2":"Package Management"},"content":"To uninstall a package we can use the Pkg.rm(\"NAME\") functino or pkg> rm NAME REPL command:|\n\nPkg.rm(\"CSV\")\n\nStatus now shows we no longer have CSV\n\nPkg.status()\n\n","type":"content","url":"/l02-03-julia-packages#uninstalling","position":13},{"hierarchy":{"lvl1":"Julia Package Development","lvl2":"Environments"},"type":"lvl2","url":"/l02-03-julia-packages#environments","position":14},{"hierarchy":{"lvl1":"Julia Package Development","lvl2":"Environments"},"content":"Notice above when managing packages, I always saw the following at the top of the file:   Resolving package versions...\n    Updating `~/.julia/environments/v1.11/Project.toml`\n\nThis was a hint to how Julia keeps its packages organized...\n\nWhenever we are working in Julia, there is always an environment active\n\nBy default, the environment is specific to the user account (~/ is UNIX shorthand for current user’s home directory) and the Julia version number (v1.11)\n\nThis means that all packages we install will be available any time someone starts Julia v1.11 from my user account\n\n","type":"content","url":"/l02-03-julia-packages#environments","position":15},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Environment Management","lvl2":"Environments"},"type":"lvl3","url":"/l02-03-julia-packages#environment-management","position":16},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Environment Management","lvl2":"Environments"},"content":"Having a single, global environment is very convenient for simple tasks and exploration\n\nHowever, for larger software or research projects, it is a best practice to have an environment specific for that project\n\nThe Julia package manager has built in support for managing isolated sets of packages in named environments\n\n","type":"content","url":"/l02-03-julia-packages#environment-management","position":17},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Activate","lvl2":"Environments"},"type":"lvl3","url":"/l02-03-julia-packages#activate","position":18},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Activate","lvl2":"Environments"},"content":"To create an environment, start Julia within the folder for the project (use pwd()) to check your folder\n\nThen run Pkg.activate(\".\") or pkg> activate . to create a new project, or activate an existing project specific to the current folder\n\nWhen you run this command, no files will have been changed, but checking status will show you are in a different environment\n\nPkg.activate(\".\")\n\nPkg.status()\n\n","type":"content","url":"/l02-03-julia-packages#activate","position":19},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Manage Packages","lvl2":"Environments"},"type":"lvl3","url":"/l02-03-julia-packages#manage-packages","position":20},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Manage Packages","lvl2":"Environments"},"content":"Now that we have a new environment activated, we can install packages specific to this project\n\nPkg.add([\"VegaLite\", \"VegaDatasets\"])\n\nPkg.status()\n\nNote two things:\n\nWe can now use the packages\n\nThe Pkg.add command had this line in the printout: Updating ~/Teaching/UCF/CAP-6318/book-myst/week02/Project.toml\n\nWe’ll demonstrate we can use the packages below, then we’ll dig into the Project.toml\n\nusing VegaLite, VegaDatasets\n\ndataset(\"cars\") |>\n@vlplot(\n    :point,\n    x=:Horsepower,\n    y=:Miles_per_Gallon,\n    color=:Origin,\n    width=400,\n    height=400\n)\n\n","type":"content","url":"/l02-03-julia-packages#manage-packages","position":21},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Package.toml","lvl2":"Environments"},"type":"lvl3","url":"/l02-03-julia-packages#package-toml","position":22},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Package.toml","lvl2":"Environments"},"content":"Julia environments are managed and described using in a format called TOML (Tom’s obvious markup language) in a file Project.toml\n\nThis file will be created and updated as needed by Pkg as we run Pkg commands\n\nLet’s see what our new Project.toml looks like:\n\nprintln(String(read(\"Project.toml\")))\n\nThis shows us we have a [deps] section with entries for the three packages we installed\n\nEach package line has the NAME = UUID syntax\n\nThere can be other top level items (not in a section) and other sections\n\nWe’ll discuss these as they come up\n\n","type":"content","url":"/l02-03-julia-packages#package-toml","position":23},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Manifest.toml","lvl2":"Environments"},"type":"lvl3","url":"/l02-03-julia-packages#manifest-toml","position":24},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Manifest.toml","lvl2":"Environments"},"content":"Notice that the Project.toml file does not have any information about the version of our installed packages\n\nThere is a companion file called Manifest.toml that does have this information\n\nLet’s take a look:\n\nprintln(String(read(\"Manifest.toml\")))\n\nThe Manifest.toml file is a very comprehensive overview of ALL details about a Julia environment\n\nThis file is rarely (if ever) touched by humans\n\nIt can be used to reproduce an exact replica of the Julia version, packages, and package versions on any machine\n\n","type":"content","url":"/l02-03-julia-packages#manifest-toml","position":25},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Set up environment on new machine","lvl2":"Environments"},"type":"lvl3","url":"/l02-03-julia-packages#set-up-environment-on-new-machine","position":26},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Set up environment on new machine","lvl2":"Environments"},"content":"If you are given a Project.toml/Manifest.toml combo, you can easily create a duplicate of teh author’s Julia environment\n\nTo do this follow these two steps:\n\nCall Pkg.activate(\".\")  (or pkg> activate) from the directory containing the .toml files\n\nCall Pkg.instantiate() (or pkg> instantiate)\n\nThis will first activate the Project’s environment in your current Julia session and then install all dependencies\n\nusing Pkg\nPkg.activate(\".\")\nPkg.instantiate()\n\n","type":"content","url":"/l02-03-julia-packages#set-up-environment-on-new-machine","position":27},{"hierarchy":{"lvl1":"Julia Package Development","lvl2":"Package Development"},"type":"lvl2","url":"/l02-03-julia-packages#package-development","position":28},{"hierarchy":{"lvl1":"Julia Package Development","lvl2":"Package Development"},"content":"The vast majority of Julia itself -- including the packages in its standard library -- are written in Julia\n\nThis means that to be a package author you really only need to know Julia\n\nSince you know Julia, you can author packages!\n\nThe Pkg module has a \n\ngenerate function to help us develop packages, however Julia authors reccomend using the first party PkgTemplates.jl package to start a new package\n\nSo, we’ll start by installing PkgTemplates\n\nusing Pkg\nPkg.add(\"PkgTemplates\")\n\nusing PkgTemplates\n\n","type":"content","url":"/l02-03-julia-packages#package-development","position":29},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"CAP6318","lvl2":"Package Development"},"type":"lvl3","url":"/l02-03-julia-packages#cap6318","position":30},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"CAP6318","lvl2":"Package Development"},"content":"As we progress throughout the semseter we will build up a toolbox of useful types and functions\n\nLet’s organize these into a helpful package called CAP6318\n\nWe can also use this package as a way to specify dependencies specifically required for the course\n\nTo create our package we will need to follow the \n\nPkgTemplates.jl documentation to (1) establish the template for our project and (2) run the template on our project name\n\nt = Template(;\n    user=\"sglyon\", # TODO: you change this!\n    plugins=[PkgTemplates.Develop(), ]\n)\n\npackage_dir = t(\"CAP6318\")\n\nNotice that the code generated a new project in ~/.julia/dev/CAP6318\n\nLet’s take a look at was created for us\n\nLet’s see what was created for us\n\ncmd =`tree $package_dir`\nprintln(\"About to run: $cmd\")\nrun(cmd);\n\nHere we see a LICENSE, Manifest.toml/Project.toml pair, and a README.md (for usage instructions) in the top folder\n\nThen inside src/ we have a module file CAP6318.jl\n\nInside test/ we have a runtests.jl file\n\nLet’s peek inside the files\n\nprint_pkg_file(parts::String...) = println(String(read(joinpath(package_dir, parts...))))\nprint_pkg_file(\"Project.toml\")\n\nprint_pkg_file(\"src\", \"CAP6318.jl\")\n\nprint_pkg_file(\"test\", \"runtests.jl\")\n\nOk, we have a nicely structured starting point\n\nWe will add to this throughout the course\n\n","type":"content","url":"/l02-03-julia-packages#cap6318","position":31},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Exercise","lvl2":"Package Development"},"type":"lvl3","url":"/l02-03-julia-packages#exercise","position":32},{"hierarchy":{"lvl1":"Julia Package Development","lvl3":"Exercise","lvl2":"Package Development"},"content":"Perform the following tasks\n\nActivate the project by doing activate CAP6318. Because we specified Develop() in our template and this is the package name we do not need to be in the same directory or pass the directory path\n\nInstall CSV, DataFrames, VegaLite, Graphs in the CAP6318 project. We’ll use them later\n\nEnsure that you installed these correctly by using the print_pkg_file function above and looking for the [deps] section\n\nCreate a new function greet() = println(\"Hello from CAP6318\") in your src/CAP6318.jl module file. Note you will have to open this file in your text editor\n\nCall using CAP6318 then run greet() to see your message","type":"content","url":"/l02-03-julia-packages#exercise","position":33},{"hierarchy":{"lvl1":"Graphs"},"type":"lvl1","url":"/l03-01-graphs","position":0},{"hierarchy":{"lvl1":"Graphs"},"content":"Computational Analysis of Social Complexity\n\nFall 2025, Spencer Lyon\n\nPrerequisites\n\nJulia setup\n\nJulia basics\n\nJulia types and methods\n\nOutcomes\n\nUnderstand key components of networks/graphs\n\nUse the Graphs.jl package for working with graphs in Julia\n\nImplement the breadth-first search algorithm\n\nReferences\n\nEasley and Kleinberg chapter 2\n\n","type":"content","url":"/l03-01-graphs","position":1},{"hierarchy":{"lvl1":"Graphs","lvl2":"Introduction"},"type":"lvl2","url":"/l03-01-graphs#introduction","position":2},{"hierarchy":{"lvl1":"Graphs","lvl2":"Introduction"},"content":"\n\n","type":"content","url":"/l03-01-graphs#introduction","position":3},{"hierarchy":{"lvl1":"Graphs","lvl3":"Why Study Graphs?","lvl2":"Introduction"},"type":"lvl3","url":"/l03-01-graphs#why-study-graphs","position":4},{"hierarchy":{"lvl1":"Graphs","lvl3":"Why Study Graphs?","lvl2":"Introduction"},"content":"Economic, cultural, political, and social interactions are influenced by structure of relationships\n\nTransmission of viruses\n\nInternational trade, supply chains, marketplaces\n\nSpread of information, diffusion of innovation\n\nPolitical persuasion, localized voting patterns\n\nHuman behaviors influenced by network of friends (sports, clothes, music)\n\nBehaviors can be effected by social networks\n\n“Influencers”\n\nCircles of followers can create echo chambers\n\n","type":"content","url":"/l03-01-graphs#why-study-graphs","position":5},{"hierarchy":{"lvl1":"Graphs","lvl3":"Edges and Nodes","lvl2":"Introduction"},"type":"lvl3","url":"/l03-01-graphs#edges-and-nodes","position":6},{"hierarchy":{"lvl1":"Graphs","lvl3":"Edges and Nodes","lvl2":"Introduction"},"content":"A graph specifies relationships between a collection of items\n\nEach item is called a node\n\nA relationship between nodes is represented by an edge\n\nVisually, graphs might look like this:\n\nHere the nodes are A, B, C, D\n\nThe edges connect nodes A-B, B-C, B-D, C-D\n\n","type":"content","url":"/l03-01-graphs#edges-and-nodes","position":7},{"hierarchy":{"lvl1":"Graphs","lvl3":"Adjacency Matrix","lvl2":"Introduction"},"type":"lvl3","url":"/l03-01-graphs#adjacency-matrix","position":8},{"hierarchy":{"lvl1":"Graphs","lvl3":"Adjacency Matrix","lvl2":"Introduction"},"content":"How might we represent the graph above numerically?\n\nOne very common approach is to use a matrix of 0’s and 1’s called an adjancency matrix\n\nSuppose we have a graph of N nodes\n\nWithout loss of generality, we’ll represent them as integers 1:N\n\nLet A \\in \\{0,1\\}^{N \\times N} be our adjacency matrix\n\nElement A_{ij} will be zero unless there is an edge between nodes i and j (diagonal is left as 0)\n\nIn our above we had\n\nNodes A, B, C, D (or 1, 2, 3, 4 respectively)\n\nEdges connecting nodes 1-2, 2-3, 2-4, 3-4\n\nThe adjacency matrix for this example is\nA = \\begin{bmatrix}\n0 & 1 & 0 & 0 \\\\\n1 & 0 & 1 & 1 \\\\\n0 & 1 & 0 & 1 \\\\\n0 & 1 & 1 & 0\n\\end{bmatrix}\n\n","type":"content","url":"/l03-01-graphs#adjacency-matrix","position":9},{"hierarchy":{"lvl1":"Graphs","lvl2":"Graphs in Julia"},"type":"lvl2","url":"/l03-01-graphs#graphs-in-julia","position":10},{"hierarchy":{"lvl1":"Graphs","lvl2":"Graphs in Julia"},"content":"In Julia there are a few ways we could represent our example graph above\n\nWe could start with the adjacency matrix concept as follows\n\nA = [\n\t0 1 0 0\n\t1 0 1 1\n\t0 1 0 1\n\t0 1 1 0\n]\n\n","type":"content","url":"/l03-01-graphs#graphs-in-julia","position":11},{"hierarchy":{"lvl1":"Graphs","lvl3":"Working with Adjacency Matrices","lvl2":"Graphs in Julia"},"type":"lvl3","url":"/l03-01-graphs#working-with-adjacency-matrices","position":12},{"hierarchy":{"lvl1":"Graphs","lvl3":"Working with Adjacency Matrices","lvl2":"Graphs in Julia"},"content":"An adjacency matrix gives us a lot of information about the structure of the graph\n\nWe could compute all of the following\n\nTotal number of nodes: number of rows or columns of A\n\nTotal number of edges: \\sum_{ij} A_{ij}\n\nNode with most edges: \\text{argmax}_{i} \\sum_{j} A_{i,j}\n\nAverage number of edges per node: \\frac{2}{N} \\cdot \\sum_{i,j>i} A_{i,j}\n\n","type":"content","url":"/l03-01-graphs#working-with-adjacency-matrices","position":13},{"hierarchy":{"lvl1":"Graphs","lvl3":"Exercise: Adjacency Matrix","lvl2":"Graphs in Julia"},"type":"lvl3","url":"/l03-01-graphs#exercise-adjacency-matrix","position":14},{"hierarchy":{"lvl1":"Graphs","lvl3":"Exercise: Adjacency Matrix","lvl2":"Graphs in Julia"},"content":"In the cell below we have defined an adjacency matrix called A_ex1\n\nUsing A_ex1 answer the following questions:\n\nHow many nodes are in the graph?\n\nHow many edges?\n\nNode with most edges (hint, use the dims argument to sum and then the argmax function)\n\nAverage number of edges per node\n\nNumber of connections for node 7: \\sum_j A_{j7}\n\nimport Random\nRandom.seed!(42)\n\nA_ex1 = zeros(Int, 30, 30)\n\nfor i in 1:30\n    for j in (i+1):30\n        if rand() < 0.2\n            A_ex1[i, j] = 1\n            A_ex1[j, i] = 1\n        end\n    end\nend\n\n# Your code here\n\nex1_total_nodes = missing\nex1_total_edges = missing\nex1_node_most_edges = missing\nex1_average_edges_per_node = missing\nex1_connections_node_7 = missing\n\n","type":"content","url":"/l03-01-graphs#exercise-adjacency-matrix","position":15},{"hierarchy":{"lvl1":"Graphs","lvl3":"Graphs.jl","lvl2":"Graphs in Julia"},"type":"lvl3","url":"/l03-01-graphs#graphs-jl","position":16},{"hierarchy":{"lvl1":"Graphs","lvl3":"Graphs.jl","lvl2":"Graphs in Julia"},"content":"There are many smart graph theory experts in the Juila community\n\nThey have built a package called Graphs for working with graphs (as well as ancillary pacakges for extra features)\n\nWe can build a Graphs.Graph object directly from our adjacency matrix\n\nusing Graphs\n\nG1 = Graph(A)\n\ncollect(edges(G1))  # collect turns an `iterator` into an array\n\ncollect(vertices(G1))  # Graphs refers to nodes as `vertices`\n\n","type":"content","url":"/l03-01-graphs#graphs-jl","position":17},{"hierarchy":{"lvl1":"Graphs","lvl4":"Visualizing Graphs","lvl3":"Graphs.jl","lvl2":"Graphs in Julia"},"type":"lvl4","url":"/l03-01-graphs#visualizing-graphs","position":18},{"hierarchy":{"lvl1":"Graphs","lvl4":"Visualizing Graphs","lvl3":"Graphs.jl","lvl2":"Graphs in Julia"},"content":"We can use the GraphPlot package to visualize our graph\n\nNote that the actual placement of the nodes is randomly generated and then tweaked to clearly show all nodes and edges\n\nThe important thing is not the placement of nodes, but rather their relative structure\n\nusing GraphPlot  # load GraphPlot package\n\ngplot(G1)\n\n","type":"content","url":"/l03-01-graphs#visualizing-graphs","position":19},{"hierarchy":{"lvl1":"Graphs","lvl3":"Size considerations","lvl2":"Graphs in Julia"},"type":"lvl3","url":"/l03-01-graphs#size-considerations","position":20},{"hierarchy":{"lvl1":"Graphs","lvl3":"Size considerations","lvl2":"Graphs in Julia"},"content":"Using Array{Int64,2} to store an adjacency matrix turns out to be a rather costly way to store a graph\n\nIn the original example graph we had 4 nodes and 4 edges\n\nTo store this we needed to have a 4x4 matrix of 64 bit integers\n\nThis is only (Int(16 * 64 / 8) == 128) bytes in our exapmle,\n\nBut consider a graph of websites and links between them -- that graph would have millions of nodes and edges...\n\nThere are a few approaches to reducing this storage cost:\n\nOnly store the upper triangle of the matrix\n\nUse Array{Bool,2} instead of Array{Int64,2} to store adjacency matrix ( each element only sizeof(Bool) == 1 bit!)\n\nUse a \n\nSparseMatrix\n\nStore as a Vector{Vector{Int}}\n\n# Vector{Vector{Int}}\nA2 = [[2], [1, 3, 4], [2, 4], [2, 3]]\n\nG1.fadjlist\n\n","type":"content","url":"/l03-01-graphs#size-considerations","position":21},{"hierarchy":{"lvl1":"Graphs","lvl2":"Graph Theory Concepts"},"type":"lvl2","url":"/l03-01-graphs#graph-theory-concepts","position":22},{"hierarchy":{"lvl1":"Graphs","lvl2":"Graph Theory Concepts"},"content":"Let’s explore some concepts often used in analysis of graphs\n\n","type":"content","url":"/l03-01-graphs#graph-theory-concepts","position":23},{"hierarchy":{"lvl1":"Graphs","lvl3":"Paths","lvl2":"Graph Theory Concepts"},"type":"lvl3","url":"/l03-01-graphs#paths","position":24},{"hierarchy":{"lvl1":"Graphs","lvl3":"Paths","lvl2":"Graph Theory Concepts"},"content":"When studying graphs it is often natural to ask about how things travel or flow across the graph\n\nFor example, how information spreads amongst a group of friends, how data travels the internet, how diseases are transmitted from one person to another, and how people navigate a metro subway system\n\nIn each of these cases, the flow of things goes from node to node across edges\n\nA flow from one any node to another node is called a path\n\n","type":"content","url":"/l03-01-graphs#paths","position":25},{"hierarchy":{"lvl1":"Graphs","lvl3":"Degree","lvl2":"Graph Theory Concepts"},"type":"lvl3","url":"/l03-01-graphs#degree","position":26},{"hierarchy":{"lvl1":"Graphs","lvl3":"Degree","lvl2":"Graph Theory Concepts"},"content":"The degree of a node is the number of edges connected to it\n\nIn our example graph G1, node B has degree 3 (connected to A, C, and D)\n\nNode A has degree 1 (only connected to B)\n\nDegree is a fundamental measure of node importance in a network\n\nHigh-degree nodes are often called “hubs”\n\nIn social networks, these might be influential people or “connectors”\n\nWe can compute degree directly from the adjacency matrix\n\nDegree of node i is \\sum_j A_{ij}\n\nGraphs.jl provides the degree function\n\ndegree(G1)\n\ndegree(arpa, node_ints[\"MIT\"])\n\nThe degree distribution of a network tells us a lot about its structure\n\nMany real-world networks have a few high-degree hubs and many low-degree nodes\n\nSocial networks: celebrities with millions of followers\n\nInternet: major websites with many incoming links\n\nTransportation: hub airports like Atlanta or Chicago\n\n","type":"content","url":"/l03-01-graphs#degree","position":27},{"hierarchy":{"lvl1":"Graphs","lvl3":"Arpanet Example","lvl2":"Graph Theory Concepts"},"type":"lvl3","url":"/l03-01-graphs#arpanet-example","position":28},{"hierarchy":{"lvl1":"Graphs","lvl3":"Arpanet Example","lvl2":"Graph Theory Concepts"},"content":"Consider the following Graph of the first iteration of the internet\n\nThere are many possible paths through this network\n\nConsider a path from UCSB to MIT: UCSB-UCLA-RAND-BBN-MIT\n\nAnother possible path from UCSB to MIT is UCSB-SRI-UTAH-MIT\n\n","type":"content","url":"/l03-01-graphs#arpanet-example","position":29},{"hierarchy":{"lvl1":"Graphs","lvl3":"Graphs.jl Arpanet","lvl2":"Graph Theory Concepts"},"type":"lvl3","url":"/l03-01-graphs#graphs-jl-arpanet","position":30},{"hierarchy":{"lvl1":"Graphs","lvl3":"Graphs.jl Arpanet","lvl2":"Graph Theory Concepts"},"content":"Let’s define the Arpanet using Graphs as it will be helpful throughout this lecture\n\nnodes = [\n\t\t\"UCSB\" => [\"SRI\", \"UCLA\"],\n\t\t\"SRI\" => [\"UCSB\", \"UCLA\", \"STAN\", \"UTAH\"],\n\t\t\"UCLA\" => [\"SRI\", \"UCSB\", \"STAN\", \"RAND\"],\n\t\t\"STAN\" => [\"SRI\", \"UCLA\"],\n\t\t\"UTAH\" => [\"SRI\", \"SDC\", \"MIT\"],\n\t\t\"SDC\" => [\"UTAH\", \"RAND\"],\n\t\t\"RAND\" => [\"UCLA\", \"SDC\", \"BBN\"],\n\t\t\"MIT\" => [\"UTAH\", \"BBN\", \"LINC\"],\n\t\t\"BBN\" => [\"MIT\", \"RAND\", \"HARV\"],\n\t\t\"LINC\" => [\"MIT\", \"CASE\"],\n\t\t\"CASE\" => [\"LINC\", \"CARN\"],\n\t\t\"CARN\" => [\"CASE\", \"HARV\"],\n\t\t\"HARV\" => [\"CARN\", \"BBN\"]\n\t]\nnode_ints = Dict(zip(first.(nodes), 1:length(nodes)))\narpa = SimpleGraph(length(nodes))\nfor (node, edges) in nodes\n    for e in edges\n        add_edge!(arpa, node_ints[node], node_ints[e])\n    end\nend\n\n# save graph for loading in future\nsavegraph(\"arpanet.lg\", arpa)\n\narpa\n\ngplot(arpa, nodelabel=first.(nodes))\n\n","type":"content","url":"/l03-01-graphs#graphs-jl-arpanet","position":31},{"hierarchy":{"lvl1":"Graphs","lvl3":"Cycles","lvl2":"Graph Theory Concepts"},"type":"lvl3","url":"/l03-01-graphs#cycles","position":32},{"hierarchy":{"lvl1":"Graphs","lvl3":"Cycles","lvl2":"Graph Theory Concepts"},"content":"An important concept when analyzing graphs is the concept of a cycle\n\nA cycle is a path that starts and ends at the same node\n\nFor the ARPA net, an example cycle is LINC-CASE-CARN-HARV-BBN-MIT-LINC\n\nQuestion... what is the shortest possible cycle in a graph (including all endpoints)?\n\nCycles appear frequently in real-world networks\n\nFriendship networks: if A is friends with B, and B with C, often A and C become friends\n\nTransportation networks: cyclical routes allow for redundancy and flexibility\n\nSupply chains: cyclical dependencies can create both resilience and vulnerabilities\n\n","type":"content","url":"/l03-01-graphs#cycles","position":33},{"hierarchy":{"lvl1":"Graphs","lvl3":"Trees","lvl2":"Graph Theory Concepts"},"type":"lvl3","url":"/l03-01-graphs#trees","position":34},{"hierarchy":{"lvl1":"Graphs","lvl3":"Trees","lvl2":"Graph Theory Concepts"},"content":"A tree is a connected graph with no cycles\n\nTrees have exactly N-1 edges for N nodes (the minimum to stay connected)\n\nAdding any edge to a tree creates a cycle\n\nRemoving any edge from a tree disconnects it\n\nTrees appear frequently in hierarchical structures\n\nOrganizational charts: CEO at root, departments as branches\n\nFamily trees: ancestors and descendants\n\nDecision trees: choices branching from initial state\n\nFile systems: directories and subdirectories\n\nThe breadth-first search we’ll see later naturally creates a tree from any graph\n\n# Example: create a simple tree\ntree = SimpleGraph(5)\nadd_edge!(tree, 1, 2)\nadd_edge!(tree, 1, 3)\nadd_edge!(tree, 2, 4)\nadd_edge!(tree, 2, 5)\ngplot(tree, nodelabel=1:5)\n\nis_tree(tree)  # Graphs.jl can check if a graph is a tree\n\nis_tree(G1)  # Our original graph has a cycle, so it's not a tree\n\n","type":"content","url":"/l03-01-graphs#trees","position":35},{"hierarchy":{"lvl1":"Graphs","lvl3":"Connectedness","lvl2":"Graph Theory Concepts"},"type":"lvl3","url":"/l03-01-graphs#connectedness","position":36},{"hierarchy":{"lvl1":"Graphs","lvl3":"Connectedness","lvl2":"Graph Theory Concepts"},"content":"A graph is connected if there exists a path between every pair of nodes\n\nIn other words, you can travel from any node to any other node by following edges\n\nThe ARPA network was designed to be connected -- ensuring communication between all sites\n\nWe can check if a graph is connected using Graphs.jl\n\nis_connected(arpa)\n\nIt is natural to believe that many real-world networks are connected\n\nTransportation: you can get to any station\n\nInternet: you can visit any website\n\nBut it is entirely possible to have a non-connected graph\n\nSocial networks (nodes: people, edges: friendships) of college students who different countries\n\nSuppliers for a textile company vs a microchip manufacturer\n\n","type":"content","url":"/l03-01-graphs#connectedness","position":37},{"hierarchy":{"lvl1":"Graphs","lvl3":"Distance","lvl2":"Graph Theory Concepts"},"type":"lvl3","url":"/l03-01-graphs#distance","position":38},{"hierarchy":{"lvl1":"Graphs","lvl3":"Distance","lvl2":"Graph Theory Concepts"},"content":"We can extend concept of paths between nodes, to include a notion of distance\n\nThe length of a path is the number of steps it takes from beginning to end\n\nMIT-BBN-RAND-UCLA has length 3 (starting from MIT take three steps before ending at UCLA)\n\nThe distance between two nodes, is the length of the shortest path between those nodes\n\nGraphs can compute distances using the gdistances function\n\nBelow we compute the distance between UCLA and all nodes\n\nDict(zip(first.(nodes), gdistances(arpa, node_ints[\"UCLA\"])))\n\n","type":"content","url":"/l03-01-graphs#distance","position":39},{"hierarchy":{"lvl1":"Graphs","lvl2":"Breadth-First Search"},"type":"lvl2","url":"/l03-01-graphs#breadth-first-search","position":40},{"hierarchy":{"lvl1":"Graphs","lvl2":"Breadth-First Search"},"content":"If asked, how would you go about computing the distance between the HARV node and all other nodes?\n\nOne iterative approach might be:\n\nStart with HARV: note it is distance zero to HARV\n\nMove on to all nodes directly connected to HARV: these are distance 1\n\nThen move to all nodes connected to nodes that are distance 1 from HARV (excluding any you may have already found): declare these to be at distance 2 from HARV\n\nContinue traversing edges until you have visited all nodes\n\nThis algorihtm is called breadth-first search\n\n","type":"content","url":"/l03-01-graphs#breadth-first-search","position":41},{"hierarchy":{"lvl1":"Graphs","lvl3":"Example: Breadth-First Search from MIT","lvl2":"Breadth-First Search"},"type":"lvl3","url":"/l03-01-graphs#example-breadth-first-search-from-mit","position":42},{"hierarchy":{"lvl1":"Graphs","lvl3":"Example: Breadth-First Search from MIT","lvl2":"Breadth-First Search"},"content":"The image below shows how breadth-first search would proceed for the MIT node\n\n","type":"content","url":"/l03-01-graphs#example-breadth-first-search-from-mit","position":43},{"hierarchy":{"lvl1":"Graphs","lvl3":"Exercise (difficult!): BFS","lvl2":"Breadth-First Search"},"type":"lvl3","url":"/l03-01-graphs#exercise-difficult-bfs","position":44},{"hierarchy":{"lvl1":"Graphs","lvl3":"Exercise (difficult!): BFS","lvl2":"Breadth-First Search"},"content":"Now it is time for you to try this out!\n\nOur goal is to use breadth-first search to compute the distance betwen a given node and all other nodes\n\nThe return value you end up with should be an Vector{Vector{Int}}, where element i of this vector contains all node labels at distance i from the starting node\n\nFill in the logic for the breadth_first_distances function below\n\nfunction breadth_first_distances(g, start::Int)\n\tout = Vector{Int}[]\n\t# use push!(out, new_nodes) to add to out\n\tdistance = 0\n\n\t# TODO: your code here...\n\n\t# return out\n\tout\nend\n\n# Test code\n\nfunction test_bfd_methods(val, want)\n    if length(val) == 0\n        error(\"Make sure to `push!` on to `out` in your function\")\n    elseif length(val) != maximum(gdistances(arpa, node_ints[\"HARV\"]))\n        error(\"`out` has incorrect number of elements\")\n    elseif length.(val) != length.(want)\n        error(\"Right number of elements, but not right number in each subvector\")\n    elseif all(map(x12 -> all(sort(x12[1]) .== sort(x12[2])), zip(val, want)))\n        println(\"correct!\")\n    end\nend\n\nfunction run_tests()\n    val = breadth_first_distances(arpa, node_ints[\"HARV\"])\n    want = [[9, 12], [7, 8, 11], [3, 6, 5, 10], [1, 2, 4]]\n    test_bfd_methods(val, want)\nend\n\n# uncomment the code below and run when you are ready to test your code\n# run_tests()\n\n","type":"content","url":"/l03-01-graphs#exercise-difficult-bfs","position":45},{"hierarchy":{"lvl1":"Graphs","lvl3":"BFS with Graphs","lvl2":"Breadth-First Search"},"type":"lvl3","url":"/l03-01-graphs#bfs-with-graphs","position":46},{"hierarchy":{"lvl1":"Graphs","lvl3":"BFS with Graphs","lvl2":"Breadth-First Search"},"content":"The Graphs library contains routines implementing breadth-first search\n\nThe main function is called bfs_tree\n\nbfs_carn = bfs_tree(arpa, node_ints[\"CARN\"])\n\nNotice that the printout says we have a graph with 13 nodes, 12 edges and it is a directed graph\n\nThus far, all graphs we have considered have been undirected\n\nWe have only been concerned about if a connection (edge) exists between nodes\n\nA directed graph extends the notion of connecting nodes with a direction\n\nWe can now say that things flow across edges from one node to another -- always in the same direction\n\nWhy would the breadth-first search routine return a directed graph instead of the undirected type we started with?\n\nLet’s visualize it and see if we can understand why\n\ngplot(bfs_carn, nodelabel=first.(nodes))\n\nNotice that arrows only flow out of CARN\n\nThey also always flow away from CARN\n\nThe use of directed edges allows Graphs to represent the shortest path from CARN to any other node\n\nFor example STAN: CARN -> HARV -> BBN -> RAND -> UCLA -> STAN\n\n","type":"content","url":"/l03-01-graphs#bfs-with-graphs","position":47},{"hierarchy":{"lvl1":"Graphs","lvl3":"Exercise: Explore DiGraph","lvl2":"Breadth-First Search"},"type":"lvl3","url":"/l03-01-graphs#exercise-explore-digraph","position":48},{"hierarchy":{"lvl1":"Graphs","lvl3":"Exercise: Explore DiGraph","lvl2":"Breadth-First Search"},"content":"The bfs_carn object has type $(Markdown.Code(string(typeof(bfs_carn))))\n\nLet’s view the names of its properties (properties)\n\npropertynames(bfs_carn)\n\nbfs_carn.fadjlist\n\nThe fadjlist (forward adjacency list) property is a Vector{Vector{Int64}}\n\nfadjlist has one element per node (call index into outer Vector i for node i)\n\nEach element is itself a vector containing node indices for all nodes j for which there is an edge flowing from i to j\n\nBelow we have set up a new method (see below) for the breadth_first_distances function that takes a DiGraph as an argument\n\nYour task is to implement the the method so that it has the same return value as the previous method from above\n\nfunction breadth_first_distances(g::SimpleDiGraph, start::Int)\n\tout = Vector{Int}[]\n\t# use push!(out, new_nodes) to add to out\n\tdistance = 0\n\n\t# TODO: your code here...\n\n\t# return out\n\tout\nend\n\n# test code\nfunction test_digraph_ex()\n\tval = breadth_first_distances(\n\t\tbfs_tree(arpa, node_ints[\"HARV\"]),\n\t\tnode_ints[\"HARV\"]\n\t)\n\twant = [[9, 12], [7, 8, 11], [3, 6, 5, 10], [1, 2, 4]]\n\ttest_bfd_methods(val, want)\nend\n\n# uncomment the code below when you are ready to test your code!\n# test_digraph_ex()\n\n","type":"content","url":"/l03-01-graphs#exercise-explore-digraph","position":49},{"hierarchy":{"lvl1":"Graphs","lvl2":"Components"},"type":"lvl2","url":"/l03-01-graphs#components","position":50},{"hierarchy":{"lvl1":"Graphs","lvl2":"Components"},"content":"A component of a graph is a self-contained subset of the nodes\n\nMore precisely, a set of nodes is a component if\n\nEvery node in the subset has a path to every other node in the subset\n\nThe subset is not part of a larger set with property (1)\n\nExample:\n\n","type":"content","url":"/l03-01-graphs#components","position":51},{"hierarchy":{"lvl1":"Graphs","lvl3":"Finding Components","lvl2":"Components"},"type":"lvl3","url":"/l03-01-graphs#finding-components","position":52},{"hierarchy":{"lvl1":"Graphs","lvl3":"Finding Components","lvl2":"Components"},"content":"Graphs.jl provides functions to identify and work with components\n\nconnected_components(g) returns a vector of vectors, where each inner vector contains the nodes in one component\n\nLet’s create a graph with multiple components and explore it\n\n# Create a graph with three components\nmulti_component = SimpleGraph(10)\n# Component 1: nodes 1, 2, 3\nadd_edge!(multi_component, 1, 2)\nadd_edge!(multi_component, 2, 3)\nadd_edge!(multi_component, 3, 1)\n# Component 2: nodes 4, 5, 6, 7\nadd_edge!(multi_component, 4, 5)\nadd_edge!(multi_component, 5, 6)\nadd_edge!(multi_component, 6, 7)\nadd_edge!(multi_component, 7, 4)\n# Component 3: nodes 8, 9\nadd_edge!(multi_component, 8, 9)\n# Node 10 is isolated (its own component)\n\ncomponents = connected_components(multi_component)\n\nprintln(\"Number of components: \", length(components))\nfor (i, comp) in enumerate(components)\n    println(\"Component $i has $(length(comp)) nodes: $comp\")\nend\n\ngplot(multi_component, nodelabel=1:10)\n\n","type":"content","url":"/l03-01-graphs#finding-components","position":53},{"hierarchy":{"lvl1":"Graphs","lvl3":"Why Components Matter","lvl2":"Components"},"type":"lvl3","url":"/l03-01-graphs#why-components-matter","position":54},{"hierarchy":{"lvl1":"Graphs","lvl3":"Why Components Matter","lvl2":"Components"},"content":"Components help us understand the structure of social networks\n\nEach component represents a group that can communicate internally but not with other groups\n\nIn social network analysis, components reveal:\n\nInformation silos: Ideas spread within components but not between them\n\nEcho chambers: Opinions reinforce within isolated groups\n\nCommunity detection: Natural groupings in social structures\n\nInfluence boundaries: Limits of where influence can spread\n\n","type":"content","url":"/l03-01-graphs#why-components-matter","position":55},{"hierarchy":{"lvl1":"Graphs","lvl3":"Real-World Implications","lvl2":"Components"},"type":"lvl3","url":"/l03-01-graphs#real-world-implications","position":56},{"hierarchy":{"lvl1":"Graphs","lvl3":"Real-World Implications","lvl2":"Components"},"content":"Disease spread: Each component represents a boundary for transmission\n\nCOVID-19 travel restrictions aimed to keep countries as separate components\n\nContact tracing identifies components to contain outbreaks\n\nMarketing: Products spread through word-of-mouth within components\n\nNeed to seed each component separately for full market penetration\n\nViral marketing campaigns can fail if they don’t bridge components\n\nPolitical polarization: Separate components in social media\n\nDifferent groups may never see opposing viewpoints\n\nBridging nodes between components become crucial for dialogue\n\nInfrastructure resilience: Power grids, internet backbone\n\nMultiple components mean system fragmentation after failures\n\nRedundant connections prevent network from splitting into components\n\n","type":"content","url":"/l03-01-graphs#real-world-implications","position":57},{"hierarchy":{"lvl1":"Graphs","lvl3":"Giant Component","lvl2":"Components"},"type":"lvl3","url":"/l03-01-graphs#giant-component","position":58},{"hierarchy":{"lvl1":"Graphs","lvl3":"Giant Component","lvl2":"Components"},"content":"Many real-world networks have a giant component containing most nodes\n\nPlus several small components or isolated nodes\n\nLet’s check if ARPANET has this structure\n\narpa_components = connected_components(arpa)\nprintln(\"ARPANET has $(length(arpa_components)) component(s)\")\nprintln(\"Component sizes: \", length.(arpa_components))\n\nARPANET is fully connected (one component) by design\n\nThis ensures any site can communicate with any other site\n\nNetwork resilience was a key design goal for the early internet\n\n","type":"content","url":"/l03-01-graphs#giant-component","position":59},{"hierarchy":{"lvl1":"Graphs","lvl2":"Example"},"type":"lvl2","url":"/l03-01-graphs#example","position":60},{"hierarchy":{"lvl1":"Graphs","lvl2":"Example"},"content":"How many components are in this graph?\n\n","type":"content","url":"/l03-01-graphs#example","position":61},{"hierarchy":{"lvl1":"Graphs","lvl2":"Real-World Network Examples"},"type":"lvl2","url":"/l03-01-graphs#real-world-network-examples","position":62},{"hierarchy":{"lvl1":"Graphs","lvl2":"Real-World Network Examples"},"content":"Let’s analyze some actual network datasets to see these concepts in practice\n\nWe’ll look at:\n\nZachary’s Karate Club: A classic social network dataset\n\nFacebook ego networks: Social connections from real Facebook data\n\nEmail networks: Communication patterns in organizations\n\n","type":"content","url":"/l03-01-graphs#real-world-network-examples","position":63},{"hierarchy":{"lvl1":"Graphs","lvl3":"Zachary’s Karate Club","lvl2":"Real-World Network Examples"},"type":"lvl3","url":"/l03-01-graphs#zacharys-karate-club","position":64},{"hierarchy":{"lvl1":"Graphs","lvl3":"Zachary’s Karate Club","lvl2":"Real-World Network Examples"},"content":"Famous dataset from sociology (Zachary, 1977)\n\nDocuments friendships in a karate club that split into two factions\n\n34 members (nodes), 78 friendships (edges)\n\nPerfect for studying community structure and components\n\n# Graphs.jl includes several famous networks as built-in datasets!\nkarate = smallgraph(:karate)\n\n# Analyze the karate club network\nusing Statistics  # for `mean` function\nprintln(\"Karate Club Network:\")\nprintln(\"  Nodes: \", nv(karate))\nprintln(\"  Edges: \", ne(karate))\nprintln(\"  Average degree: \", round(mean(degree(karate)), digits=2))\nprintln(\"  Is connected: \", is_connected(karate))\n\n# Look at degree distribution\ndegrees = degree(karate)\nprintln(\"\\nDegree distribution:\")\nprintln(\"  Min degree: \", minimum(degrees))\nprintln(\"  Max degree: \", maximum(degrees))\nprintln(\"  Node with most connections: \", argmax(degrees))\n\n# Visualize the karate club network\ngplot(karate, nodelabel=1:nv(karate), nodesize=0.1)\n\n","type":"content","url":"/l03-01-graphs#zacharys-karate-club","position":65},{"hierarchy":{"lvl1":"Graphs","lvl3":"Exercise: Analyzing the Petersen Graph","lvl2":"Real-World Network Examples"},"type":"lvl3","url":"/l03-01-graphs#exercise-analyzing-the-petersen-graph","position":66},{"hierarchy":{"lvl1":"Graphs","lvl3":"Exercise: Analyzing the Petersen Graph","lvl2":"Real-World Network Examples"},"content":"The Petersen graph is a famous graph in graph theory\n\nIt appears in many theoretical results and counterexamples\n\nYour task: analyze this network’s structure\n\n# Load the Petersen graph\npetersen = smallgraph(:petersen)\n\n# TODO: Calculate the following properties\nnum_nodes = missing           # Total number of nodes\nnum_edges = missing           # Total number of edges\navg_degree = missing          # Average degree (should be the same for all nodes!)\nis_it_connected = missing     # Is the graph connected?\nis_it_tree = missing          # Is it a tree?\nnum_components = missing      # How many components?\n\n# Print your results\nprintln(\"Petersen Graph Analysis:\")\nprintln(\"  Number of nodes: \", num_nodes)\nprintln(\"  Number of edges: \", num_edges)\nprintln(\"  Average degree: \", avg_degree)\nprintln(\"  Is connected: \", is_it_connected)\nprintln(\"  Is it a tree: \", is_it_tree)\nprintln(\"  Number of components: \", num_components)\n\n","type":"content","url":"/l03-01-graphs#exercise-analyzing-the-petersen-graph","position":67},{"hierarchy":{"lvl1":"Graphs","lvl3":"Other Built-in Networks","lvl2":"Real-World Network Examples"},"type":"lvl3","url":"/l03-01-graphs#other-built-in-networks","position":68},{"hierarchy":{"lvl1":"Graphs","lvl3":"Other Built-in Networks","lvl2":"Real-World Network Examples"},"content":"Graphs.jl includes many classic networks for teaching and research\n\nSome interesting examples you can explore:\n\n# Examples of other built-in graphs\ngraphs_to_explore = [\n    :house,        # The \"house\" graph (5 nodes)\n    :bull,         # The bull graph\n    :cubical,      # 3-dimensional cube\n    :diamond,      # Diamond graph\n    :dodecahedral, # Dodecahedron graph (20 nodes)\n    :heawood,      # Heawood graph (14 nodes)\n    :moebiuskantor,# Möbius-Kantor graph\n    :octahedral,   # Octahedron graph\n    :pappus,       # Pappus graph\n    :tutte,        # Tutte graph (46 nodes)\n]\n\n# Try loading and analyzing one!\n# Example: g = smallgraph(:house)","type":"content","url":"/l03-01-graphs#other-built-in-networks","position":69},{"hierarchy":{"lvl1":"Strong and Weak Ties"},"type":"lvl1","url":"/l03-02-strong-weak-ties","position":0},{"hierarchy":{"lvl1":"Strong and Weak Ties"},"content":"Computational Analysis of Social Complexity\n\nFall 2025, Spencer Lyon\n\nPrerequisites\n\nIntroduction to Graphs\n\nOutcomes\n\nRecognize open and closed triangles in a graph\n\nUnderstand concept of triadic closure\n\nBe able to identify global and local bridges in a network: visually and programatically\n\nUnderstand the “strength of weak ties”\n\nBe familiar with betweenness centrality and its use in graph partitioning\n\nReferences\n\nEasley and Kleinberg chapter 3\n\n","type":"content","url":"/l03-02-strong-weak-ties","position":1},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl2":"Granovetter’s question"},"type":"lvl2","url":"/l03-02-strong-weak-ties#granovetters-question","position":2},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl2":"Granovetter’s question"},"content":"In the late 1960s a PhD student Mark Granovetter wanted to understand how people get a new job\n\nHe interviewed many people who recently changed firms and asked how they got their job\n\nUnsurprisingly, people said they got referrals or learned about the job from personal contacts\n\nSurprisingly, most people said the contacts were made via their “acquaintances” and not “friends”\n\nWhy?\n\n","type":"content","url":"/l03-02-strong-weak-ties#granovetters-question","position":3},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Graphs for Information Flow","lvl2":"Granovetter’s question"},"type":"lvl3","url":"/l03-02-strong-weak-ties#graphs-for-information-flow","position":4},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Graphs for Information Flow","lvl2":"Granovetter’s question"},"content":"To answer Granovetter’s question, we’ll turn to graphs\n\nAs we’ll see, this is one of many possible examples of how we can use a graph to study the flow of information\n\nWhat other examples are there?\n\nFrom what sources do you get your information?\n\nDo you get different types of information from different types of source? Why?\n\nOne interesting point to make in this regard is that by studying information flow via graphs we are taking something inherently interpersonal or emotional (friendships and sharing information) and analyzing it from a structural perspective (as a graph)\n\nKeep these themes in mind as we study the theoretical/technical tools\n\nWe’ll return back to Granovetter’s question after building up some tools\n\n","type":"content","url":"/l03-02-strong-weak-ties#graphs-for-information-flow","position":5},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl2":"Triangles"},"type":"lvl2","url":"/l03-02-strong-weak-ties#triangles","position":6},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl2":"Triangles"},"content":"When studying graphs, the smallest possible structure involving more than two nodes is a triangle\n\nTriangles are made up of three nodes and either two or three edges that connect them\n\nA triangle with only two edges is said to be open\n\nA triangle with three edges is closed\n\nIn the example below, there are 3 triangles, all of which are open\n\nusing Graphs, GraphPlot\n\ng1 = star_graph(4)\nadd_vertex!(g1)\ngplot(g1, nodelabel='A':'E', layout=shell_layout)\n\n","type":"content","url":"/l03-02-strong-weak-ties#triangles","position":7},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Social Triangles","lvl2":"Triangles"},"type":"lvl3","url":"/l03-02-strong-weak-ties#social-triangles","position":8},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Social Triangles","lvl2":"Triangles"},"content":"Suppose our graph is of students arriving for first year of college\n\nEach node is a student\n\nAn edge represents a friendship or connection between students\n\nStory...\n\nA went to and out of school state, but happened to know B, C, and D from various summer camps or family-friend relationships\n\nNone of B, C and D know one another\n\nQuestion: Given only this information, is it more likely that B and E become friends, or B and C? Why?\n\n","type":"content","url":"/l03-02-strong-weak-ties#social-triangles","position":9},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Closing triangles","lvl2":"Triangles"},"type":"lvl3","url":"/l03-02-strong-weak-ties#closing-triangles","position":10},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Closing triangles","lvl2":"Triangles"},"content":"In our example graph the only edges are between A and another node\n\nConsider a triangle formed by nodes A, B, C\n\nTo close this triangle, there would need to be an edge between B-C as follows\n\ng2 = copy(g1)\nadd_edge!(g2, 2, 3)\ngplot(g2, nodelabel='A':'E', layout=shell_layout)\n\n","type":"content","url":"/l03-02-strong-weak-ties#closing-triangles","position":11},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Triadic Closure","lvl2":"Triangles"},"type":"lvl3","url":"/l03-02-strong-weak-ties#triadic-closure","position":12},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Triadic Closure","lvl2":"Triangles"},"content":"There is overwhelming empirical evidence to support the intuition that when there are edges A-B and A-C, it is likely that an edge B-C will form\n\nThis is known as triadic closure (closing the final edge of a triangle)\n\nFor this reason, when analyzing social network data it is very common to see triangles\n\n","type":"content","url":"/l03-02-strong-weak-ties#triadic-closure","position":13},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Triangles with Graphs.jl","lvl2":"Triangles"},"type":"lvl3","url":"/l03-02-strong-weak-ties#triangles-with-graphs-jl","position":14},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Triangles with Graphs.jl","lvl2":"Triangles"},"content":"There is good support in Graphs.jl for helping us count triangles in a graph\n\nThe two key functions are triangles(g) and local_clustering(g)\n\ntriangles(g) will return an array of integers, where values correspond to how many closed triangles there are in the graph\n\n@show triangles(g1)\n@show triangles(g2);\n\nThe local_clustering(g) function will return a tuple of two things:\n\nThe number of closed triangles for each node (same as triangles(g))\n\nThe number of possible triangles for each node in g\n\n@show local_clustering(g1)\n@show local_clustering(g2);\n\n","type":"content","url":"/l03-02-strong-weak-ties#triangles-with-graphs-jl","position":15},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Clustering Coefficients","lvl2":"Triangles"},"type":"lvl3","url":"/l03-02-strong-weak-ties#clustering-coefficients","position":16},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Clustering Coefficients","lvl2":"Triangles"},"content":"It is helpful to have a single number summary of how “closed” a graphs triangles are\n\nThe clustering coefficient tells us the fraction of triangles that are closed\n\n“The clustering coefficient of a node A is defined as the probability that two randomly selected friends of A are friends with each other. In other words, it is the fraction of pairs of A’s friends that are connected to each other by edges” (E&K pg. 49)\n\nThere is a local flavor, where we consider all triangles for a specific node\n\nThere is also a global flavor where we consider all triangles for the entire graph\n\nGraphs.jl has functions local_clustering_coefficient and global_clustering_coefficient to compute these quantities respectively\n\nlocal_clustering_coefficient(g2)\n\nglobal_clustering_coefficient(g2)\n\nQuestion: In each of the graphs below, how many open triangles are there? How many closed?\n\n#graph 1\ngplot(g2, nodelabel='A':'E', layout=shell_layout)\n\n#graph 2\ngplot(path_graph(5), nodelabel='A':'E', layout=shell_layout)\n\n# graph 3\ngplot(dorogovtsev_mendes(7), nodelabel=1:7)\n\n# graph 4\ngplot(smallgraph(:bull), nodelabel=1:5)\n\n","type":"content","url":"/l03-02-strong-weak-ties#clustering-coefficients","position":17},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl2":"Bridges"},"type":"lvl2","url":"/l03-02-strong-weak-ties#bridges","position":18},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl2":"Bridges"},"content":"Consider the graph below\n\ng3 = barbell_graph(4, 4)\ngplot(g3, nodelabel='A':'H', layout=spring_layout)\n\nNow consider D\n\nNotice that connection between D and any of A B C is somehow different from connection to E\n\nD-E is known as a bridge\n\nA bridge is an edge that, if removed, would cause the nodes involved to be in different components of the graph\n\ng4 = copy(g3)\nrem_edge!(g4, 4, 5)\ngplot(g4, nodelabel='A':'H', layout=spring_layout)\n\n","type":"content","url":"/l03-02-strong-weak-ties#bridges","position":19},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Frequency of bridges","lvl2":"Bridges"},"type":"lvl3","url":"/l03-02-strong-weak-ties#frequency-of-bridges","position":20},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Frequency of bridges","lvl2":"Bridges"},"content":"Given our discussion on triadic closure, bridges are likely to be rare in real social networks\n\nIt is very likely that an edge will form between E and one of A``B``C\n\nEven if that isn’t the case, consider the possibility that the graph we have been looking at is actually a smaller subset of a larger graph:\n\nusing Downloads\nif !isfile(\"local_bridge.lg\")\n    Downloads.download(\"https://ucf-cap-6318-resources.s3.amazonaws.com/data/local_bridge.lg\", \"local_bridge.lg\")\nend\ng5 = loadgraph(\"local_bridge.lg\")\ngplot(g5, nodelabel='A':'M', layout=spring_layout)\n\nLocal Bridges\n\nIn the graph above even if D-E were broken, there would only be one component in our graph\n\nIn other words there is another path from D to E (here D-I-K-M-E)\n\nBecause true bridges are so rare, a looser definition of bridge was created called a local bridge\n\nAn edge is a local bridge if A and B have no neighbors in common\n\n","type":"content","url":"/l03-02-strong-weak-ties#frequency-of-bridges","position":21},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Detecting Local Bridges","lvl2":"Bridges"},"type":"lvl3","url":"/l03-02-strong-weak-ties#detecting-local-bridges","position":22},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Detecting Local Bridges","lvl2":"Bridges"},"content":"So far we have dealt with example graphs that we can visually inspect\n\nMost real world graphs are far too large for this\n\nTo analyze larger graphs we need computational tools\n\nLet’s build up some code that will allow us to find local bridges\n\nExercise\n\nPopulate the num_shared_neighbors function below\n\n\"\"\"\n    num_shared_neighbors(g, n1, n2)\n\nGiven a graph `g` and node indexes `n1` and `n2`, compute\nhow many neighbors `n1` and `n2` have in common\n\"\"\"\nfunction num_shared_neighbors(g, n1, n2)\n    # HINT: `neighbors(g, n1)` will give you an array of neighbors\n    #        of `n1`\n\n\nend\n\n\n\n# test code here\nusing Test\n\nfunction test_num_shared_neighbors()\n    @testset \"num_shared_neighbors\" begin\n        vals = [\n            num_shared_neighbors(g5, 6, 7),\n            num_shared_neighbors(g5, 4, 5)\n        ]\n        @test !isnothing(vals[1])\n        @test vals[1] isa Integer\n        @test vals == [2, 0]\n    end\nend\n\n# uncomment and run the code below when you are ready to test your code\n# test_num_shared_neighbors()\n\nExercise\n\nNow that we have a function for computing the number of shared neighbors, we can use it to build a routine for finding a local bridge\n\nWe’ll do that now\n\nYour task is to fill in the missing logic for the local_bridges(g) function below\n\n\"\"\"\n    local_bridges(g)\n\nGiven a graph `g`, find all local bridges in the graph\n\"\"\"\nfunction local_bridges(g)\n    out = []\n    for n1 in 1:nv(g)\n\n        # TODO determine what to loop over for n2\n\n        # TODO: call num_shared_neighbors(g, n1, n2)\n\n        # TODO: if n1 and n2 have no shared neighbors, **AND** (n1 < n2)\n        #       call push!(out, (n1, n2))\n    end\n    return out\nend\n\nfunction test_local_bridges()\n    @testset \"local_bridges\" begin\n        vals = [\n            local_bridges(g5),\n            local_bridges(g4)\n        ]\n        @test vals[1] isa Array\n        @test length(vals[1]) == 1\n        @test length(vals[2]) == 0\n        @test vals[1][1] == (4, 5)\n    end\nend\n\n# uncomment and run the code below when you are ready to test your code\n# test_local_bridges()\n\n","type":"content","url":"/l03-02-strong-weak-ties#detecting-local-bridges","position":23},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Example: Twitter connections","lvl2":"Bridges"},"type":"lvl3","url":"/l03-02-strong-weak-ties#example-twitter-connections","position":24},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Example: Twitter connections","lvl2":"Bridges"},"content":"Let’s now consider an example using real social network data\n\nBelow we’ll load up a graph called tw that is a graph of connections between twitter users\n\nEach node is a different twitter account\n\nThere is an edge between nodes if either one of the accounts follows the other\n\nusing Downloads\nif !isfile(\"twitter.lg\")\n    Downloads.download(\"https://ucf-cap-6318-resources.s3.amazonaws.com/data/twitter.lg\", \"twitter.lg\")\nend\ntw = loadgraph(\"twitter.lg\")\n\nNotice that there are 81,306 nodes and 1,342,310 edges\n\nThis network is far too big to analyze visually\n\nLet’s use a few of our empirical metrics to study the properties of this graph\n\nglobal_clustering_coefficient(tw)\n\ntw_bridges = bridges(tw)\n\nratio_bridges = length(tw_bridges) / ne(tw)\n\nNotice how only 0.372% of edges are bridges (true bridges, not local bridges)!\n\n","type":"content","url":"/l03-02-strong-weak-ties#example-twitter-connections","position":25},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl2":"Edge Strength"},"type":"lvl2","url":"/l03-02-strong-weak-ties#edge-strength","position":26},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl2":"Edge Strength"},"content":"We have so far considered only whether or not two nodes are connected\n\nWe have not discussed the strength of these connections\n\nWe will now extend our analysis to the notion of an edge representing a strong or a weak tie\n\nIn our friendship example, the strong ties would represent friends and the weak ties would represent acquaintances\n\n","type":"content","url":"/l03-02-strong-weak-ties#edge-strength","position":27},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Strong and Weak ties","lvl2":"Edge Strength"},"type":"lvl3","url":"/l03-02-strong-weak-ties#strong-and-weak-ties","position":28},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Strong and Weak ties","lvl2":"Edge Strength"},"content":"In the figure below, we have a representation of a graph similar to our g5 where all edges have been annotated with a S or a W\n\nA S edge represents a strong edge, or friendship\n\nA W edge represents a weak edge or, or acquaintance\n\n","type":"content","url":"/l03-02-strong-weak-ties#strong-and-weak-ties","position":29},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Triadic Closure: Strong Vs Weak","lvl2":"Edge Strength"},"type":"lvl3","url":"/l03-02-strong-weak-ties#triadic-closure-strong-vs-weak","position":30},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Triadic Closure: Strong Vs Weak","lvl2":"Edge Strength"},"content":"Let’s extend the intuition behind triadic closure to our strong/weak setting\n\nOur argument was that because we have edges A-B and A-C, it is likely that an edge B-C will form\n\nNow we’ll state that if A-B and A-C are both strong ties, then it is more likely that B-C will form than if either A-B or A-C were weak\n\nMore formally... we have  the Strong Triadic Closure Property\n\nWe say that a node A violates the Strong Triadic Closure Property if it has strong ties to two other nodes B and C, and there is no edge at all (either a strong or weak tie) between B and C. We say that a node A satisfies the Strong Triadic Closure Property if it does not violate it.\n\n","type":"content","url":"/l03-02-strong-weak-ties#triadic-closure-strong-vs-weak","position":31},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Local Bridges and Weak Ties","lvl2":"Edge Strength"},"type":"lvl3","url":"/l03-02-strong-weak-ties#local-bridges-and-weak-ties","position":32},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Local Bridges and Weak Ties","lvl2":"Edge Strength"},"content":"Given this definition of the Strong Triadic Closure Property, we can make the following claim (see section 3.2 of E&K for proof, intuition in figure below):\n\nClaim: If a node A in a network satisfies the Strong Triadic Closure Property and is involved in at least two strong ties, then any local bridge it is involved in must be a weak tie.\n\n","type":"content","url":"/l03-02-strong-weak-ties#local-bridges-and-weak-ties","position":33},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Back to Granovetter","lvl2":"Edge Strength"},"type":"lvl3","url":"/l03-02-strong-weak-ties#back-to-granovetter","position":34},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Back to Granovetter","lvl2":"Edge Strength"},"content":"Recall our original question: why do people report finding jobs through acquaintances (weak ties) more often than close friends (strong ties)?\n\nThe Strong Triadic Closure Property gives the answer...\n\nSuppose A lost its job\n\nBy asking for a referral from any of C, D, or E; A is likely to get a similar set of information as they are strongly connected to one other and likely have access to the same set of information\n\nInstead by talking to the weak tie B, A is likely to get new information from people in B’s social circle (including H and the three unlabeled nodes)\n\ntl;dr: local bridges are weak ties, so it is weak ties that get you access to “new” parts of the network\n\n","type":"content","url":"/l03-02-strong-weak-ties#back-to-granovetter","position":35},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl2":"Graph Partitioning"},"type":"lvl2","url":"/l03-02-strong-weak-ties#graph-partitioning","position":36},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl2":"Graph Partitioning"},"content":"Social networks often consist of tightly knit regions and weak ties that connect them\n\nOne algorithmic problem that has been studied and applied in many settings is that of graph partitioning\n\nTo partition a graph is to break it down into the tightly-knit components\n\nWhen a graph is partitioned, it is broken down into components called regions\n\ng6 = let\n    edges = Edge.([\n        (1,2), (1,3), (2,3), (3,7), (7,6), (6,4), (6,5), (4,5), (7,8),\n        (8,9), (9,10), (10,11), (9,11), (8,12), (12,13), (13,14), (12,14)\n    ])\n    Graph(edges)\nend\n\ngplot(g6, nodelabel=1:14, layout=spring_layout)\n\n","type":"content","url":"/l03-02-strong-weak-ties#graph-partitioning","position":37},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Two Approaches","lvl2":"Graph Partitioning"},"type":"lvl3","url":"/l03-02-strong-weak-ties#two-approaches","position":38},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Two Approaches","lvl2":"Graph Partitioning"},"content":"There are two classes of algorithms that can be used to partition a graph:\n\nDivisive: partition a graph by removing local bridges (“spanning links”)  and breaking down the network into large chunks\n\nAgglomerative: start with a single node and construct regions “bottom-up” by iteratively finding nodes highly connected to existing nodes in the region\n\nWe’ll focus on divisive methods here\n\n","type":"content","url":"/l03-02-strong-weak-ties#two-approaches","position":39},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Betweenness Centrality","lvl2":"Graph Partitioning"},"type":"lvl3","url":"/l03-02-strong-weak-ties#betweenness-centrality","position":40},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Betweenness Centrality","lvl2":"Graph Partitioning"},"content":"In order to build a divisive partitioning algorithm, we’ll first define a key metric for analyzing how “central” a node is in a network\n\nWe’ll provide a brief introduction here, and refer you to section 3.6 of E&K for more detail\n\nLet V represent set of all nodes and s, t, v \\in V\n\nLet \\sigma_{st} represent the number of shortest paths between s and t\n\nLet \\sigma_{st}(v) represent the number of shortest paths between s and t that pass through v.\n\nThen, the betweenness centrality  for node v (C_{B}(v)) is defined as:\nC_{B}(v) = \\sum_{s \\ne v \\ne t \\in V} \\frac{\\sigma_{st}(v)}{\\sigma_{st}}\n\nConceptually, C_B(v) captures how much information “flows” across node v on average\n\n","type":"content","url":"/l03-02-strong-weak-ties#betweenness-centrality","position":41},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Computing C_B(v)","lvl2":"Graph Partitioning"},"type":"lvl3","url":"/l03-02-strong-weak-ties#computing-c-b-v","position":42},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Computing C_B(v)","lvl2":"Graph Partitioning"},"content":"There are various algorithms we could use to compute C_B(v)\n\nFor now we will let Graphs.jl handle it for us ;)\n\nbetweenness_centrality(g6)\n\nNote that 7 and 8 are a local bridge\n\nAlso note that they carry the highest value of C_B...🤔\n\n","type":"content","url":"/l03-02-strong-weak-ties#computing-c-b-v","position":43},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Algorithm: Girvan-Newman","lvl2":"Graph Partitioning"},"type":"lvl3","url":"/l03-02-strong-weak-ties#algorithm-girvan-newman","position":44},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl3":"Algorithm: Girvan-Newman","lvl2":"Graph Partitioning"},"content":"We will not present the algorithm in detail, but will describe the overall steps\n\nRefer to Section 3.6 of E&K for details\n\nThe Girvan-Newman algorithm for graph partitioning:\n\nInputs: node\n\nOutputs: list of edges to delete at each step\n\nAlgorithm:\n\nFind nodes with highest betweenness centrality -- remove them from the network (and add edges connecting them to the network to the list of deleted edges for first step)\n\nRe-compute betweenness centrality for all subgraphs that resulted from deletion in step 1. Remove all nodes with highest betweenness centrality and record list of deleted edges\n\nContinue until all edges have been removed\n\n","type":"content","url":"/l03-02-strong-weak-ties#algorithm-girvan-newman","position":45},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl2":"Summary: Key ideas"},"type":"lvl2","url":"/l03-02-strong-weak-ties#summary-key-ideas","position":46},{"hierarchy":{"lvl1":"Strong and Weak Ties","lvl2":"Summary: Key ideas"},"content":"Triangles are key network structures\n\nClosed triangles are common in social networks due to triadic closure\n\nSocial networks are often composed of tightly knit regions bound together with weak ties\n\nWeak ties often form local bridges and are therefore valuable for referrals and information flow\n\nBetweenness centrality captures idea of how essential a node is in connecting regions of a graph (how much information flows across a node)","type":"content","url":"/l03-02-strong-weak-ties#summary-key-ideas","position":47},{"hierarchy":{"lvl1":"Homophily"},"type":"lvl1","url":"/l04-01-homophily","position":0},{"hierarchy":{"lvl1":"Homophily"},"content":"Computational Analysis of Social Complexity\n\nFall 2025, Spencer Lyon\n\nPrerequisites\n\nIntroduction to Graphs\n\nStrong and Weak Ties\n\nOutcomes\n\nUnderstand the concept of homophily\n\nPractice working through “by hand” examples of diagnosing homophily\n\nBe prepared to computationally diagnose homophily in a large network\n\nReferences\n\nEasley and Kleinberg chapter 4 (especially section 4.1)\n\nDatasets\n\nFlorentine family relationships: \n\nhttps://​www​.cs171​.org​/2018​/assets​/instructions​/lab8​/Lab8​.html\n\n","type":"content","url":"/l04-01-homophily","position":1},{"hierarchy":{"lvl1":"Homophily","lvl2":"Introduction"},"type":"lvl2","url":"/l04-01-homophily#introduction","position":2},{"hierarchy":{"lvl1":"Homophily","lvl2":"Introduction"},"content":"\n\n","type":"content","url":"/l04-01-homophily#introduction","position":3},{"hierarchy":{"lvl1":"Homophily","lvl3":"Main Idea","lvl2":"Introduction"},"type":"lvl3","url":"/l04-01-homophily#main-idea","position":4},{"hierarchy":{"lvl1":"Homophily","lvl3":"Main Idea","lvl2":"Introduction"},"content":"Consider your friends. Do they tend to\n\nEnjoy the same movies, music, hobbies as you?\n\nHold similar religious or political beliefs?\n\nCome from similar schools, workplaces, or socio-economic settings?\n\nWhat about a random sample of people in the world?\n\nIf you are like me, your answers likely indicate that you have more in common with your friends than you would expect to have with a random sample of people\n\nThis concept -- that we are similar to our friends -- is called homophily\n\n","type":"content","url":"/l04-01-homophily#main-idea","position":5},{"hierarchy":{"lvl1":"Homophily","lvl3":"Homophily in Graphs","lvl2":"Introduction"},"type":"lvl3","url":"/l04-01-homophily#homophily-in-graphs","position":6},{"hierarchy":{"lvl1":"Homophily","lvl3":"Homophily in Graphs","lvl2":"Introduction"},"content":"In the context of graphs or networks, homophily means that nodes that are connected are more similar than nodes at a further distance in the graph\n\nBut what do we mean by more similar?\n\nIdea: We might have common friends.\n\nThis is an intrinsic force that led to node formation (e.g. triadic closure)\n\nAlternative: We may share characteristics or properties that are not represented in the graph -- external forces.\n\nExamples: same race, gender, school, employer, sports team, etc.\n\nThese external forces are what homophily captures\n\n","type":"content","url":"/l04-01-homophily#homophily-in-graphs","position":7},{"hierarchy":{"lvl1":"Homophily","lvl3":"Context","lvl2":"Introduction"},"type":"lvl3","url":"/l04-01-homophily#context","position":8},{"hierarchy":{"lvl1":"Homophily","lvl3":"Context","lvl2":"Introduction"},"content":"To identify if homophily is active in a network, we must have access to context on top of list of nodes and edges\n\nOne way to represent this context would be with a DataFrame in addition to a graph:\n\nOne row per node\n\nOne column indicating the node identifier (or just use row number)\n\nOne column for additional characteristic\n\nusing DataFrames, Graphs, GraphPlot\n\n\n\ndf1 = DataFrame(\n    family=[\n        \"Acciaiuoli\", \"Albizzi\", \"Barbadori\", \"Bischeri\", \"Castellani\",\n        \"Ginori\", \"Guadagni\", \"Lamberteschi\", \"Medici\", \"Pazzi\",\n        \"Peruzzi\", \"Ridolfi\", \"Salviati\", \"Strozzi\", \"Tornabuoni\"\n    ],\n    wealth=[10, 36, 55, 44, 20, 32, 8, 42, 103, 48, 49,  27, 10, 146, 48],\n    priorates=[53, 65, missing, 12, 22, missing, 21, 0, 53, missing, 42, 38, 35, 74, missing],\n)\n\nIt will be easier to do our homohpily calculations with binary data,\n\nwe’ll create new columns, high_wealth and high_power if the wealth and priorates columns, respectively, are above the column medians\n\nusing Statistics\ndf1[!, :high_wealth] = df1.wealth .> median(df1.wealth)\ndf1[!, :high_power] = df1.priorates .> median(df1.priorates[.!(ismissing.(df1.priorates))])\ndf1[ismissing.(df1.priorates), :high_power] .= false\ndf1\n\n\nmarriages = [\n    0 0 0 0 0 0 0 0 1 0 0 0 0 0 0\n    0 0 0 0 0 1 1 0 1 0 0 0 0 0 0\n    0 0 0 0 1 0 0 0 1 0 0 0 0 0 0\n    0 0 0 0 0 0 1 0 0 0 1 0 0 1 0\n    0 0 1 0 0 0 0 0 0 0 1 0 0 1 0\n    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0\n    0 1 0 1 0 0 0 1 0 0 0 0 0 0 1\n    0 0 0 0 0 0 1 0 0 0 0 0 0 0 0\n    1 1 1 0 0 0 0 0 0 0 0 1 1 0 1\n    0 0 0 0 0 0 0 0 0 0 0 0 1 0 0\n    0 0 0 1 1 0 0 0 0 0 0 0 0 1 0\n    0 0 0 0 0 0 0 0 1 0 0 0 0 1 1\n    0 0 0 0 0 0 0 0 1 1 0 0 0 0 0\n    0 0 0 1 1 0 0 0 0 0 1 1 0 0 0\n    0 0 0 0 0 0 1 0 1 0 0 1 0 0 0\n]\ng1 = Graph(marriages)\n\ngplot(g1, nodelabel=df1.family)\n\n","type":"content","url":"/l04-01-homophily#context","position":9},{"hierarchy":{"lvl1":"Homophily","lvl2":"Measuring Homophily"},"type":"lvl2","url":"/l04-01-homophily#measuring-homophily","position":10},{"hierarchy":{"lvl1":"Homophily","lvl2":"Measuring Homophily"},"content":"Our discussion on homophily so far has been conceptual... let’s make it precise\n\nWe’ll frame the discussion in terms of a null hypothesis\n\nConcept should be familiar from statistics, but not exactly the same we we won’t make distributional assumptions\n\n","type":"content","url":"/l04-01-homophily#measuring-homophily","position":11},{"hierarchy":{"lvl1":"Homophily","lvl3":"Random Homophily","lvl2":"Measuring Homophily"},"type":"lvl3","url":"/l04-01-homophily#random-homophily","position":12},{"hierarchy":{"lvl1":"Homophily","lvl3":"Random Homophily","lvl2":"Measuring Homophily"},"content":"Our analytical approach begins with a thought experiment (counter factual) that all edges are randomly formed\n\nIn this case, we should not expect the context around our graph to help us predict its structure\n\nSuppose we consider a characteristic X\n\nWe have N nodes and N_x of them exhibit feature X and N - N_x of them to not\n\nWe’ll work with probabilities: p_x = \\frac{N_x}{N}\n\nThe probability that an arbitrary edge is between two nodes that both share X is equal to p_x^2\n\nProbability of edge between two non X nodes: (1-p_x)^2\n\nProbabillity of edge bewtween one X and one non X:\n\\begin{aligned}\\text{prob}(\\text{edge (X <=> not X)}) &= p_x (1-p_x) + (1-p_x) p_x \\\\ &= 2 p_x (1-p_x)\\end{aligned}\n\nThis will be our “random edge formation” benchmark\n\n","type":"content","url":"/l04-01-homophily#random-homophily","position":13},{"hierarchy":{"lvl1":"Homophily","lvl3":"Counting Frequencies","lvl2":"Measuring Homophily"},"type":"lvl3","url":"/l04-01-homophily#counting-frequencies","position":14},{"hierarchy":{"lvl1":"Homophily","lvl3":"Counting Frequencies","lvl2":"Measuring Homophily"},"content":"Now an empirical value...\n\nLet there be e edges\n\nLet...\n\nvariable\n\nmeaning\n\ne_{xx}\n\n# edges between 2 X\n\ne_{yy}\n\n# edges between 2 not X\n\ne_{xy}\n\n# edges between 1 X  and 1 not X\n\nThen e = e_{xx} + e_{yy} + e_{xy}\n\nWe’ll use these 4 numbers to count frequencies of edges between X types and non-X types\n\n","type":"content","url":"/l04-01-homophily#counting-frequencies","position":15},{"hierarchy":{"lvl1":"Homophily","lvl3":"Testing for Homophily","lvl2":"Measuring Homophily"},"type":"lvl3","url":"/l04-01-homophily#testing-for-homophily","position":16},{"hierarchy":{"lvl1":"Homophily","lvl3":"Testing for Homophily","lvl2":"Measuring Homophily"},"content":"We are now ready to test for homophily\n\nWe’ll consider the assumption (null hypothesis) that there is no homophily in characteristic X\n\n\\Longrightarrow observed proportion of cross-characteristic edges is (approximately) the same as characteristic frequencies in the full population\n\nTo test this assumption, we compare\n\n2 p_x(1-p_x): the likelihood of a cross-characteristic edge forming, under the assumption of purely random edge formation\n\n\\frac{e_{xy}}{e}: the proportion of cross-characteristic edges that exist in the network\n\nWhen comparing these statistics, we could get one of three outcomes:\n\nCondition\n\nresult\n\n\\frac{e_{xy}}{e} >> 2 p_x(1-p_x)\n\ninverse homophily\n\n\\frac{e_{xy}}{e} \\approx 2 p_x(1-p_x)\n\nno homophily\n\n\\frac{e_{xy}}{e} << 2 p_x(1-p_x)\n\nhomophily\n\nIntuition: If observed cross characteristic edge formation is significantly less than what we’d expected under random edge formation, we reject the hypothesis that homophily is not present, and conclude that characteristic X is meaningful for edge formation\n\n","type":"content","url":"/l04-01-homophily#testing-for-homophily","position":17},{"hierarchy":{"lvl1":"Homophily","lvl3":"Example: high school relationships","lvl2":"Measuring Homophily"},"type":"lvl3","url":"/l04-01-homophily#example-high-school-relationships","position":18},{"hierarchy":{"lvl1":"Homophily","lvl3":"Example: high school relationships","lvl2":"Measuring Homophily"},"content":"Recall the graph of romantic relationships between high school students\n\nQuestion: does this graph exhibit homophily in gender? Why?\n\n","type":"content","url":"/l04-01-homophily#example-high-school-relationships","position":19},{"hierarchy":{"lvl1":"Homophily","lvl2":"Example: Florentines"},"type":"lvl2","url":"/l04-01-homophily#example-florentines","position":20},{"hierarchy":{"lvl1":"Homophily","lvl2":"Example: Florentines"},"content":"Let’s work through an example of numerically dianosing homophily using the Florentine data\n\nI’ll repeat the data below\n\ndf1\n\nnode_color = map(x -> x ? \"blue\" : \"red\", df1.high_wealth)\ngplot(g1, nodelabel=df1.family, nodefillc=node_color)\n\n","type":"content","url":"/l04-01-homophily#example-florentines","position":21},{"hierarchy":{"lvl1":"Homophily","lvl3":"Step 1: Counting frequencies","lvl2":"Example: Florentines"},"type":"lvl3","url":"/l04-01-homophily#step-1-counting-frequencies","position":22},{"hierarchy":{"lvl1":"Homophily","lvl3":"Step 1: Counting frequencies","lvl2":"Example: Florentines"},"content":"First we need to count frequencies for all our characteristics\n\nWe’ll do that here\n\nusing DataStructures\n\nfunction count_frequencies(vals)\n    counts = DataStructures.counter(vals)\n    total = length(vals)\n    Dict(c => v / total for (c, v) in pairs(counts))\nend\n\ncount_frequencies(df1.high_wealth)\n\nDict(\n    n => count_frequencies(df1[!, n])\n    for n in names(df1)[4:end]\n)\n\n","type":"content","url":"/l04-01-homophily#step-1-counting-frequencies","position":23},{"hierarchy":{"lvl1":"Homophily","lvl3":"Step 2: Counting Edges","lvl2":"Example: Florentines"},"type":"lvl3","url":"/l04-01-homophily#step-2-counting-edges","position":24},{"hierarchy":{"lvl1":"Homophily","lvl3":"Step 2: Counting Edges","lvl2":"Example: Florentines"},"content":"Next we need to count the number of edges of each type\n\nThis step is a bit tricker as it will require that we access both data from the Graph and the DataFrame\n\nTo not spoil the fun, we’ll leave this code as an exercise on the homework\n\nFor now we’ll look at things “by hand”\n\nLet’s consider high_wealth and test if marriages where influenced by mutual wealth\n\nData: We have 7 high wealth families in the dataset\n\nCounting edge types for high_wealth vs non high_wealth:\n\nhigh-high edges: 6\n\nlow-low edges: 3\n\nCross edges (high to low): 11\n\nTotal: 11 + 6 + 3 = 20 edges ✓\n\nThe ratio of cross edges is 11/20 = 0.55\n\nThe ratio of nodes that are high is 7/15 = 0.46 (p_x)\n\ngplot(g1, nodelabel=df1.family)\n\nE = ne(g1)\nExy = 11  # cross edges\nn_high = 7\nN = nv(g1)\npx = n_high / N\n\n# test\n2 * px * (1-px), Exy/E\n\nHere we have that the actual proportion of cross edges (0.55) is slightly higher than what we’d expect under random formation (0.5)\n\nThis suggests a very mild instance of inverse homophily (opposites attract), though the difference is quite small\n\nThis does make some sense, as anecdotally we have heard tales of parents desiring their daughters to marry into a wealthy family\n\n","type":"content","url":"/l04-01-homophily#step-2-counting-edges","position":25},{"hierarchy":{"lvl1":"Homophily","lvl3":"Exercise","lvl2":"Example: Florentines"},"type":"lvl3","url":"/l04-01-homophily#exercise","position":26},{"hierarchy":{"lvl1":"Homophily","lvl3":"Exercise","lvl2":"Example: Florentines"},"content":"Repeat the counting exercise, but for the high_power characteristic\n\nWhat do you find? Do you see homophily in this characteristic?","type":"content","url":"/l04-01-homophily#exercise","position":27},{"hierarchy":{"lvl1":"Weighted Graphs"},"type":"lvl1","url":"/l04-02-weighted-graphs","position":0},{"hierarchy":{"lvl1":"Weighted Graphs"},"content":"Prerequisites\n\nIntroduction to Graphs\n\nStrong and Weak Ties\n\nOutcomes\n\nKnow what a weighted graph is and how to construct them using SimpleWeightedGraphs.jl\n\nImplement the shortest path algorithm for traversing a weighted graph\n\nReferences\n\nEasley and Kleinberg chapter 5 (especially section 5.1-5-3)\n\n# import Pkg; Pkg.add(\"SimpleWeightedGraphs\")\n\nusing Graphs, GraphPlot, SimpleWeightedGraphs\n\n","type":"content","url":"/l04-02-weighted-graphs","position":1},{"hierarchy":{"lvl1":"Weighted Graphs","lvl2":"Introduction"},"type":"lvl2","url":"/l04-02-weighted-graphs#introduction","position":2},{"hierarchy":{"lvl1":"Weighted Graphs","lvl2":"Introduction"},"content":"So far we have considered a few types of graphs\n\nUndirected graph: nodes A and B are connected by an edge\n\nDirected graph: connection from node A to node B\n\nStrong/weak graphs: each edge is labeled as strong or weak\n\nToday we extend our understanding of networks to talk about weighted graphs\n\nEach edge is assigned a float denoting the strength of tie\n\nTies can be positive (friends) or negative (enemies)\n\nCan also very in strength (+2.0 better friends than +0.2)\n\n","type":"content","url":"/l04-02-weighted-graphs#introduction","position":3},{"hierarchy":{"lvl1":"Weighted Graphs","lvl3":"Weighted Adjacency Matrix","lvl2":"Introduction"},"type":"lvl3","url":"/l04-02-weighted-graphs#weighted-adjacency-matrix","position":4},{"hierarchy":{"lvl1":"Weighted Graphs","lvl3":"Weighted Adjacency Matrix","lvl2":"Introduction"},"content":"In a simple (unweighted) graph, we used a matrix of 0’s and 1’s as an adjacency matrix\n\nA 1 in row i column j marked an edge between i and j (or from i->j for directed)\n\nA 0 marked lack of an edge\n\nG1 = complete_graph(4)\nlocs_x = [1, 2, 3, 2.0]\nlocs_y = [1.0, 0.7, 1, 0]\nlabels1 = collect('A':'Z')[1:nv(G1)]\ngplot(G1, locs_x, locs_y, nodelabel=labels1)\n\nA1 = adjacency_matrix(G1)\n\nWe can extend idea of adjacency matrix to include weighted edges\n\nSuppose nodes A, B, C are friends -- but A-C are best friends\n\nAlso suppose that all of A, B, C consider D an enemy\n\nTo represent this we might say weight of edges is:\n\nA-B and B-C: 1.0\n\nA-C: 2.0\n\nA-D, B-D, C-D: -1.0\n\nHere’s the adjacency matrix\n\nA2 = [0 1 2 -1; 1 0 1 -1; 2 1 0 -1; -1 -1 -1.0 0]\n\nAnd here is how we might visualize this graph (notice the labeled edges)\n\nG2 = SimpleWeightedGraph(A2)\ngplot(\n    G2, locs_x, locs_y,\n    nodelabel=labels1, edgelabel=weight.(edges(G2)),\n)\n\n","type":"content","url":"/l04-02-weighted-graphs#weighted-adjacency-matrix","position":5},{"hierarchy":{"lvl1":"Weighted Graphs","lvl2":"Shortest Paths"},"type":"lvl2","url":"/l04-02-weighted-graphs#shortest-paths","position":6},{"hierarchy":{"lvl1":"Weighted Graphs","lvl2":"Shortest Paths"},"content":"We talked previously about shortest paths for a Graph\n\nThis was defined as the minimum number of edges needed to move from node n1 to node n2\n\nWhen we have a weighted graph things get more interesting...\n\nLet w_{ab} represent the weight connecting nodes A and B\n\nDefine the shortest path between n1 and n2 as the path that minimizes \\sum w_{ab} for all edges A->B along a path\n\n","type":"content","url":"/l04-02-weighted-graphs#shortest-paths","position":7},{"hierarchy":{"lvl1":"Weighted Graphs","lvl3":"Example","lvl2":"Shortest Paths"},"type":"lvl3","url":"/l04-02-weighted-graphs#example","position":8},{"hierarchy":{"lvl1":"Weighted Graphs","lvl3":"Example","lvl2":"Shortest Paths"},"content":"Consider the following directed graph\n\nA3 = [\n    0 1 5 3 0 0 0\n    0 0 0 9 6 0 0\n    0 0 0 0 0 2 0\n    0 0 0 0 0 4 8\n    0 0 0 0 0 0 4\n    0 0 0 0 0 0 1\n    0 0 0 0 0 0 0\n]\nG3 = SimpleWeightedDiGraph(A3)\n\n#plotting details\nlocs_x_3 = [3, 5, 1, 3, 4, 2, 3.0]\nlocs_y_3 = [1, 2, 2, 3, 4, 4, 5.0]\nlabels3 = collect('A':'Z')[1:size(A3, 1)]\ngplot(G3, locs_x_3, locs_y_3, nodelabel=labels3, edgelabel=weight.(edges(G3)))\n\nWe wish to travel from node A to node G at minimum cost\n\nThe shortest path (ignoring weights)  is A-D-G\n\nTaking into account weights we have 3 + 8 = 11\n\nThere are two other paths that lead to lower cost (total of 8)\n\nA-C-F-G has cost 5 + 2 + 1 = 8\n\nA-D-F-G has cost 3 + 4 + 1 = 8\n\nFor this small graph, we could find these paths by hand\n\nFor a larger one, we will need an algorithm...\n\n","type":"content","url":"/l04-02-weighted-graphs#example","position":9},{"hierarchy":{"lvl1":"Weighted Graphs","lvl3":"Shortest path algorithm","lvl2":"Shortest Paths"},"type":"lvl3","url":"/l04-02-weighted-graphs#shortest-path-algorithm","position":10},{"hierarchy":{"lvl1":"Weighted Graphs","lvl3":"Shortest path algorithm","lvl2":"Shortest Paths"},"content":"Let J(v) be the minimum cost-to-go from node v to node G\n\nSuppose that we know J(v) for each node v, as shown below for our example graph\n\nNote J(G) = 0\n\n\n\nWith J(v) in hand, the following algorithm will find the cost-minimizing path from A to G:\n\nStart with v = A\n\nFrom current node v move to any node that solves \\min_{n \\in F_v} w_{vn} + J(n), where F_v is the set of nodes that can be reached from v.\n\nUpdate notation to set v = n\n\nRepeat steps 2-3 (making note of which we visit) until v = G\n\n","type":"content","url":"/l04-02-weighted-graphs#shortest-path-algorithm","position":11},{"hierarchy":{"lvl1":"Weighted Graphs","lvl3":"Exercise: Traversing Cost-Minimizing Path","lvl2":"Shortest Paths"},"type":"lvl3","url":"/l04-02-weighted-graphs#exercise-traversing-cost-minimizing-path","position":12},{"hierarchy":{"lvl1":"Weighted Graphs","lvl3":"Exercise: Traversing Cost-Minimizing Path","lvl2":"Shortest Paths"},"content":"Let’s implement the algorithm above\n\nBelow I have started a function called traverse_graph\n\nYour task is to complete it until you get that the minimum cost path has a cost of 8 and length(4)\n\nJ3 = [8, 10, 3, 5, 4, 1, 0]\n\nfunction traverse_graph(\n        G::SimpleWeightedDiGraph, \n        J::AbstractArray, \n        start_node::Int, end_node::Int\n    )\n    path = Int[start_node]\n    cost = 0.0\n    W = weights(G)\n\n    # TODO: step1, initialize v\n    v = 1  # CHANGE ME\n    num = 0\n    while v != end_node && num < nv(G)  # prevent infinite loop\n        num +=1\n        F_v = neighbors(G, v)\n\n        # TODO: step 2, compute costs for all n in F_v\n        costs = [0 for n in F_v]  # CHANGE ME\n\n        n = F_v[argmin(costs)]\n\n        # TODO: how should we update cost?\n        cost += 0   # CHANGE ME\n\n        push!(path, n)\n\n        # TODO: step 3 -- update v\n        v = v  # CHANGE ME\n    end\n    path, cost\nend\n\ntraverse_graph(G3, J3, 1, 7)\n\n","type":"content","url":"/l04-02-weighted-graphs#exercise-traversing-cost-minimizing-path","position":13},{"hierarchy":{"lvl1":"Weighted Graphs","lvl3":"But what about J(v)","lvl2":"Shortest Paths"},"type":"lvl3","url":"/l04-02-weighted-graphs#but-what-about-j-v","position":14},{"hierarchy":{"lvl1":"Weighted Graphs","lvl3":"But what about J(v)","lvl2":"Shortest Paths"},"content":"The shortest path algorithm we presented above sounds simple, but assumed we know J(v)\n\nHow can we find it?\n\nIf you stare at the following equation long enough, you’ll be convinced that J satisfies\nJ(v) = \\min_{n \\in F_v} w_{vn} + J(n)\n\nThis is known as the Bellman equation\n\nIt is a restriction that J must satisfy\n\nWe’ll use this restriction to compute J\n\n","type":"content","url":"/l04-02-weighted-graphs#but-what-about-j-v","position":15},{"hierarchy":{"lvl1":"Weighted Graphs","lvl3":"Computing J: Guess and Iterate","lvl2":"Shortest Paths"},"type":"lvl3","url":"/l04-02-weighted-graphs#computing-j-guess-and-iterate","position":16},{"hierarchy":{"lvl1":"Weighted Graphs","lvl3":"Computing J: Guess and Iterate","lvl2":"Shortest Paths"},"content":"We’ll present the standard algorithm for computing J(v)\n\nThis is an iterative method\n\nLet i represent the iteration we are on and J_i(v) be the guess for J(v) on iteration i\n\nAlgorithm\n\nSet i=0, and J_i(v) = 0 \\forall v\n\nSet J_{i+1}(v) = \\min_{n \\in F_v} w_{vn} + J_i(n) \\forall n\n\nCheck if J_{i+1} and J_i are equal for all v -- if not set i = i+1 and see repeat steps 2-3\n\nThis algorithm converges to J (we won’t prove it here...)\n\n","type":"content","url":"/l04-02-weighted-graphs#computing-j-guess-and-iterate","position":17},{"hierarchy":{"lvl1":"Weighted Graphs","lvl3":"Implementation","lvl2":"Shortest Paths"},"type":"lvl3","url":"/l04-02-weighted-graphs#implementation","position":18},{"hierarchy":{"lvl1":"Weighted Graphs","lvl3":"Implementation","lvl2":"Shortest Paths"},"content":"Let’s now implement the algorithm!\n\nWe’ll walk you through our implementation\n\ncost(W, J, n, v) = W[v, n] + J[n]\n\nfunction compute_J(G::SimpleWeightedDiGraph, dest_node::Int)\n    N = nv(G)\n    # step 1. start with zeros\n    i = 0\n    Ji = zeros(N)\n\n    next_J = zeros(N)\n\n    W = weights(G)\n\n    done = false\n    while !done\n        i += 1\n        for v in 1:N\n            if v == dest_node\n                next_J[v] = 0\n                continue\n            end\n            F_v = neighbors(G, v)\n            costs = [cost(W, Ji, n, v) for n in F_v]\n            next_J[v] = minimum(costs)\n        end\n        done = all(next_J .≈ Ji)\n        copy!(Ji, next_J)\n    end\n    Ji\nend\n\ncompute_J(G3, 7)\n\n","type":"content","url":"/l04-02-weighted-graphs#implementation","position":19},{"hierarchy":{"lvl1":"Weighted Graphs","lvl2":"Exercise: Shortest Path"},"type":"lvl2","url":"/l04-02-weighted-graphs#exercise-shortest-path","position":20},{"hierarchy":{"lvl1":"Weighted Graphs","lvl2":"Exercise: Shortest Path"},"content":"Let’s now combine the two functions to compute a shortest path (and associated cost) for a graph\n\nYour task is to fill in the function below and get the test to pass\n\n\"\"\"\nGiven a weighted graph `G`, enumerate a shortest path between `start_node` and `end_node`\n\"\"\"\nfunction shortest_path(G::SimpleWeightedDiGraph, start_node::Int, end_node::Int)\n    # your code here\nend\n\n","type":"content","url":"/l04-02-weighted-graphs#exercise-shortest-path","position":21},{"hierarchy":{"lvl1":"Weighted Graphs","lvl2":"Summary"},"type":"lvl2","url":"/l04-02-weighted-graphs#summary","position":22},{"hierarchy":{"lvl1":"Weighted Graphs","lvl2":"Summary"},"content":"Weighted graphs allow us to analyze the cost of travsersing paths\n\nApplied in situations like traffic flows (on physical roads/bridges), resource planning, supply chain, international trade (weights as tarrifs), and more\n\nProgramming skills...\n\nWe built up an algorithm shortest_path using two smaller routines: traverse_graph, compute_J\n\nFor each of the 3 functions we were able to write tests to verify code correctness\n\nGood habit to break a hard problem into smaller sub-problems that can be implemented/tested separately\n\nThen compose overall routine using functions for sub-problems\n\nNot all practitioners do this... we’ve seen some scary notebooks and scripts... don’t do that... you know better","type":"content","url":"/l04-02-weighted-graphs#summary","position":23},{"hierarchy":{"lvl1":"Structural Balance"},"type":"lvl1","url":"/l04-03-structural-balance","position":0},{"hierarchy":{"lvl1":"Structural Balance"},"content":"Prerequisites\n\nIntroduction to Graphs\n\nStrong and Weak Ties\n\nWeighted Graphs\n\nOutcomes\n\nUnderstand the structural balance property for sets of three nodes\n\nUnderstand the structural balance theorem for a graph\n\nRecognize structural balance in a weighted graph\n\nReferences\n\nEasley and Kleinberg chapter 5 (especially section 5.1-5-3)\n\n","type":"content","url":"/l04-03-structural-balance","position":1},{"hierarchy":{"lvl1":"Structural Balance","lvl2":"Introduction"},"type":"lvl2","url":"/l04-03-structural-balance#introduction","position":2},{"hierarchy":{"lvl1":"Structural Balance","lvl2":"Introduction"},"content":"We now shift our discussion to the notion of whether or not a network is balanced\n\nFor this discussion we will use weighted graphs, where weights are one of\n\n1: if nodes are friends (also called +)\n\n0: if they don’t know eachother\n\n-1: if nodes are enemies (also called -)\n\nWe won’t consider strength of ties right now\n\nWe will also limit discussion to complete graphs (cliques) where all nodes are connected to all other nodes\n\n","type":"content","url":"/l04-03-structural-balance#introduction","position":3},{"hierarchy":{"lvl1":"Structural Balance","lvl2":"Balance in Triangles"},"type":"lvl2","url":"/l04-03-structural-balance#balance-in-triangles","position":4},{"hierarchy":{"lvl1":"Structural Balance","lvl2":"Balance in Triangles"},"content":"To start thinking about balance, consider the possible configurations of + and - edges in a triangle\n\nThere are 4 options as shown below\n\n\n\nIn (a) all people are friends -- this is happy and balanced\n\nIn (c) A-B are friends with a common enemy C -- nobody has reason to change alliances => balanced\n\nIn (b) A is friends with B and C, but they are enemies -- B and C may try to flip A against other => not balanced\n\nIn (d) all are enemies -- two parties have incentive to team up against common enemy => not balanced\n\n","type":"content","url":"/l04-03-structural-balance#balance-in-triangles","position":5},{"hierarchy":{"lvl1":"Structural Balance","lvl2":"Balance In Graphs"},"type":"lvl2","url":"/l04-03-structural-balance#balance-in-graphs","position":6},{"hierarchy":{"lvl1":"Structural Balance","lvl2":"Balance In Graphs"},"content":"This definition of balance in triangles can be extended to graphs\n\nA complete graph G satisfies the Structural Balance Property if for every set of three nodes, exactly one or three of the edges is labeled +\n\n","type":"content","url":"/l04-03-structural-balance#balance-in-graphs","position":7},{"hierarchy":{"lvl1":"Structural Balance","lvl3":"Implications: Balance Theorem","lvl2":"Balance In Graphs"},"type":"lvl3","url":"/l04-03-structural-balance#implications-balance-theorem","position":8},{"hierarchy":{"lvl1":"Structural Balance","lvl3":"Implications: Balance Theorem","lvl2":"Balance In Graphs"},"content":"One implication of the Structural Balance Property is the Balance Theorem\n\nIf a labeled complete graph is balanced, then either all pairs of nodes are friends, or else the nodes can be divided into two groups, X and Y , such that every pair of nodes in X like each other, every pair of nodes in Y like each other, and everyone in X is the enemy of everyone in Y .\n\nNotice the strength of the statement: either all + or two mutually exclusive groups of friends that are all enemies with other group\n\n","type":"content","url":"/l04-03-structural-balance#implications-balance-theorem","position":9},{"hierarchy":{"lvl1":"Structural Balance","lvl3":"Proving Balance Theorem","lvl2":"Balance In Graphs"},"type":"lvl3","url":"/l04-03-structural-balance#proving-balance-theorem","position":10},{"hierarchy":{"lvl1":"Structural Balance","lvl3":"Proving Balance Theorem","lvl2":"Balance In Graphs"},"content":"We will provide some intuition for how to prove the Balance Theorem, which will help us understand why it is true\n\nConsider a complete Graph G\n\nTwo alternative cases:\n\nEveryone is friends: satisfies theorem by definition\n\nThere are some + and some - edges: need to prove\n\nFor case 2, we must be able to split G into X and Y where the following hold\n\nEvery node in X is friends with every other node in X\n\nEvery node in Y is friends with every other node in Y\n\nEvery node in X is enemies with every node in Y\n\n","type":"content","url":"/l04-03-structural-balance#proving-balance-theorem","position":11},{"hierarchy":{"lvl1":"Structural Balance","lvl3":"Proof by construction","lvl2":"Balance In Graphs"},"type":"lvl3","url":"/l04-03-structural-balance#proof-by-construction","position":12},{"hierarchy":{"lvl1":"Structural Balance","lvl3":"Proof by construction","lvl2":"Balance In Graphs"},"content":"Start with complete, balanced graph G (our only assumption!)\n\nWe will prove the balance theorem by constructing sets X and Y and verifying that the members of these sets satisfy the 3 properties outlined above\n\nTo start, pick any node A \\in G\n\nDivide all other nodes that are friends with A into X and enemies into Y\n\nBecause G is complete, this is all nodes\n\n","type":"content","url":"/l04-03-structural-balance#proof-by-construction","position":13},{"hierarchy":{"lvl1":"Structural Balance","lvl4":"Condition 1: \\forall B, C \\in X \\quad B \\rightarrow C = +","lvl3":"Proof by construction","lvl2":"Balance In Graphs"},"type":"lvl4","url":"/l04-03-structural-balance#condition-1-forall-b-c-in-x-quad-b-rightarrow-c","position":14},{"hierarchy":{"lvl1":"Structural Balance","lvl4":"Condition 1: \\forall B, C \\in X \\quad B \\rightarrow C = +","lvl3":"Proof by construction","lvl2":"Balance In Graphs"},"content":"Let B, C \\in X\n\nWe know A \\rightarrow B = + and A \\rightarrow C = +\n\nBecause graph is balanced, this triangle must have 1 or 3 +\n\nThere are already 2, so it must be that B \\rightarrow C = +\n\nB, C were arbitrary, so this part is proven\n\n","type":"content","url":"/l04-03-structural-balance#condition-1-forall-b-c-in-x-quad-b-rightarrow-c","position":15},{"hierarchy":{"lvl1":"Structural Balance","lvl4":"Condition 2: \\forall D, E \\in Y \\quad D \\rightarrow E = +","lvl3":"Proof by construction","lvl2":"Balance In Graphs"},"type":"lvl4","url":"/l04-03-structural-balance#condition-2-forall-d-e-in-y-quad-d-rightarrow-e","position":16},{"hierarchy":{"lvl1":"Structural Balance","lvl4":"Condition 2: \\forall D, E \\in Y \\quad D \\rightarrow E = +","lvl3":"Proof by construction","lvl2":"Balance In Graphs"},"content":"Let D, E \\in Y\n\nWe know A \\rightarrow D = - and A \\rightarrow E = -\n\nBecause graph is balanced, this triangle must have 1 or 3 +\n\nThere no + and only one option left, so it must be that D \\rightarrow E = +\n\nD, E were arbitrary, so this part is proven\n\n","type":"content","url":"/l04-03-structural-balance#condition-2-forall-d-e-in-y-quad-d-rightarrow-e","position":17},{"hierarchy":{"lvl1":"Structural Balance","lvl4":"Condition 3: \\forall B \\in X and E \\in Y \\quad B \\rightarrow E = -","lvl3":"Proof by construction","lvl2":"Balance In Graphs"},"type":"lvl4","url":"/l04-03-structural-balance#condition-3-forall-b-in-x-and-e-in-y-quad-b-rightarrow-e","position":18},{"hierarchy":{"lvl1":"Structural Balance","lvl4":"Condition 3: \\forall B \\in X and E \\in Y \\quad B \\rightarrow E = -","lvl3":"Proof by construction","lvl2":"Balance In Graphs"},"content":"Let B \\in X and D \\in Y\n\nWe know A \\rightarrow D = - and A \\rightarrow B = +\n\nBecause graph is balanced, this triangle must have 1 or 3 +\n\nThere is one + (A \\rightarrow B) and only one option left, so it must be that B \\rightarrow D = -\n\nB, D were arbitrary, so this part is proven\n\n","type":"content","url":"/l04-03-structural-balance#condition-3-forall-b-in-x-and-e-in-y-quad-b-rightarrow-e","position":19},{"hierarchy":{"lvl1":"Structural Balance","lvl3":"Summary","lvl2":"Balance In Graphs"},"type":"lvl3","url":"/l04-03-structural-balance#summary","position":20},{"hierarchy":{"lvl1":"Structural Balance","lvl3":"Summary","lvl2":"Balance In Graphs"},"content":"We’ve just proven that for any complete, balanced graph G; we can partition G into sets X and Y that satisfy the group structure of all friends or two groups of friends\n\nThis has interesting implications for fields like social interactions, international relations, and online behavior\n\n","type":"content","url":"/l04-03-structural-balance#summary","position":21},{"hierarchy":{"lvl1":"Structural Balance","lvl2":"Application: International Relations"},"type":"lvl2","url":"/l04-03-structural-balance#application-international-relations","position":22},{"hierarchy":{"lvl1":"Structural Balance","lvl2":"Application: International Relations"},"content":"Consider the evolution of alliances in Europe between 1872 and 1907 as represented in the graphs below\n\n","type":"content","url":"/l04-03-structural-balance#application-international-relations","position":23},{"hierarchy":{"lvl1":"Production Networks"},"type":"lvl1","url":"/l05-01-production-networks","position":0},{"hierarchy":{"lvl1":"Production Networks"},"content":"Prerequisites\n\nIntroduction to Graphs\n\nWeighted Graphs\n\nOutcomes\n\nRecall the key concepts of spectral theory from Linear Algebra\n\nDesribe the key proprties of the Leintief family of production models\n\nExplain the difference between “in”-based centrality and “out”-based centrality\n\nAnalyze the impact of sector specific shocks on other sectors of the US economy\n\nReferences\n\nQuantEcon Networks chapters 1-2  (especially section 1.2)\n\n","type":"content","url":"/l05-01-production-networks","position":1},{"hierarchy":{"lvl1":"Production Networks","lvl2":"Linear Algebra"},"type":"lvl2","url":"/l05-01-production-networks#linear-algebra","position":2},{"hierarchy":{"lvl1":"Production Networks","lvl2":"Linear Algebra"},"content":"Linear algebra is the backbone of modern computational algorithms\n\nGraphics\n\nStatistics\n\nData analysis\n\nOptimization\n\nMachine Learning\n\nWorkhorse for accelerated computing\n\nGPUs work on matrices to efficiently parallellize common computations\n\nSpecialty hardware like the TPU (tensor processing unit) take this even further\n\n","type":"content","url":"/l05-01-production-networks#linear-algebra","position":3},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Building Blocks","lvl2":"Linear Algebra"},"type":"lvl3","url":"/l05-01-production-networks#building-blocks","position":4},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Building Blocks","lvl2":"Linear Algebra"},"content":"Vectors: arrays of numbers representing points in multi-dimensional space\n\nMatrices\n\nRectangular arrays that transform vectors\n\nAlso used to represent certain datasets/relationships: e.g. adjacency matrix in Graph Theory\n\nTensors: higher dimensional collections of numbers that allow high-dimensional\n\nVectors are 1d tensors, matrices 2d tensors, etc.\n\nImplemented in numpy as np.array and Julia as the build in array\n\n","type":"content","url":"/l05-01-production-networks#building-blocks","position":5},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Some Key Theories","lvl2":"Linear Algebra"},"type":"lvl3","url":"/l05-01-production-networks#some-key-theories","position":6},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Some Key Theories","lvl2":"Linear Algebra"},"content":"Linear systems of equations\n\nInner product spaces (length, distance, and angles)\n\nEigenvalues and eigen vectors (spectral theory)\n\n","type":"content","url":"/l05-01-production-networks#some-key-theories","position":7},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Spectral Theory","lvl2":"Linear Algebra"},"type":"lvl3","url":"/l05-01-production-networks#spectral-theory","position":8},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Spectral Theory","lvl2":"Linear Algebra"},"content":"Let’s dig into eigenvalues and eigenvectors\n\nLet A \\in \\mathbb{R}^{n \\times n}\n\nA scalar \\lambda \\in \\mathbb{C} is an eigenvalue of A if there exists a nonzero vector e \\in \\mathbb{C}^n such that A e = \\lambda e\n\nA vector e satisfying this equality is called an eigenvector corresponding to the eigenvalue \\lambda\n\nA vector \\epsilon sastifying A ' \\epsilon = \\lambda \\epsilon is a left-eigenvector of A\n\nusing LinearAlgebra\n\nA = [\n    0 -1\n    1 0\n]\neigvals(A)\n\n","type":"content","url":"/l05-01-production-networks#spectral-theory","position":9},{"hierarchy":{"lvl1":"Production Networks","lvl4":"Definitions","lvl3":"Spectral Theory","lvl2":"Linear Algebra"},"type":"lvl4","url":"/l05-01-production-networks#definitions","position":10},{"hierarchy":{"lvl1":"Production Networks","lvl4":"Definitions","lvl3":"Spectral Theory","lvl2":"Linear Algebra"},"content":"The set of all eigenvalues of A is called the spectrum of A and is written \\sigma(A)\n\nThe spectral radius of A is written r(A) \\equiv \\max \\{ | \\lambda | : \\lambda \\in \\sigma(A) \\}\n\nThe spectral radius important when considering the convergence of a dynamic system driven by A\n\nIf x_{t+1} = A x_t and r(A)< 1 then the sequence \\{x\\}_t is finite and will converge\n\nSome facts (not proven here)\n\nA will have at most n distinct eigenvalues\n\nEigenvectors are only unique to a scalar multiple: if (\\lambda, e) is an eigenpair, then so is (\\lambda, \\alpha e) for any \\alpha \\in \\mathbb{R}, \\alpha \\ne 0\n\nSometimes a matrix will have a repeated eigenvalue (the same value works with multiple distinct eigenvectors)\n\nThe algebraic multiplicity of an eigenvalue is the number of times it is repeated with distinct eigenvectors\n\nAn eigenvalue with an algebraic multiplicity of one is called simple\n\n","type":"content","url":"/l05-01-production-networks#definitions","position":11},{"hierarchy":{"lvl1":"Production Networks","lvl4":"Diagonalization","lvl3":"Spectral Theory","lvl2":"Linear Algebra"},"type":"lvl4","url":"/l05-01-production-networks#diagonalization","position":12},{"hierarchy":{"lvl1":"Production Networks","lvl4":"Diagonalization","lvl3":"Spectral Theory","lvl2":"Linear Algebra"},"content":"A matrix A \\in \\mathbb{R}^{n \\times n} is diagonalizable if A = PDP^{-1}\n\nD = \\text{diag}(\\lambda_1, \\dots, \\lambda_n), P is some invertible matrix\n\nThe decomposition is called the eigen decomposition or spectral decomposition of A\n\nThe asymptotic properties of m \\mapsto A^m are determined by \\sigma(A)\n\nCan be seen when A is diagonalizable\n\nIf A = P \\text{diag}(\\lambda) P^{-1} \\Longrightarrow A^m = P \\text{diag}(\\lambda_i^m) P^{-1}\n\n","type":"content","url":"/l05-01-production-networks#diagonalization","position":13},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Example: Worker Dynamics","lvl2":"Linear Algebra"},"type":"lvl3","url":"/l05-01-production-networks#example-worker-dynamics","position":14},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Example: Worker Dynamics","lvl2":"Linear Algebra"},"content":"Consider a continuum of workers (large number, not counted discretely)\n\nWorkers can be in one of two states: (1) employed and (2) unemployed\n\nEach month workers are hired at a rate \\alpha and fired at a rate \\beta\n\nWe express these dynamics as a weighted directed graph with adjacency matrix:P_w = \\begin{bmatrix}1-\\alpha & \\alpha \\\\ \\beta & 1-\\beta \\end{bmatrix} \\; \\alpha, \\beta \\in [0, 1]\n\nRow 1 gives the probabilities of employment and unemployement for an employed worker\n\nRow 2 gives the probabilities of employment and unemployement for an unemployed worker\n\n","type":"content","url":"/l05-01-production-networks#example-worker-dynamics","position":15},{"hierarchy":{"lvl1":"Production Networks","lvl4":"Transitions","lvl3":"Example: Worker Dynamics","lvl2":"Linear Algebra"},"type":"lvl4","url":"/l05-01-production-networks#transitions","position":16},{"hierarchy":{"lvl1":"Production Networks","lvl4":"Transitions","lvl3":"Example: Worker Dynamics","lvl2":"Linear Algebra"},"content":"Suppose we have a vector x \\in \\Delta(2) (2 element simplex) representing current fraction of workers that are employed and unemployed\n\nQuestion... What matrix operation between P_w and x will give the fraction of workers that start next month as employed and unemployed?\n\nalpha = 0.3\nbeta = 0.1\n\nP = [1-alpha alpha; beta 1-beta]\n\nx = [0.9, 0.1]\n\n# TODO: simulate for many periods\n\n# TODO: compare to largest left eigenvector\n\n","type":"content","url":"/l05-01-production-networks#transitions","position":17},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Neumann Series Lemma","lvl2":"Linear Algebra"},"type":"lvl3","url":"/l05-01-production-networks#neumann-series-lemma","position":18},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Neumann Series Lemma","lvl2":"Linear Algebra"},"content":"We need one more linear alegbra result...\n\nIf A \\in \\mathbb{R}^{n \\times n} and r(A) < 1, then I-A is non-singular and (I-A)^{-1} = \\sum_{m=0}^{\\infty} A^m\n\nThis is known as the Neumann series lemma\n\n","type":"content","url":"/l05-01-production-networks#neumann-series-lemma","position":19},{"hierarchy":{"lvl1":"Production Networks","lvl2":"Production Networks"},"type":"lvl2","url":"/l05-01-production-networks#production-networks","position":20},{"hierarchy":{"lvl1":"Production Networks","lvl2":"Production Networks"},"content":"We will now study a family of economic models that allow us to analyze the economy as a collection of sectors\n\nThese models were proposed by nobel prize winner Wassily Leontief in 1941 and are still commonly used today\n\nThe key idea behind a Leontief model is the input-output table\n\n","type":"content","url":"/l05-01-production-networks#production-networks","position":21},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Input-output tables","lvl2":"Production Networks"},"type":"lvl3","url":"/l05-01-production-networks#input-output-tables","position":22},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Input-output tables","lvl2":"Production Networks"},"content":"Firms (companies) are categorized into n distinct sectors\n\nFirms use materials produced by other sectors as part of their production process\n\nThe relationship of flows of value are organized into an input/output table\n\n\n\nsector 1\n\nsector 2\n\nsector 3\n\nsector 1\n\na_{11}\n\na_{12}\n\na_{13}\n\nsector 2\n\na_{21}\n\na_{22}\n\na_{23}\n\nsector 3\n\na_{31}\n\na_{32}\n\na_{33}\n\na_{ij} is called an input-output coefficient and is equal to:a_{ij} = \\frac{\\text{value of sector j inputs purchased from sector i}}{\\text{total sales of sector j}}\n\nIf a_{ij} is large, sector i is an important supplier of intermediate goods to sector j\n\nThe sum of column j is the value of all inputs to sector j\n\nRow i shows how intensively each sector uses good i as an intermediate good\n\nThe input output table can be directly used as the adjacency matrix for a weighted directed graph\n\n","type":"content","url":"/l05-01-production-networks#input-output-tables","position":23},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Input-output data","lvl2":"Production Networks"},"type":"lvl3","url":"/l05-01-production-networks#input-output-data","position":24},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Input-output data","lvl2":"Production Networks"},"content":"In the United States, the Bureau of Economic Analysis is responsible for compiling input-output tables for sectors\n\nWe’ll be studying the \n\nInput-Output Accounts Data\n\nThe main set of tables we’ll be using are called the Make-Use tables\n\nThe Make table shows the value of final goods produced by each sector\n\nNote this is predominately a diagonal matrix as each sector primarily produces and sells final goods within their sector\n\nSometimes a firm will have secondary outputs as part of their production process\n\n“Which industries produce which commodities?”\n\nThe Use tables show the intermediate and final use of commodities across sectors\n\n“Who uses or consumes the commodities produced?”\n\nusing CSV, DataFrames, Graphs, SimpleWeightedGraphs, GraphPlot, ColorSchemes, Colors, Downloads, PlotlyBase\n\nusing Downloads\n\nfunction read_remote_csv(url)\n    bn = basename(url)\n    if !isfile(bn)\n        Downloads.download(url, bn)\n    end\n    CSV.read(bn, DataFrame)\nend\n\nmake_15 = read_remote_csv(\"https://compsosci-resources.s3.amazonaws.com/graph-theory-lectures/data/QE-networks/make_15.csv\");\nuse_15 = read_remote_csv(\"https://compsosci-resources.s3.amazonaws.com/graph-theory-lectures/data/QE-networks/use_15.csv\");\ncodes = read_remote_csv(\"https://compsosci-resources.s3.amazonaws.com/graph-theory-lectures/data/QE-networks/codes.csv\");\n\n","type":"content","url":"/l05-01-production-networks#input-output-data","position":25},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Example: US 15 sector data","lvl2":"Production Networks"},"type":"lvl3","url":"/l05-01-production-networks#example-us-15-sector-data","position":26},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Example: US 15 sector data","lvl2":"Production Networks"},"content":"\n\nColor of nodes is according to their hub-based eigenvector centrality (see below)\n\nSize of nodes is according to their total outputs (make table)\n\nThickness of edges is according to amount of goods\n\nRepresent a_{ij} and point from sector creating the intermediate good (sector i) to sector  using intermediate good (sector j)\n\n\n\n","type":"content","url":"/l05-01-production-networks#example-us-15-sector-data","position":27},{"hierarchy":{"lvl1":"Production Networks","lvl4":"Eigenvector Centrality","lvl3":"Example: US 15 sector data","lvl2":"Production Networks"},"type":"lvl4","url":"/l05-01-production-networks#eigenvector-centrality","position":28},{"hierarchy":{"lvl1":"Production Networks","lvl4":"Eigenvector Centrality","lvl3":"Example: US 15 sector data","lvl2":"Production Networks"},"content":"The node size above shows the hub-based eigenvector centrality\n\nThis is equal to the dominant eigenvector of the adjacency matrix (eigenvector associated with largest eigenvalue)\n\nThis measure of centrality measures the influence of a node in a network\n\nWhen computing this statistic for a node N, the value will be higher if it is connected to other “influential” nodes\n\nhttps://​youtu​.be​/LYyZqlyDEL4​?si​=​x2kYhe3phZxQtQvV​&​t​=​202\n\n","type":"content","url":"/l05-01-production-networks#eigenvector-centrality","position":29},{"hierarchy":{"lvl1":"Production Networks","lvl4":"Example","lvl3":"Example: US 15 sector data","lvl2":"Production Networks"},"type":"lvl4","url":"/l05-01-production-networks#example","position":30},{"hierarchy":{"lvl1":"Production Networks","lvl4":"Example","lvl3":"Example: US 15 sector data","lvl2":"Production Networks"},"content":"Let’s compute the eigenvector centrality for the data in the image above\n\nI have some code to import the make/use files into a helpful struct\n\nWe’ll see what all the fields are as we progress through the lecture\n\nto_int(x) = parse(Int, x)\nto_int(x::Integer) = Int(x)\n\nstruct SectorData\n    Z::Matrix{Int}\n    X::Vector{Int}\n    A::Matrix{Float64}\n    F::Matrix{Float64}\n    Z_df::DataFrame\n    names::Vector{String}\n    codes::Vector{String}\n    N::Int\n    G::SimpleWeightedDiGraph{Int64, Float64}\nend\n\nconst CODES = let\n    df = read_remote_csv(\"codes.csv\")\n    Dict(zip(df.name, df.code))\nend\n\nfunction load_sector(N)\n    # read csv\n    df = CSV.read(\"use_$(N).csv\", DataFrame)\n\n    # replace `---` with `0`\n    df .= ifelse.(df .== \"---\", \"0\", df)\n\n    # conver to int\n    df[!, 2:end] .= to_int.(df[!, 2:end])\n\n    # first column is industry name, next columns are sector values\n    # first N rows are values\n    Z = Array(df[1:N, 2:(N+1)])\n    names = df[1:N, 1]\n    codes = [CODES[n] for n in names]\n\n    # total industry outputs come from teh `make_N.csv` file\n    X = CSV.read(\"make_$(N).csv\", DataFrame)[1:N, \"Total Industry Output\"]\n\n    # value of sector j's inputs purchased from i / sales of `j`\n    # or ...\n    A = Z ./ X'\n\n    F = Z ./ X\n\n    # make copy of A where small values are set to zero to make plotting clearer\n    A_copy = copy(A)\n    A_copy[A .<= 0.01] .= 0;\n    G = SimpleWeightedDiGraph(A_copy)\n\n    SectorData(Z, X, A, F, df, names, codes, N, G)\nend\n\ndata15 = load_sector(15);\n\nlambda15 = eigenvector_centrality(data15.G)\n\nPlot(bar(x=data15.codes, y=lambda15))\n\n","type":"content","url":"/l05-01-production-networks#example","position":31},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Accounting","lvl2":"Production Networks"},"type":"lvl3","url":"/l05-01-production-networks#accounting","position":32},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Accounting","lvl2":"Production Networks"},"content":"Let...\n\nd_i be the final consumer demand for good i\n\nx_i be total sales of sector i\n\nz_{ij} be inter-industry sales from sector i to sector j\n\nFor accounts to add up we must have x_i = \\sum_{j=1}^n z_{ij} + d_i\n\nNotice that \\frac{z_{ij}}{x_j} = a_{ij} = \\text{dollar value of inputs from $i$ per dollar output from $j$}\n\nThis means x_i = \\sum_{j=1} a_{ij} x_j + d_i\n\nWhich can be written x = Ax + d\n\n","type":"content","url":"/l05-01-production-networks#accounting","position":33},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Equilibrium","lvl2":"Production Networks"},"type":"lvl3","url":"/l05-01-production-networks#equilibrium","position":34},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Equilibrium","lvl2":"Production Networks"},"content":"An equilibrium in a Leonteif model with input-output coefficient matrix A and a vector d \\in \\mathbb{R}^n of final consumer demands for each sector is a vector x for sector-specific output such that x = Ax + d is satisfied\n\nNote that d and A are treated as given\n\nTo find this vector requires that we trace the impact of final demand on the intermediate linkages through A\n\nExample:\n\nExample\n\nSuppose d_3 \\uparrow\n\nWill cause 3 to consume more from its suppliers (2 and 4)\n\nWhich will cause 2 to demand more from 1\n\nWhich will cause 1 to demand more from 2 and 4\n\n... and so on\n\nComputing an equilibrium is not entirely straight forward...\n\n","type":"content","url":"/l05-01-production-networks#equilibrium","position":35},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Computing an Equilibrium","lvl2":"Production Networks"},"type":"lvl3","url":"/l05-01-production-networks#computing-an-equilibrium","position":36},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Computing an Equilibrium","lvl2":"Production Networks"},"content":"Define v_j \\equiv x_j - \\sum_{i=1}^n z_{ij} as the value added by sector j\n\nAssumption: The input-output adjacency matrix A satisfies \\eta_j \\equiv \\sum_{i=1}^n a_{ij} < 1 \\; \\forall j \\in [n]\n\nThis holds whenever v_j > 0 \\forall j\n\nWhen this assumption holds, for each d \\ge 0 there is a unique, nonnegative output solution given by x^* = Ld \\qquad \\text{where } L \\equiv (I-A)^{-1}\n\nThe matrix L is called the Leontief inverse associated with the coefficient matrix A\n\nL15 = inv(I - data15.A)\n\n# propose a demand vector where each element is between [100, 600]\nd = rand(15).* 500 .+ 100\n\nL15 * d\n\nQuestion\n\nWe don’t have a field for d in our SectorData struct.\n\nHow could we compute/derive d given the fields we do have?\n\nfieldnames(SectorData)\n\n","type":"content","url":"/l05-01-production-networks#computing-an-equilibrium","position":37},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Demand Shocks","lvl2":"Production Networks"},"type":"lvl3","url":"/l05-01-production-networks#demand-shocks","position":38},{"hierarchy":{"lvl1":"Production Networks","lvl3":"Demand Shocks","lvl2":"Production Networks"},"content":"A common form of economic analysis is to consider the impact of external “shocks”\n\nOften, these are modeled as a one time change in the value of a variable\n\nLet’s consider a demand shock of size \\Delta d such that demand moves from d_0 to d_1 = \\Delta d + d_0\n\nThe equilibrium vector shifts from x_0 = L d_0 to x_1 = L d_1\n\nDefine \\Delta x = L (d_1 - d_0) = L \\delta d\n\n","type":"content","url":"/l05-01-production-networks#demand-shocks","position":39},{"hierarchy":{"lvl1":"Production Networks","lvl3":"NSL","lvl2":"Production Networks"},"type":"lvl3","url":"/l05-01-production-networks#nsl","position":40},{"hierarchy":{"lvl1":"Production Networks","lvl3":"NSL","lvl2":"Production Networks"},"content":"We will further assume that r(A)<1 so that we can write the expression for \\Delta x as an infinite sum using the Neumann Series Lemma: \\Delta x = \\Delta d + A (\\Delta d) + A^2 (\\Delta d) + \\cdots\n\n\\Delta d is the initial response in each sector,\n\nA (\\Delta d) is the response generated by the first round of backward linkages,\n\nA^2 (\\Delta d) is the response generated by the second round, and so on.\n\nThe total response is the sum of the responses at each round\n\nThe typical element l_{ij} of L = \\sum_{m=0}^{\\infty} A^m shows total impact on sector i of a unit change in the demand for good j\n\nL15\n\nPlot(heatmap(z=L15))","type":"content","url":"/l05-01-production-networks#nsl","position":41},{"hierarchy":{"lvl1":"Agent Based Models"},"type":"lvl1","url":"/l06-01-abm-concepts","position":0},{"hierarchy":{"lvl1":"Agent Based Models"},"content":"Computational Analysis of Social Complexity\n\nPrerequisites\n\nNone 😏\n\nOutcomes\n\nUnderstand what a model is\n\nKnow the difference between what we call equation based models and agent based models\n\nUnderstand the key building blocks of agent based models\n\nLearn the key components of the Schelling segregation model\n\nReferences\n\nCioffi-Revilla Chapter 10\n\nhttps://​journal​.sohostrategy​.com​/what​-does​-an​-agent​-based​-model​-look​-like​-dc1fbc17f2f5\n\nhttps://​journal​.sohostrategy​.com​/what​-is​-abm​-abms​-f52ff2f1f712\n\nhttps://​towardsdatascience​.com​/agent​-based​-modeling​-will​-unleash​-a​-new​-paradigm​-of​-machine​-learning​-ff6d3b1ac940​?source​=​search​_post​-​-​-​-​-​-​-​--3\n\n","type":"content","url":"/l06-01-abm-concepts","position":1},{"hierarchy":{"lvl1":"Agent Based Models","lvl2":"Why Models?"},"type":"lvl2","url":"/l06-01-abm-concepts#why-models","position":2},{"hierarchy":{"lvl1":"Agent Based Models","lvl2":"Why Models?"},"content":"Many topics of interest for social scientists are either unethical or unreasonable to study in a laboratory\n\nImpact on communities of upsurge in illicit drug usage (can’t give people drugs to see impact)\n\nFlow of traffic given a new infrastructure updates (too costly to experiment with)\n\nImpact of new tariffs in international trading relationships (too costly to coordinate legislation and implement)\n\nFor this reason, we as social scientists turn to models to study our problems\n\nA model is a probability distribution over outcomes\n\nI’ll repeat for emphasis: a model is a probability distribution over outcomes\n\nExample: A model of housing prices doesn’t predict your house will sell for exactly $350,000\n\nInstead, it might say there’s a 60% chance it sells between 340,000-360,000, 30% chance between 320,000-340,000, etc.\n\nThe model describes the likelihood of different outcomes, not a single deterministic answer\n\n","type":"content","url":"/l06-01-abm-concepts#why-models","position":3},{"hierarchy":{"lvl1":"Agent Based Models","lvl3":"Types of Models","lvl2":"Why Models?"},"type":"lvl3","url":"/l06-01-abm-concepts#types-of-models","position":4},{"hierarchy":{"lvl1":"Agent Based Models","lvl3":"Types of Models","lvl2":"Why Models?"},"content":"A model is a mathematical object: equations, rules, distributional assumptions.\n\nAt its heart, a model is a simplification of some real-world system or phenomenon\n\nMuch complexity is abstracted away (or not included directly in model)\n\nKey aspects relevant for study are modeled explicitly (e.g. trading response to tariffs)\n\nFor our purposes, we will think of models as belonging to one of two families\n\nEquation based models\n\nAgent based models\n\nThis is a simplification and not a perfect classification (because equation based models have agents and agent based models have equations), but we will be able to draw useful distinctions with this classification.\n\n","type":"content","url":"/l06-01-abm-concepts#types-of-models","position":5},{"hierarchy":{"lvl1":"Agent Based Models","lvl3":"Equation Based Models","lvl2":"Why Models?"},"type":"lvl3","url":"/l06-01-abm-concepts#equation-based-models","position":6},{"hierarchy":{"lvl1":"Agent Based Models","lvl3":"Equation Based Models","lvl2":"Why Models?"},"content":"An equation based model describes the decision making setting for each agent using mathematical equations\n\nTypically, these are posed as (constrained) optimization problems\n\nA set of equations is also developed that describe interaction between agents\n\nThese equations can feature random variables and will require specification of model parameters\n\nMost models I study and develop in my economics research are equation based\n\nPros:\n\nAllow precise specification of assumptions, incentives, and outcomes\n\nHave wide toolbox of numerical optimization, and statistical fitting to “solve” model\n\nCons:\n\nOptimization and calibration of parameters can be very difficult\n\nOften subject to the “curse of dimensionality”, which limits size and complexity of model\n\n","type":"content","url":"/l06-01-abm-concepts#equation-based-models","position":7},{"hierarchy":{"lvl1":"Agent Based Models","lvl3":"Agent Based Models (ABMs)","lvl2":"Why Models?"},"type":"lvl3","url":"/l06-01-abm-concepts#agent-based-models-abms","position":8},{"hierarchy":{"lvl1":"Agent Based Models","lvl3":"Agent Based Models (ABMs)","lvl2":"Why Models?"},"content":"An agent based model describes rules for how individual agents respond to their environment\n\nThere are usually many agents, each with a set of properties\n\nOne common property is the type of the agent: usually drawn from a small/finite set (buyer-seller, parent-child-teacher, sheep-wolf)\n\nAll agents of the same type have the same set of additional properties\n\nEach agent has a state at each time step t\n\nThe rules are equations that specify how the state of an agent is updated between periods t and t+1\n\nRules are common for all agents of a type, but vary based on that agent’s state and property values\n\nRules will often have random variables as well as parameters\n\nRules often include notion of “neighboring” agents\n\nPros:\n\nFocus on how an individual should respond in a given state without requiring optimization\n\nBecause rules are typically mathematically simple, can have many many agents\n\nCons:\n\nOften lacks notion of equilibrium (could be a feature)\n\nNot very “reusable” -- to study specific topic you usually have to create whole new model\n\nSometimes \n\ntoo many parameters: need for careful calibration\n\n","type":"content","url":"/l06-01-abm-concepts#agent-based-models-abms","position":9},{"hierarchy":{"lvl1":"Agent Based Models","lvl3":"Example: Farmer’s Market Pricing","lvl2":"Why Models?"},"type":"lvl3","url":"/l06-01-abm-concepts#example-farmers-market-pricing","position":10},{"hierarchy":{"lvl1":"Agent Based Models","lvl3":"Example: Farmer’s Market Pricing","lvl2":"Why Models?"},"content":"Consider modeling prices at a local farmer’s market for tomatoes:\n\nEquation-based approach:\n\nDefine supply and demand curves\n\nSolve for equilibrium price where supply equals demand\n\nResult: Market clears at $3.50/lb with 500 lbs sold\n\nBest for: Understanding average market price, total quantity sold, analyzing policy impacts (e.g., effect of a $0.50/lb subsidy)\n\nAgent-based approach:\n\nIndividual vendors: each has costs, quality, inventory, and pricing strategy\n\nIndividual buyers: each has budget, quality preferences, and willingness to pay\n\nRules: Buyers visit stalls, compare prices/quality, purchase or move on\n\nVendors adjust prices based on remaining inventory and time of day\n\nEmergent patterns: Price dispersion, quality segments, end-of-day discounts\n\nBest for: Understanding why some vendors charge more, how relationships form, impact of vendor reputation\n\nThe equation model tells us the average outcome; the ABM shows us the rich variety of individual transactions that create that average.\n\n","type":"content","url":"/l06-01-abm-concepts#example-farmers-market-pricing","position":11},{"hierarchy":{"lvl1":"Agent Based Models","lvl2":"ABMs"},"type":"lvl2","url":"/l06-01-abm-concepts#abms","position":12},{"hierarchy":{"lvl1":"Agent Based Models","lvl2":"ABMs"},"content":"For the next few lectures we’ll focus on agent base models\n\nWe’ll start by outlining the main components of an ABM\n\nThen we’ll talk about how we could represent them in Julia using the Agents.jl library\n\nThis will require a step up in our Julia skills, so we’ll spend some time covering these concepts in greater detail\n\nFinally we’ll see a few examples of ABMs in practice\n\nNOTE: Most of the study of the Julia skills and ABM examples are not in this notebook\n\n","type":"content","url":"/l06-01-abm-concepts#abms","position":13},{"hierarchy":{"lvl1":"Agent Based Models","lvl3":"ABM components","lvl2":"ABMs"},"type":"lvl3","url":"/l06-01-abm-concepts#abm-components","position":14},{"hierarchy":{"lvl1":"Agent Based Models","lvl3":"ABM components","lvl2":"ABMs"},"content":"ABMs are made up of 3 distinct components:\n\nAgents\n\nEnvironment\n\nRules\n\n","type":"content","url":"/l06-01-abm-concepts#abm-components","position":15},{"hierarchy":{"lvl1":"Agent Based Models","lvl4":"Agents","lvl3":"ABM components","lvl2":"ABMs"},"type":"lvl4","url":"/l06-01-abm-concepts#agents","position":16},{"hierarchy":{"lvl1":"Agent Based Models","lvl4":"Agents","lvl3":"ABM components","lvl2":"ABMs"},"content":"Have state at discrete time steps t (state is value of properties, some properties might be fixed)\n\nAlways aware of its own state\n\nAutonomous: can make a decisions independent of other agents\n\nReactive: can respond to changes in environment or state of other agents\n\nProactive: can behave in a way to achieve a goal\n\nCommunicate: can make some attributes visible to other agents\n\n","type":"content","url":"/l06-01-abm-concepts#agents","position":17},{"hierarchy":{"lvl1":"Agent Based Models","lvl4":"Environments","lvl3":"ABM components","lvl2":"ABMs"},"type":"lvl4","url":"/l06-01-abm-concepts#environments","position":18},{"hierarchy":{"lvl1":"Agent Based Models","lvl4":"Environments","lvl3":"ABM components","lvl2":"ABMs"},"content":"One of two types\n\nNatural Environments: biophysical landscapes and settings\n\nArtifical environments: classrooms, economic markets, parks, transportation streets, buildings, etc.\n\nAgents reside within an environment\n\nProperties of environment can be fixed (size, dimensions) or varying (weather, congestion, unused capacity)\n\nAgents can observe and potentially respond to properties of the environment\n\n","type":"content","url":"/l06-01-abm-concepts#environments","position":19},{"hierarchy":{"lvl1":"Agent Based Models","lvl4":"Rules","lvl3":"ABM components","lvl2":"ABMs"},"type":"lvl4","url":"/l06-01-abm-concepts#rules","position":20},{"hierarchy":{"lvl1":"Agent Based Models","lvl4":"Rules","lvl3":"ABM components","lvl2":"ABMs"},"content":"Rules are the key feature that makes ABMs dynamic\n\nTypes of rules:\n\nInter-agent: how agents communicate and respond to one another (e.g. information spread)\n\nAgent-environment rules: How an agent responds to an environment (e.g. avoid park if raining), or how an agent’s decisions and behaviors impact environment (e.g. more cars => more pollution)\n\nIntra-environmental rules: cause and effect mechanisms within the environment (e.g. more rain => more vegetation)\n\n","type":"content","url":"/l06-01-abm-concepts#rules","position":21},{"hierarchy":{"lvl1":"Agent Based Models","lvl3":"Why ABMs for Social Science?","lvl2":"ABMs"},"type":"lvl3","url":"/l06-01-abm-concepts#why-abms-for-social-science","position":22},{"hierarchy":{"lvl1":"Agent Based Models","lvl3":"Why ABMs for Social Science?","lvl2":"ABMs"},"content":"ABMs are particularly powerful for social science because:\n\nNo equilibrium required: Social systems rarely reach stable equilibria\n\nFashion trends, social media virality, political movements constantly evolve\n\nHeterogeneity matters: Individual differences drive social outcomes\n\nNot everyone responds the same way to incentives or information\n\nLocal interactions dominate: Who you know matters more than population averages\n\nJob opportunities through networks, not random matching\n\nDisease spread through actual contact patterns\n\nPath dependence: History and timing matter\n\nEarly adopters can shift entire market dynamics\n\nSmall initial differences can lead to dramatically different outcomes\n\nEmergence: Simple individual rules create complex social patterns\n\nSegregation can emerge without strong individual preferences (as we’ll see with Schelling)\n\n","type":"content","url":"/l06-01-abm-concepts#why-abms-for-social-science","position":23},{"hierarchy":{"lvl1":"Agent Based Models","lvl2":"ABMs in Julia"},"type":"lvl2","url":"/l06-01-abm-concepts#abms-in-julia","position":24},{"hierarchy":{"lvl1":"Agent Based Models","lvl2":"ABMs in Julia"},"content":"We need a way to represent these three components in Julia\n\nAgents: represent as a Julia struct\n\nStruct fields record agent properties\n\nOur custom agent type can have methods that ascribe behavior to agents\n\nEnvironments: either explicitly as Julia struct or implicitly in the update rules\n\nRules: julia functions\n\nKey function is step! which will allow our agents to make decisions and have the environment and agent properties update in response\n\n","type":"content","url":"/l06-01-abm-concepts#abms-in-julia","position":25},{"hierarchy":{"lvl1":"Agent Based Models","lvl2":"Schelling Segregation Model"},"type":"lvl2","url":"/l06-01-abm-concepts#schelling-segregation-model","position":26},{"hierarchy":{"lvl1":"Agent Based Models","lvl2":"Schelling Segregation Model"},"content":"We will work on learning how to represent our agents, rules, and environment in Julia\n\nTo make that discussion more concrete, it will be helpful to have a model to implement\n\nThe “hello world” of ABMs may just be the Schelling segregation model\n\nReferences include \n\nQuantEcon and \n\nAgents.jl tutorial\n\n","type":"content","url":"/l06-01-abm-concepts#schelling-segregation-model","position":27},{"hierarchy":{"lvl1":"Agent Based Models","lvl3":"Schelling’s Work","lvl2":"Schelling Segregation Model"},"type":"lvl3","url":"/l06-01-abm-concepts#schellings-work","position":28},{"hierarchy":{"lvl1":"Agent Based Models","lvl3":"Schelling’s Work","lvl2":"Schelling Segregation Model"},"content":"Thomas Schelling won a nobel price in economics for his study of racial segregation\n\nAt the heart of his study, was a model proposed in 1969 for how racial segregation can occur in urban areas\n\nOne theme of this work (and ABMs in general) is that local interactions (like decisions of individual agents) can lead to surprising aggregate results\n\n","type":"content","url":"/l06-01-abm-concepts#schellings-work","position":29},{"hierarchy":{"lvl1":"Agent Based Models","lvl3":"The Model","lvl2":"Schelling Segregation Model"},"type":"lvl3","url":"/l06-01-abm-concepts#the-model","position":30},{"hierarchy":{"lvl1":"Agent Based Models","lvl3":"The Model","lvl2":"Schelling Segregation Model"},"content":"Environment: 25x25 grid of single family dwellings\n\nAgents with properties:\n\nlocation (x,y) coordinate for current home\n\ntype: orange or blue. Fixed over time. 250 of each\n\nhappiness: 0 if less than N of neighbors are of same type, 1 otherwise\n\nRules:\n\nAgents choose to move to unoccupied grid point if unhappy\n\nNote neighbors for a particular cell are the the 8 other cells surrounding the cell of interest. Corner or edge cells have less than 8 neighbors","type":"content","url":"/l06-01-abm-concepts#the-model","position":31},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl"},"type":"lvl1","url":"/l06-02-schelling-agents","position":0},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl"},"content":"Computational Analysis of Social Complexity\n\nPrerequisites\n\nJulia Basics (from week 2)\n\nJulia Types (from week 2)\n\nABM intro\n\nOutcomes\n\nLearn to use the Julia REPL for running interactive ABM visualizations\n\nImplement the Schelling segregation model using Agents.jl\n\nReferences\n\nAgents.jl tutorial\n\nQuantEcon lecture\n\n","type":"content","url":"/l06-02-schelling-agents","position":1},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl2":"Review Schelling Model"},"type":"lvl2","url":"/l06-02-schelling-agents#review-schelling-model","position":2},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl2":"Review Schelling Model"},"content":"Recall the components of the Schelling segregation model\n\nEnvironment: 25x25 grid of single family dwellings\n\nAgents with properties:\n\nlocation (x,y) coordinate for current home\n\ntype: orange or blue. Fixed over time. 250 of each\n\nhappiness: 0 if less than N of neighbors are of same type, 1 otherwise\n\nRules:\n\nAgents choose to move to unoccupied grid point if unhappy\n\nNote neighbors for a particular cell are the the 8 other cells surrounding the cell of interest. Corner or edge cells have less than 8 neighbors\n\n","type":"content","url":"/l06-02-schelling-agents#review-schelling-model","position":3},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl2":"Agents.jl"},"type":"lvl2","url":"/l06-02-schelling-agents#agents-jl","position":4},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl2":"Agents.jl"},"content":"We are now ready to get started implementing the Schelling segregation model in Julia\n\nWe’ll use the Agents.jl library, which is a very powerful ABM toolkit\n\nHere are some points of comparison between Agents.jl and other ABM software (from the Agents.jl website):\n\n","type":"content","url":"/l06-02-schelling-agents#agents-jl","position":5},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl2":"Schelling in Agents.jl"},"type":"lvl2","url":"/l06-02-schelling-agents#schelling-in-agents-jl","position":6},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl2":"Schelling in Agents.jl"},"content":"Let’s now implement the Schelling Segregation model in Agents.jl\n\nThe first thing we’ll need to do is define our Agent\n\nThe recommended way to do this is to create a new Julia struct using the @agent macro provided by Agents.jl\n\nThe macro will ensure a few things:\n\nThe struct contains id and pos fields to keep track of the agent and its position\n\nThe struct is mutable so the position can be updated\n\nThe struct is a subtype of AbstractAgent so it can be used by other functions in Agents.jl\n\n# load up packages we need for this example... might take a few minutes\n# import Pkg\n# Pkg.activate(\".\")\n# Pkg.instantiate()\n\nusing Agents\n\n@agent struct SchellingAgent(GridAgent{2})\n    is_happy::Bool      # whether the agent is happy in its position. (true = happy)\n    group::Int          # The group of the agent, determines mood as it interacts with neighbors 0: blue, 1: orange\nend\n\nWe can see the complete structure of the ShellingAgent type using the dump function\n\ndump(SchellingAgent)\n\n","type":"content","url":"/l06-02-schelling-agents#schelling-in-agents-jl","position":7},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Schelling Environment","lvl2":"Schelling in Agents.jl"},"type":"lvl3","url":"/l06-02-schelling-agents#schelling-environment","position":8},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Schelling Environment","lvl2":"Schelling in Agents.jl"},"content":"Our Schelling environment will be one the built-in Agents.jl spaces\n\nWe’ll use GridSpace\n\nenvironment = GridSpaceSingle((25, 25); periodic = false)\n\n","type":"content","url":"/l06-02-schelling-agents#schelling-environment","position":9},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Rules","lvl2":"Schelling in Agents.jl"},"type":"lvl3","url":"/l06-02-schelling-agents#rules","position":10},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Rules","lvl2":"Schelling in Agents.jl"},"content":"The last part of our ABM that we need to specify is the rules for how agents respond to the environment and state\n\nOur rule is that agents will choose to move to an empty grid space if they have less than wanted_neighbors neighbors of the same group\n\nAgents.jl requires us to implement these rules in a method agent_step!(agent::SchellingAgent, model)\n\nWe’ll make use of a couple helper functions provided by Agents.jl:\n\nmove_agent_single!: move a single agent to an empty place in the environment. This modifies the pos field of the agent\n\nnearby_agents: return an array of all neighbors of a particular agent. This queries the pos field of all agents\n\nfunction agent_step!(agent::SchellingAgent, model)\n\twant = model.wanted_neighbors\n\thave = 0\n\tfor n in nearby_agents(agent, model)\n\t\tif n.group == agent.group\n\t\t\thave += 1\n\t\tend\n\tend\n\tagent.is_happy = have >= want\n\tif !agent.is_happy\n\t\tmove_agent_single!(agent, model)\n\tend\n\treturn\nend\n\n","type":"content","url":"/l06-02-schelling-agents#rules","position":11},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Combining Agents, Environment, and Rules","lvl2":"Schelling in Agents.jl"},"type":"lvl3","url":"/l06-02-schelling-agents#combining-agents-environment-and-rules","position":12},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Combining Agents, Environment, and Rules","lvl2":"Schelling in Agents.jl"},"content":"We now need to create an instance of the AgentBasedModel (or ABM for short) type\n\nTo construct our instance we need to specify our agent type, our environment, our rules (via agent_step! function), and any additional properties\n\nThese additional properties belong to the model, and can be thought of as parameters that should be calibrated\n\nIn our previous exposition we would have attached these to the environment\n\nproperties = Dict(:wanted_neighbors => 4)\nschelling = AgentBasedModel(SchellingAgent, environment; properties=properties, agent_step! = agent_step!)\n\n","type":"content","url":"/l06-02-schelling-agents#combining-agents-environment-and-rules","position":13},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Add Agents","lvl2":"Schelling in Agents.jl"},"type":"lvl3","url":"/l06-02-schelling-agents#add-agents","position":14},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Add Agents","lvl2":"Schelling in Agents.jl"},"content":"Now we have fully specified the behavior of our ABM, but we have a problem...\n\nWe don’t have any agents!!\n\nTo add agents, we’ll use the add_agent_single!(::SchellingAgent, model) function, which is provided by Agents.jl and knows how to place non-overlapping agents in our environment\n\nThis will set the pos field for our agents\n\nSo that we can run many experiments, we’ll actually create a helper function that will create a new model from scratch and add agents to it\n\nfunction init_schelling(;num_agents_per_group=250)\n\tenvironment = GridSpaceSingle((25, 25), periodic=false)\n\tproperties = Dict(:wanted_neighbors => 4)\n\tmodel = ABM(SchellingAgent, environment; properties=properties, agent_step! = agent_step!)\n\t\n\tid = 0\n\tfor group in 1:2, i in 1:num_agents_per_group\n\t\tagent = SchellingAgent(id+=1, (1, 1), false, group)\n\t\tadd_agent_single!(agent, model)\n\tend\n\tmodel\nend\n\nmodel = init_schelling()\n\n","type":"content","url":"/l06-02-schelling-agents#add-agents","position":15},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Running the Model","lvl2":"Schelling in Agents.jl"},"type":"lvl3","url":"/l06-02-schelling-agents#running-the-model","position":16},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Running the Model","lvl2":"Schelling in Agents.jl"},"content":"To run our model, we need to step forward in time\n\nWe do this using the step! function provided by Agents.jl\n\nThis function will iterate over all the agents in the model and call agent_step! for each of them\n\n# advance one step\nstep!(model)\n\n# advance three steps\nstep!(model, 3)\n\nWe can also use the run function\n\nThis function requires a model, agent_step! function, number of steps and array of agent property names to record\n\nThe output is a DataFrame with all the data\n\nmodel = init_schelling()\nadata = [:pos, :is_happy, :group]  # short for agent data\ndata, _ = run!(model, 10; adata)\ndata\n\n","type":"content","url":"/l06-02-schelling-agents#running-the-model","position":17},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Visualizing the Agents","lvl2":"Schelling in Agents.jl"},"type":"lvl3","url":"/l06-02-schelling-agents#visualizing-the-agents","position":18},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Visualizing the Agents","lvl2":"Schelling in Agents.jl"},"content":"One of the more instructive (and fun!) parts of agent based modeling is visualizing the data\n\nTo do this visualization we will use the abmplot function\n\nusing CairoMakie\n\nagent_color(a) = a.group == 1 ? :blue : :orange\nagent_marker(a) = a.group == 1 ? :circle : :rect\nfigure, _ = abmplot(model; agent_color, agent_marker, agent_size = 10)\nfigure # returning the figure displays it\n\n","type":"content","url":"/l06-02-schelling-agents#visualizing-the-agents","position":19},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Animating the Agents","lvl2":"Schelling in Agents.jl"},"type":"lvl3","url":"/l06-02-schelling-agents#animating-the-agents","position":20},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Animating the Agents","lvl2":"Schelling in Agents.jl"},"content":"We can also create a video that animates our agents moving throughout the system\n\nWe do this using the abmvideo function as follows\n\nmodel = init_schelling();\nabmvideo(\n    \"schelling.mp4\", model;\n    agent_color, agent_marker, agent_size = 10,\n    framerate = 4, frames = 20,\n    title = \"Schelling's segregation model\"\n)\n\n","type":"content","url":"/l06-02-schelling-agents#animating-the-agents","position":21},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Interactive Application","lvl2":"Schelling in Agents.jl"},"type":"lvl3","url":"/l06-02-schelling-agents#interactive-application","position":22},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Interactive Application","lvl2":"Schelling in Agents.jl"},"content":"Agents.jl also makes it very easy to create an interactive application for our model!\n\nWe can do this using the abmexploration function\n\nThis expects a single positional argument:\n\nmodel\n\nWe also have some keyword arguments\n\nparams: Dict mapping model parameters to range of values to test\n\nagent_color, agent_marker, agent_size: control marker color color, symbol, and size as before\n\nadata: Array of (agent_property, summary_func) tuples that specify which data to plot in separate charts\n\nalabels: What label to put on the plots for adata\n\nmodel = init_schelling()\nadata = [(:is_happy, sum)]\nalabels = [\"n_happy\"]\nparameter_range = Dict(:wanted_neighbors => 0:8)\nfigure, abmobs = abmexploration(\n    model;\n    adata, alabels,\n    agent_color, agent_marker, agent_size = 10,\n    params=parameter_range,\n)\nfigure\n\n","type":"content","url":"/l06-02-schelling-agents#interactive-application","position":23},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl2":"Running Julia Code in the REPL"},"type":"lvl2","url":"/l06-02-schelling-agents#running-julia-code-in-the-repl","position":24},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl2":"Running Julia Code in the REPL"},"content":"In order to use the interactive app we need to run the code from the Julia REPL (not inside VS Code or Jupyter)\n\nThe REPL (Read-Eval-Print-Loop) is the default way to run Julia interactively\n\nLet’s learn about the REPL before we run our interactive visualization","type":"content","url":"/l06-02-schelling-agents#running-julia-code-in-the-repl","position":25},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"The Julia REPL","lvl2":"Running Julia Code in the REPL"},"type":"lvl3","url":"/l06-02-schelling-agents#the-julia-repl","position":26},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"The Julia REPL","lvl2":"Running Julia Code in the REPL"},"content":"The REPL is typically started either by typing julia in a terminal or by clicking on the Julia icon in your Applications list\n\nOnce started, you will see a prompt julia> where you can enter Julia code\n\nIf you enter code and press Enter, the REPL will evaluate the code and print the result","type":"content","url":"/l06-02-schelling-agents#the-julia-repl","position":27},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"REPL Modes","lvl2":"Running Julia Code in the REPL"},"type":"lvl3","url":"/l06-02-schelling-agents#repl-modes","position":28},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"REPL Modes","lvl2":"Running Julia Code in the REPL"},"content":"The REPL has several modes you can switch between:\n\nDefault mode julia>: Run Julia code and see output (default)\n\nShell mode shell>: Interact with underlying shell/terminal (activate with ;)\n\nHelp mode help?>: Get help on Julia functions (activate with ?)\n\nPackage mode pkg>: Manage Julia packages (activate with ])\n\nTo return to default mode from any other mode, press backspace at an empty prompt\n\nExamples of what each mode prompt looks like:\n\nDefault: julia>\n\nShell: shell>\n\nHelp: help?>\n\nPackage: (@v1.9) pkg>","type":"content","url":"/l06-02-schelling-agents#repl-modes","position":29},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Running our Interactive Schelling Model","lvl2":"Running Julia Code in the REPL"},"type":"lvl3","url":"/l06-02-schelling-agents#running-our-interactive-schelling-model","position":30},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Running our Interactive Schelling Model","lvl2":"Running Julia Code in the REPL"},"content":"Now let’s run our interactive model from the REPL:\n\nOpen a terminal and type julia to start the REPL\n\nNavigate to this notebook’s directory if needed (using ; for shell mode)\n\nCopy and run the code from the cells above to set up the model\n\nRun the interactive visualization code\n\nYou’ll be able to adjust parameters with sliders and see the model update in real-time!\n\n","type":"content","url":"/l06-02-schelling-agents#running-our-interactive-schelling-model","position":31},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl2":"Real-World Implications"},"type":"lvl2","url":"/l06-02-schelling-agents#real-world-implications","position":32},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl2":"Real-World Implications"},"content":"Schelling’s model was groundbreaking for urban planning and social policy\n\nKey insight: segregation doesn’t require intense prejudice - even mild preferences for similar neighbors create strong patterns\n\nApplications beyond racial segregation:\n\nIncome clustering in neighborhoods\n\nSocial media echo chambers and political polarization\n\nClustering in high school cafeterias\n\nAcademic discipline segregation in universities\n\nModel limitations: Reality includes housing costs, school quality, employment access, historical policies\n\nPolicy implication: Simply reducing prejudice may not eliminate segregation - structural interventions may be needed\n\n","type":"content","url":"/l06-02-schelling-agents#real-world-implications","position":33},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl2":"Exercises"},"type":"lvl2","url":"/l06-02-schelling-agents#exercises","position":34},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl2":"Exercises"},"content":"","type":"content","url":"/l06-02-schelling-agents#exercises","position":35},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Exercise 1: Parameter Sensitivity Analysis","lvl2":"Exercises"},"type":"lvl3","url":"/l06-02-schelling-agents#exercise-1-parameter-sensitivity-analysis","position":36},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Exercise 1: Parameter Sensitivity Analysis","lvl2":"Exercises"},"content":"Using the interactive app or by modifying the code, explore how different wanted_neighbors values affect segregation:\n\nRun the model with wanted_neighbors = 1 (agents want just 1 similar neighbor)\n\nObserve the final pattern. Is there segregation?\n\nRun with wanted_neighbors = 3 (moderate preference)\n\nHow does the pattern differ? How many steps to stability?\n\nRun with wanted_neighbors = 6 (strong preference)\n\nWhat happens? Do all agents become happy?\n\nDocument your findings:\n\nAt what threshold does segregation become noticeable?\n\nWhat happens when the threshold is too high?\n\nHow does empty space (less than 500 agents total) affect the patterns?\n\n","type":"content","url":"/l06-02-schelling-agents#exercise-1-parameter-sensitivity-analysis","position":37},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Exercise 2: Model Extensions","lvl2":"Exercises"},"type":"lvl3","url":"/l06-02-schelling-agents#exercise-2-model-extensions","position":38},{"hierarchy":{"lvl1":"Schelling Model with Agents.jl","lvl3":"Exercise 2: Model Extensions","lvl2":"Exercises"},"content":"Modify the Schelling model to explore these variations:\n\nThree groups instead of two:\n\nAdd a third group (e.g., green agents)\n\nWhat patterns emerge with three groups?\n\nHint: Modify the init_schelling function to have for group in 1:3\n\nAsymmetric populations:\n\nTry 400 agents of group 1 and 100 agents of group 2\n\nDoes the minority group cluster more tightly?\n\nWhat happens to the majority group’s distribution?\n\nDifferent happiness thresholds per group:\n\nModify so group 1 wants 3 similar neighbors, group 2 wants 5\n\nWhich group ends up more segregated?\n\nWhat does this suggest about tolerance and outcomes?\n\nDistance-based happiness (Advanced):\n\nInstead of just counting similar neighbors, weight them by distance\n\nImmediate neighbors count as 1.0, diagonal neighbors as 0.7\n\nHow does this change the segregation patterns?\n\nChoose at least one modification to implement and document your observations.","type":"content","url":"/l06-02-schelling-agents#exercise-2-model-extensions","position":39},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice"},"type":"lvl1","url":"/l07-01-abm-money","position":0},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice"},"content":"Computational Analysis of Social Complexity\n\nPrerequisites\n\nABM\n\nShelling segregation model\n\nOutcomes\n\nRecall key components of ABM\n\nReview additional example of ABM in Julia\n\nReferences\n\nhttps://​proceedings​.scipy​.org​/articles​/Majora​-7b98e3ed​-009​.pdf\n\nhttps://​juliadynamics​.github​.io​/Agents​.jl​/stable/\n\nhttps://​juliadynamics​.github​.io​/AgentsExampleZoo​.jl​/dev​/examples​/wealth​_distribution/\n\n","type":"content","url":"/l07-01-abm-money","position":1},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl2":"Agent Based Models"},"type":"lvl2","url":"/l07-01-abm-money#agent-based-models","position":2},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl2":"Agent Based Models"},"content":"Agent based models are...\n\nAn approximation to some complex system (a model)\n\nUsed in various fields including biology, epidemiology, economics, etc.\n\nComposed of three key elements: (1) Agents (2) Environment (3) Rules\n\n","type":"content","url":"/l07-01-abm-money#agent-based-models","position":3},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl2":"Schelling Segregation Model"},"type":"lvl2","url":"/l07-01-abm-money#schelling-segregation-model","position":4},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl2":"Schelling Segregation Model"},"content":"Recall the Schelling segregation model...\n\nAgents: individuals/families seeking a home in a neighborhood. Have a type and hapiness. Agents are happy if least N of their neighbors are same type\n\nEnvironment: grid of “lots” or homes where agents can live\n\nRules: All unhappy agents move to a new random home in the environment\n\n","type":"content","url":"/l07-01-abm-money#schelling-segregation-model","position":5},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl3":"Schelling Takeaways","lvl2":"Schelling Segregation Model"},"type":"lvl3","url":"/l07-01-abm-money#schelling-takeaways","position":6},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl3":"Schelling Takeaways","lvl2":"Schelling Segregation Model"},"content":"Very simplistic view of agents (people) and decision making criterion (rules)\n\nAgents only considered immediate neighbors when deciding to move (locality)\n\nSimplistic, local behavior led to stark aggregate results: segregation of neighborhoods into agent types\n\nAgents.jl implementation very straightforward: struct to represent agent, struct (Agents.jl defined) to represent environment, function to represent rules for single agent\n\n","type":"content","url":"/l07-01-abm-money#schelling-takeaways","position":7},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl2":"Plan today"},"type":"lvl2","url":"/l07-01-abm-money#plan-today","position":8},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl2":"Plan today"},"content":"See example of second model\n\nBreak into groups and study example models from the \n\nAgents.jl model zoo\n\nPresent model your group studied\n\n","type":"content","url":"/l07-01-abm-money#plan-today","position":9},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl2":"Money Model"},"type":"lvl2","url":"/l07-01-abm-money#money-model","position":10},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl2":"Money Model"},"content":"Agents:\n\nN Agents\n\nAll start with 1.0 wealth\n\nEnvironment: none -- they just exist ;)\n\nRules:\n\nIf agent has at least 1.0 wealth, gives 1.0 wealth to another agent\n\nIf agent has 0 wealth, does nothing\n\n","type":"content","url":"/l07-01-abm-money#money-model","position":11},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl3":"Agents","lvl2":"Money Model"},"type":"lvl3","url":"/l07-01-abm-money#agents","position":12},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl3":"Agents","lvl2":"Money Model"},"content":"\n\n# import Pkg\n# Pkg.activate(\".\")\n# Pkg.instantiate()\n\nusing Agents, Random, DataFrames\n\n@agent struct MoneyAgent(NoSpaceAgent)\n    wealth::Int\nend\n\n","type":"content","url":"/l07-01-abm-money#agents","position":13},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl3":"Rules","lvl2":"Money Model"},"type":"lvl3","url":"/l07-01-abm-money#rules","position":14},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl3":"Rules","lvl2":"Money Model"},"content":"\n\nfunction agent_step!(agent, model)\n    if agent.wealth == 0\n        return\n    end\n    recipient = random_agent(model)\n    agent.wealth -= 1\n    recipient.wealth += 1\nend\n\n","type":"content","url":"/l07-01-abm-money#rules","position":15},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl3":"Model","lvl2":"Money Model"},"type":"lvl3","url":"/l07-01-abm-money#model","position":16},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl3":"Model","lvl2":"Money Model"},"content":"\n\nfunction money_model(; N = 100)\n    m = ABM(MoneyAgent; agent_step!)\n    for _ in 1:N\n        add_agent!(m, 1)\n    end\n    return m\nend\n\nmoney_model()\n\n","type":"content","url":"/l07-01-abm-money#model","position":17},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl3":"Simulation","lvl2":"Money Model"},"type":"lvl3","url":"/l07-01-abm-money#simulation","position":18},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl3":"Simulation","lvl2":"Money Model"},"content":"\n\nm = money_model(N=2000)\nadata = [:wealth]\ndf, _ = run!(m, 10; adata)\n\nusing CairoMakie\n\nhist(\n    filter(x -> x.time == 10, df).wealth;\n    bins = collect(0:9),\n    color = cgrad(:viridis)[28:28:256],\n)\n\nWhat do we see? With 2000 agents starting with equal wealth (1 unit each), after just 10 steps most agents have 0 or 1 units of wealth while very few have accumulated 5+ units\n\nThis concentration of wealth in the hands of a few emerges naturally from random exchanges!\n\nAbove we see the famous “power law” pattern\n\nThis is a common result in many areas of economics: that activity or wealth is concentrated in the very few (the 1%)\n\nReferences: \n\nGabaix (2016), \n\nhttps://​www​.sciencedirect​.com​/science​/article​/abs​/pii​/S0378437197002173, \n\nhttps://​www​.theguardian​.com​/commentisfree​/2011​/nov​/11​/occupy​-movement​-wealth​-power​-law​-distribution\n\n","type":"content","url":"/l07-01-abm-money#simulation","position":19},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl3":"Exercise: Effect of Population Size","lvl2":"Money Model"},"type":"lvl3","url":"/l07-01-abm-money#exercise-effect-of-population-size","position":20},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl3":"Exercise: Effect of Population Size","lvl2":"Money Model"},"content":"Try running the simulation with different population sizes to see how the wealth distribution changes:\n\nRun with N=100, N=500, and N=5000\n\nCompare the histograms - does the power law pattern persist?\n\nHow many steps does it take for the pattern to emerge with different N?\n\n","type":"content","url":"/l07-01-abm-money#exercise-effect-of-population-size","position":21},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl2":"Money Model with space"},"type":"lvl2","url":"/l07-01-abm-money#money-model-with-space","position":22},{"hierarchy":{"lvl1":"Agent Based Models Review/Practice","lvl2":"Money Model with space"},"content":"Let’s expand our environment to a 2d-grid and only allow sharing wealth amongst neighbors\n\nChanges relative to previous setup:\n\nAgents now have a position\n\nEnvironment is 2d GridSpace\n\nAgents randomly pick a neighbor to give money to\n\n@agent struct WealthInSpace(GridAgent{2})\n    wealth::Int\nend\n\nfunction agent_step!(agent::WealthInSpace, model)\n    if agent.wealth == 0\n        return\n    end\n\n    recipient = rand(collect(nearby_agents(agent, model)))\n    agent.wealth -= 1\n    recipient.wealth += 1\nend\n\nfunction money_model_2d(; dims = (25, 25))\n    # periodic = true means agents at edges can interact with agents on opposite edge\n    # This creates a torus topology - think of it like Pac-Man where going off one side\n    # brings you to the other side\n    space = GridSpace(dims, periodic = true)\n    model = ABM(WealthInSpace, space; scheduler = Schedulers.Randomly(), agent_step! = agent_step!)\n\n    fill_space!(model, 1)\n    return model\nend\n\nm2d = money_model_2d()\nadata2d = [:wealth, :pos]\ndf2d, _ = run!(m2d, 10; adata=adata2d)\n\nhist(\n    filter(x -> x.time == 10, df2d).wealth;\n    bins = collect(0:9),\n    color = cgrad(:viridis)[28:28:256],\n)\n\nStill a power law... very pervasive!\n\nfunction make_heatmap(model, df, T=maximum(df.step))\n    df_T = filter(x -> x.time == T, df)\n\n    x = combine(groupby(df_T, :pos), :wealth => sum)\n    arr = zeros(Int, size(getfield(model, :space)))\n\n    for r in eachrow(x)\n        arr[r.pos...] += r.wealth_sum\n    end\n\n    figure = Figure(; size = (600, 450))\n    hmap_l = figure[1, 1] = Axis(figure, title=\"T= $T\")\n    hmap = heatmap!(hmap_l, arr; colormap = cgrad(:default))\n    cbar = figure[1, 2] = Colorbar(figure, hmap; width = 30)\n    return figure\nend\n\nfor t in 0:10\n    display(make_heatmap(m2d, df2d, t))\nend","type":"content","url":"/l07-01-abm-money#money-model-with-space","position":23},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model"},"type":"lvl1","url":"/l07-02-abm-paper-virality","position":0},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model"},"content":"Computational Analysis of Social Complexity\n\nPrerequisites\n\nABM concepts\n\nBasic network analysis\n\nData manipulation with DataFrames\n\nOutcomes\n\nBuild an ABM using real-world data\n\nModel citation dynamics in academic networks\n\nAnalyze emergence of “viral” papers and sleeping beauties\n\nReferences\n\nArXiv Dataset: \n\nhttps://​www​.kaggle​.com​/datasets​/Cornell​-University​/arxiv\n\nCitation Network Tools: \n\nhttps://​github​.com​/mattbierbaum​/arxiv​-public​-datasets\n\n","type":"content","url":"/l07-02-abm-paper-virality","position":1},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl2":"Overview"},"type":"lvl2","url":"/l07-02-abm-paper-virality#overview","position":2},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl2":"Overview"},"content":"Academic papers spread through citation networks\n\nSome papers go “viral” quickly, others are “sleeping beauties” that gain citations years later\n\nWe’ll model how papers gain citations based on:\n\nAuthor prestige\n\nTopic trends\n\nNetwork position\n\nQuality/novelty\n\n","type":"content","url":"/l07-02-abm-paper-virality#overview","position":3},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl2":"Part 1: Data Collection & Exploration"},"type":"lvl2","url":"/l07-02-abm-paper-virality#part-1-data-collection-exploration","position":4},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl2":"Part 1: Data Collection & Exploration"},"content":"\n\n","type":"content","url":"/l07-02-abm-paper-virality#part-1-data-collection-exploration","position":5},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Setup and Dependencies","lvl2":"Part 1: Data Collection & Exploration"},"type":"lvl3","url":"/l07-02-abm-paper-virality#setup-and-dependencies","position":6},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Setup and Dependencies","lvl2":"Part 1: Data Collection & Exploration"},"content":"\n\nusing Pkg\nPkg.add([\"JSON3\", \"Downloads\", \"CSV\", \"DataFrames\", \"Graphs\", \"Agents\", \"Random\", \"Statistics\", \"CairoMakie\", \"ProgressMeter\", \"StatsBase\"])\n\nusing JSON3\nusing Downloads\nusing CSV\nusing DataFrames\nusing Graphs\nusing Agents\nusing Random\nusing Statistics\nusing CairoMakie\nusing Dates\nusing StatsBase\n\n","type":"content","url":"/l07-02-abm-paper-virality#setup-and-dependencies","position":7},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Download Sample ArXiv Data","lvl2":"Part 1: Data Collection & Exploration"},"type":"lvl3","url":"/l07-02-abm-paper-virality#download-sample-arxiv-data","position":8},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Download Sample ArXiv Data","lvl2":"Part 1: Data Collection & Exploration"},"content":"For this example, we’ll work with a subset of ArXiv papers. In practice, you would download the full dataset from Kaggle.\n\n# For demonstration, we'll create synthetic data that mimics ArXiv structure\n# In practice, download from: https://www.kaggle.com/datasets/Cornell-University/arxiv\n\nfunction create_sample_arxiv_data(n_papers=1000, n_authors=300)\n    Random.seed!(42)\n\n    # Create authors with varying prestige\n    authors = DataFrame(\n        author_id = 1:n_authors,\n        name = [\"Author_$i\" for i in 1:n_authors],\n        h_index = rand(1:50, n_authors),\n        institution_rank = rand(1:100, n_authors)\n    )\n\n    # Create papers\n    papers = DataFrame()\n    papers.paper_id = 1:n_papers\n    papers.title = [\"Paper_$i\" for i in 1:n_papers]\n    papers.year = rand(2010:2023, n_papers)\n    papers.month = rand(1:12, n_papers)\n    papers.category = rand([\"cs.AI\", \"cs.LG\", \"stat.ML\", \"physics\", \"math\"], n_papers)\n    papers.abstract_length = rand(100:500, n_papers)\n    papers.n_authors = rand(1:5, n_papers)\n    papers.lead_author_id = rand(1:n_authors, n_papers)\n    papers.quality_score = rand(n_papers)  # Hidden variable representing paper quality\n\n    # Create citation network (papers cite older papers)\n    citations = DataFrame(citing_paper=Int[], cited_paper=Int[], citation_year=Int[])\n\n    for i in 1:n_papers\n        paper_year = papers.year[i]\n        # Papers can only cite older papers\n        older_papers = findall(papers.year .< paper_year)\n        if length(older_papers) > 0\n            n_citations = min(rand(0:20), length(older_papers))\n            if n_citations > 0\n                cited = sample(older_papers, n_citations, replace=false)\n                for c in cited\n                    push!(citations, (i, c, paper_year + rand(0:2)))\n                end\n            end\n        end\n    end\n\n    return papers, authors, citations\nend\n\npapers_df, authors_df, citations_df = create_sample_arxiv_data()\nprintln(\"Generated $(nrow(papers_df)) papers, $(nrow(authors_df)) authors, $(nrow(citations_df)) citations\")\n\n","type":"content","url":"/l07-02-abm-paper-virality#download-sample-arxiv-data","position":9},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Explore the Data","lvl2":"Part 1: Data Collection & Exploration"},"type":"lvl3","url":"/l07-02-abm-paper-virality#explore-the-data","position":10},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Explore the Data","lvl2":"Part 1: Data Collection & Exploration"},"content":"\n\n# Show sample of papers\nfirst(papers_df, 5)\n\n# Citation statistics\ncitation_counts = combine(groupby(citations_df, :cited_paper), nrow => :n_citations)\ndescribe(citation_counts.n_citations)\n\n# Visualize citation distribution (classic power law)\nfig = Figure()\nax = Axis(fig[1, 1], xlabel=\"Number of Citations\", ylabel=\"Count\", title=\"Citation Distribution\")\nhist!(ax, citation_counts.n_citations, bins=20)\nfig\n\n","type":"content","url":"/l07-02-abm-paper-virality#explore-the-data","position":11},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Analyze Network Structure","lvl2":"Part 1: Data Collection & Exploration"},"type":"lvl3","url":"/l07-02-abm-paper-virality#analyze-network-structure","position":12},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Analyze Network Structure","lvl2":"Part 1: Data Collection & Exploration"},"content":"\n\n# Build citation graph\nfunction build_citation_graph(papers_df, citations_df)\n    n_papers = nrow(papers_df)\n    g = SimpleDiGraph(n_papers)\n\n    for row in eachrow(citations_df)\n        add_edge!(g, row.citing_paper, row.cited_paper)\n    end\n\n    return g\nend\n\ncitation_graph = build_citation_graph(papers_df, citations_df)\nprintln(\"Graph has $(nv(citation_graph)) nodes and $(ne(citation_graph)) edges\")\nprintln(\"Average degree: $(round(mean(degree(citation_graph)), digits=2))\")\n\n","type":"content","url":"/l07-02-abm-paper-virality#analyze-network-structure","position":13},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl2":"Part 2: Agent-Based Model Design"},"type":"lvl2","url":"/l07-02-abm-paper-virality#part-2-agent-based-model-design","position":14},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl2":"Part 2: Agent-Based Model Design"},"content":"","type":"content","url":"/l07-02-abm-paper-virality#part-2-agent-based-model-design","position":15},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Model Components","lvl2":"Part 2: Agent-Based Model Design"},"type":"lvl3","url":"/l07-02-abm-paper-virality#model-components","position":16},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Model Components","lvl2":"Part 2: Agent-Based Model Design"},"content":"Agents: Research papers\n\nProperties: quality, author prestige, field, age, citation count\n\nBehavior: Papers get “read” by researchers who may cite them\n\nEnvironment: Academic field with trending topics\n\nTopic hotness varies over time\n\nConferences/journals provide visibility boosts\n\nRules:\n\nEach time step, new papers are “published”\n\nResearchers “read” papers based on:\n\nRecent publications (recency bias)\n\nHigh citation count (preferential attachment)\n\nAuthor prestige\n\nTopic match with current trends\n\nRead papers get cited with probability based on quality\n\n","type":"content","url":"/l07-02-abm-paper-virality#model-components","position":17},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Define Agent Structure","lvl2":"Part 2: Agent-Based Model Design"},"type":"lvl3","url":"/l07-02-abm-paper-virality#define-agent-structure","position":18},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Define Agent Structure","lvl2":"Part 2: Agent-Based Model Design"},"content":"\n\n@agent struct Paper(NoSpaceAgent)\n    # Fixed properties\n    quality::Float64\n    author_prestige::Float64\n    field::String\n    publication_time::Int\n\n    # Dynamic properties\n    citations::Int\n    reads::Int  # Times the paper has been read\n    age::Int\nend\n\n","type":"content","url":"/l07-02-abm-paper-virality#define-agent-structure","position":19},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Define Model Properties","lvl2":"Part 2: Agent-Based Model Design"},"type":"lvl3","url":"/l07-02-abm-paper-virality#define-model-properties","position":20},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Define Model Properties","lvl2":"Part 2: Agent-Based Model Design"},"content":"\n\nmutable struct ModelProperties\n    current_time::Int\n    field_trends::Dict{String, Float64}  # How \"hot\" each field is\n    n_researchers::Int  # Number of researchers reading papers each time step\n    papers_per_researcher::Int  # Papers read per researcher per time step\n    citation_prob_base::Float64  # Base probability of citing a read paper\n    new_papers_per_step::Int  # New papers published each time step\nend\n\n","type":"content","url":"/l07-02-abm-paper-virality#define-model-properties","position":21},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Model Rules","lvl2":"Part 2: Agent-Based Model Design"},"type":"lvl3","url":"/l07-02-abm-paper-virality#model-rules","position":22},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Model Rules","lvl2":"Part 2: Agent-Based Model Design"},"content":"\n\nfunction model_step!(model)\n    props = model.properties\n    props.current_time += 1\n\n    # Update field trends (random walk)\n    for field in keys(props.field_trends)\n        props.field_trends[field] = clamp(props.field_trends[field] + randn() * 0.1, 0.1, 2.0)\n    end\n\n    # Age all papers\n    for paper in allagents(model)\n        paper.age += 1\n    end\n\n    # Researchers read and cite papers\n    all_papers = collect(allagents(model))\n    if length(all_papers) > 0\n        for _ in 1:props.n_researchers\n            # Select papers to read (biased selection)\n            papers_to_read = select_papers_to_read(all_papers, props.papers_per_researcher, props)\n\n            for paper in papers_to_read\n                paper.reads += 1\n\n                # Decide whether to cite (based on quality and other factors)\n                cite_prob = calculate_citation_probability(paper, props)\n                if rand() < cite_prob\n                    paper.citations += 1\n                end\n            end\n        end\n    end\n\n    # Publish new papers\n    for _ in 1:props.new_papers_per_step\n        field = sample(collect(keys(props.field_trends)))\n        add_agent!(\n            model,\n            rand(),  # quality\n            rand(),  # author_prestige\n            field,\n            props.current_time,\n            0,  # citations\n            0,  # reads\n            0   # age\n        )\n    end\nend\n\nfunction select_papers_to_read(papers, n, props)\n    if length(papers) <= n\n        return papers\n    end\n\n    # Calculate selection weights\n    weights = Float64[]\n    for paper in papers\n        # Recency bias\n        recency_weight = exp(-paper.age / 365.0)  # Decay over a year\n\n        # Preferential attachment (rich get richer)\n        citation_weight = log(2 + paper.citations)\n\n        # Field trendiness\n        trend_weight = get(props.field_trends, paper.field, 1.0)\n\n        # Author prestige\n        prestige_weight = paper.author_prestige\n\n        push!(weights, recency_weight * citation_weight * trend_weight * prestige_weight)\n    end\n\n    # Weighted sampling without replacement\n    selected_indices = sample(1:length(papers), Weights(weights), n, replace=false)\n    return papers[selected_indices]\nend\n\nfunction calculate_citation_probability(paper, props)\n    # Base probability modified by paper quality and field trend\n    base_prob = props.citation_prob_base\n    quality_modifier = paper.quality\n    trend_modifier = get(props.field_trends, paper.field, 1.0)\n\n    return clamp(base_prob * quality_modifier * trend_modifier, 0.0, 1.0)\nend\n\n","type":"content","url":"/l07-02-abm-paper-virality#model-rules","position":23},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Initialize Model with Real Data","lvl2":"Part 2: Agent-Based Model Design"},"type":"lvl3","url":"/l07-02-abm-paper-virality#initialize-model-with-real-data","position":24},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Initialize Model with Real Data","lvl2":"Part 2: Agent-Based Model Design"},"content":"\n\nfunction initialize_model_from_data(papers_df, authors_df;\n                                   n_researchers=100,\n                                   papers_per_researcher=5)\n    # Create model properties\n    fields = unique(papers_df.category)\n    field_trends = Dict(f => 1.0 for f in fields)\n\n    props = ModelProperties(\n        0,  # current_time\n        field_trends,\n        n_researchers,\n        papers_per_researcher,\n        0.1,  # citation_prob_base\n        10   # new_papers_per_step\n    )\n\n    # Create model - properties need to be wrapped in Dict\n    model = ABM(Paper; properties=Dict(:properties => props), model_step!)\n\n    # Add initial papers from data\n    for row in eachrow(papers_df[1:min(100, nrow(papers_df)), :])  # Start with first 100 papers\n        author = authors_df[row.lead_author_id, :]\n        prestige = author.h_index / 50.0  # Normalize to [0, 1]\n\n        add_agent!(\n            model,\n            row.quality_score,\n            prestige,\n            row.category,\n            0,  # publication_time\n            0,  # citations\n            0,  # reads\n            0   # age\n        )\n    end\n\n    return model\nend\n\nmodel = initialize_model_from_data(papers_df, authors_df)\nprintln(\"Model initialized with $(nagents(model)) papers\")\n\n","type":"content","url":"/l07-02-abm-paper-virality#initialize-model-with-real-data","position":25},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl2":"Part 3: Simulation & Analysis"},"type":"lvl2","url":"/l07-02-abm-paper-virality#part-3-simulation-analysis","position":26},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl2":"Part 3: Simulation & Analysis"},"content":"\n\n","type":"content","url":"/l07-02-abm-paper-virality#part-3-simulation-analysis","position":27},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Run Simulation","lvl2":"Part 3: Simulation & Analysis"},"type":"lvl3","url":"/l07-02-abm-paper-virality#run-simulation","position":28},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Run Simulation","lvl2":"Part 3: Simulation & Analysis"},"content":"\n\n# Data to collect\nadata = [:citations, :reads, :age, :quality, :field]\n\n# Run simulation\nn_steps = 365  # Simulate one year\nadf, _ = run!(model, n_steps; adata)\n\nprintln(\"Simulation complete. Final model has $(nagents(model)) papers\")\n\n","type":"content","url":"/l07-02-abm-paper-virality#run-simulation","position":29},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Analyze Citation Dynamics","lvl2":"Part 3: Simulation & Analysis"},"type":"lvl3","url":"/l07-02-abm-paper-virality#analyze-citation-dynamics","position":30},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Analyze Citation Dynamics","lvl2":"Part 3: Simulation & Analysis"},"content":"\n\n# Get final state\nfinal_data = filter(row -> row.time == n_steps, adf)\n\n# Citation distribution\nfig = Figure(resolution=(800, 300))\n\n# Histogram of citations\nax1 = Axis(fig[1, 1], xlabel=\"Citations\", ylabel=\"Count\", title=\"Final Citation Distribution\")\nhist!(ax1, final_data.citations, bins=20)\n\n# Quality vs Citations scatter\nax2 = Axis(fig[1, 2], xlabel=\"Quality\", ylabel=\"Citations\", title=\"Quality vs Citations\")\nscatter!(ax2, final_data.quality, final_data.citations, markersize=5, alpha=0.5)\n\nfig\n\n# Track citation growth over time\nfunction analyze_citation_patterns(adf)\n    # Group by paper ID first, then process each group\n    velocities = Dict{Int, Vector{Float64}}()\n\n    # Use groupby to efficiently iterate through papers\n    for group in groupby(adf, :id)\n        paper_id = first(group.id)\n\n        # Sort by time and get citations\n        sorted_times = sort(group, :time)\n        citations_over_time = sorted_times.citations\n\n        if length(citations_over_time) > 1\n            velocity = diff(citations_over_time)\n            velocities[paper_id] = velocity\n        end\n    end\n\n    return velocities\nend\n\nvelocities = analyze_citation_patterns(adf)\n\n# Find viral papers (high early velocity)\nviral_papers = []\nsleeping_beauties = []\n\nfor (paper_id, vel) in velocities\n    if length(vel) >= 10\n        early_velocity = mean(vel[1:min(10, length(vel))])\n        late_velocity = mean(vel[max(1, end-10):end])\n\n        if early_velocity > 0.5  # Threshold for \"viral\"\n            push!(viral_papers, paper_id)\n        elseif early_velocity < 0.1 && late_velocity > 0.3  # Sleeping beauty pattern\n            push!(sleeping_beauties, paper_id)\n        end\n    end\nend\n\nprintln(\"Found $(length(viral_papers)) viral papers\")\nprintln(\"Found $(length(sleeping_beauties)) sleeping beauties\")\n\n","type":"content","url":"/l07-02-abm-paper-virality#analyze-citation-dynamics","position":31},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Visualize Citation Trajectories","lvl2":"Part 3: Simulation & Analysis"},"type":"lvl3","url":"/l07-02-abm-paper-virality#visualize-citation-trajectories","position":32},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl3":"Visualize Citation Trajectories","lvl2":"Part 3: Simulation & Analysis"},"content":"\n\n# Plot citation trajectories for different paper types\nfig = Figure(resolution=(800, 400))\nax = Axis(fig[1, 1], xlabel=\"Time\", ylabel=\"Cumulative Citations\",\n          title=\"Citation Trajectories\")\n\n# Plot a sample of papers\nsample_papers = vcat(\n    length(viral_papers) > 0 ? viral_papers[1:min(3, length(viral_papers))] : [],\n    length(sleeping_beauties) > 0 ? sleeping_beauties[1:min(3, length(sleeping_beauties))] : [],\n    rand(setdiff(unique(adf.id), vcat(viral_papers, sleeping_beauties)), min(3, nagents(model)))\n)\n\ncolors = [:red, :red, :red, :blue, :blue, :blue, :gray, :gray, :gray]\nlabels = [\"Viral\", \"\", \"\", \"Sleeping Beauty\", \"\", \"\", \"Normal\", \"\", \"\"]\n\nfor (i, paper_id) in enumerate(sample_papers)\n    paper_data = filter(row -> row.id == paper_id, adf)\n    sort!(paper_data, :time)\n\n    if nrow(paper_data) > 0\n        lines!(ax, paper_data.time, paper_data.citations,\n               color=colors[min(i, length(colors))],\n               label=labels[min(i, length(labels))],\n               linewidth=2)\n    end\nend\n\naxislegend(ax, unique=true, position=:lt)\nfig\n\n","type":"content","url":"/l07-02-abm-paper-virality#visualize-citation-trajectories","position":33},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl2":"Part 4: Parameter Calibration from Real Data"},"type":"lvl2","url":"/l07-02-abm-paper-virality#part-4-parameter-calibration-from-real-data","position":34},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl2":"Part 4: Parameter Calibration from Real Data"},"content":"\n\n# Calibrate model parameters from real citation data\nfunction calibrate_model(citations_df, papers_df)\n    # Calculate empirical citation rate\n    citation_counts = combine(groupby(citations_df, :cited_paper), nrow => :n_citations)\n    mean_citations = mean(citation_counts.n_citations)\n\n    # Calculate field popularity from data\n    field_papers = combine(groupby(papers_df, :category), nrow => :count)\n    total_papers = sum(field_papers.count)\n    field_popularity = Dict(row.category => row.count / total_papers\n                          for row in eachrow(field_papers))\n\n    # Calculate author prestige distribution\n    author_prestiges = Float64[]\n    for paper in eachrow(papers_df)\n        if paper.lead_author_id <= nrow(authors_df)\n            push!(author_prestiges, authors_df[paper.lead_author_id, :h_index] / 50.0)\n        end\n    end\n    mean_prestige = mean(author_prestiges)\n\n    println(\"Calibration Results:\")\n    println(\"  Mean citations per paper: $(round(mean_citations, digits=2))\")\n    println(\"  Mean author prestige: $(round(mean_prestige, digits=3))\")\n    println(\"  Field distribution:\")\n    for (field, pop) in field_popularity\n        println(\"    $field: $(round(pop * 100, digits=1))%\")\n    end\n\n    return Dict(\n        \"mean_citations\" => mean_citations,\n        \"field_trends\" => field_popularity,\n        \"mean_prestige\" => mean_prestige\n    )\nend\n\ncalibration = calibrate_model(citations_df, papers_df)\n\n","type":"content","url":"/l07-02-abm-paper-virality#part-4-parameter-calibration-from-real-data","position":35},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl2":"Exercises"},"type":"lvl2","url":"/l07-02-abm-paper-virality#exercises","position":36},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl2":"Exercises"},"content":"Network Effects: Modify the model to include co-authorship networks. Papers by frequently collaborating authors should have higher visibility.\n\nConference Boost: Add “conference” events where papers in certain fields get temporary visibility boosts.\n\nReal Data: Download the full ArXiv dataset from Kaggle and run the model with real papers. Compare simulated citation patterns to actual ones.\n\nIntervention Analysis: What happens if we:\n\nIncrease open access (higher base read probability)?\n\nAdd social media promotion (viral boost for some papers)?\n\nImplement better recommendation systems (quality-based selection)?\n\n","type":"content","url":"/l07-02-abm-paper-virality#exercises","position":37},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl2":"Summary"},"type":"lvl2","url":"/l07-02-abm-paper-virality#summary","position":38},{"hierarchy":{"lvl1":"Academic Paper Virality: An Agent-Based Model","lvl2":"Summary"},"content":"Built an ABM of academic paper citations using real data structure\n\nObserved emergence of power law citation distributions\n\nIdentified viral papers and sleeping beauties\n\nModel can help understand:\n\nHow quality vs. marketing affects impact\n\nRole of author prestige and networks\n\nEffects of field trends on citation patterns","type":"content","url":"/l07-02-abm-paper-virality#summary","position":39}]}